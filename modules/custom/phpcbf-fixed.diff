--- qed42_activities/vendor/antoineaugusti/google-books/src/InvalidResponseException.php
+++ PHP_CodeSniffer
@@ -5,5 +5,6 @@
 /**
  *
  */
-class InvalidResponseException extends \Exception {
+class InvalidResponseException extends \Exception
+{
 }

--- qed42_activities/vendor/antoineaugusti/google-books/src/Book.php
+++ PHP_CodeSniffer
@@ -7,48 +7,50 @@
 /**
  *
  */
-class Book {
-  public $title;
-  public $subtitle;
-  public $authors;
-  public $printType;
-  public $pageCount;
-  public $publisher;
-  public $publishedDate;
-  public $publishedDateFormat;
-  public $averageRating;
-  public $thumbnail;
-  public $language;
-  public $categories;
+class Book
+{
+    public $title;
+    public $subtitle;
+    public $authors;
+    public $printType;
+    public $pageCount;
+    public $publisher;
+    public $publishedDate;
+    public $publishedDateFormat;
+    public $averageRating;
+    public $thumbnail;
+    public $language;
+    public $categories;
 
-  /**
+    /**
    * New up a book.
    *
-   * @param string $title
-   * @param string $subtitle
-   * @param array $authors
-   * @param string $printType
-   * @param int $pageCount
-   * @param string $publisher
+   * @param string    $title
+   * @param string    $subtitle
+   * @param array     $authors
+   * @param string    $printType
+   * @param int       $pageCount
+   * @param string    $publisher
    * @param \DateTime $publishedDate
-   * @param int $averageRating
-   * @param string $thumbnail
-   * @param string $language
-   * @param array $categories
+   * @param int       $averageRating
+   * @param string    $thumbnail
+   * @param string    $language
+   * @param array     $categories
    */
-  public function __construct($title, $subtitle, array $authors, $printType, $pageCount, $publisher, DateTime $publishedDate = NULL, $publishedDateFormat, $averageRating, $thumbnail, $language, array $categories) {
-    $this->title = $title;
-    $this->subtitle = $subtitle;
-    $this->authors = $authors;
-    $this->printType = $printType;
-    $this->pageCount = $pageCount;
-    $this->publisher = $publisher;
-    $this->publishedDate = $publishedDate;
-    $this->publishedDateFormat = $publishedDateFormat;
-    $this->averageRating = $averageRating;
-    $this->thumbnail = $thumbnail;
-    $this->language = $language;
-    $this->categories = $categories;
-  }
+    public function __construct($title, $subtitle, array $authors, $printType, $pageCount, $publisher, DateTime $publishedDate = null, $publishedDateFormat, $averageRating, $thumbnail, $language, array $categories) 
+    {
+        $this->title = $title;
+        $this->subtitle = $subtitle;
+        $this->authors = $authors;
+        $this->printType = $printType;
+        $this->pageCount = $pageCount;
+        $this->publisher = $publisher;
+        $this->publishedDate = $publishedDate;
+        $this->publishedDateFormat = $publishedDateFormat;
+        $this->averageRating = $averageRating;
+        $this->thumbnail = $thumbnail;
+        $this->language = $language;
+        $this->categories = $categories;
+    }
 
 }

--- qed42_activities/vendor/antoineaugusti/google-books/src/Fetcher.php
+++ PHP_CodeSniffer
@@ -9,20 +9,22 @@
 /**
  *
  */
-class Fetcher {
-  /**
+class Fetcher
+{
+    /**
    * @var \GuzzleHttp\ClientInterface
    */
-  private $client;
+    private $client;
 
-  /**
+    /**
    * @param \GuzzleHttp\ClientInterface $client
    */
-  public function __construct(ClientInterface $client) {
-    $this->client = $client;
-  }
+    public function __construct(ClientInterface $client) 
+    {
+        $this->client = $client;
+    }
 
-  /**
+    /**
    * Retrieve information about a book given its ISBN.
    *
    * @param string $isbn
@@ -32,97 +34,106 @@
    *
    * @return Book
    */
-  public function forISBN($isbn) {
-    if (!$this->isValidISBN($isbn)) {
-      throw new InvalidArgumentException('ISBN is not valid. Got: ' . $isbn);
-    }
-
-    // Example: https://www.googleapis.com/books/v1/volumes?q=isbn:9780525953739
-    $response = $this->client->request('GET', 'volumes', [
-      'query'       => ['q' => 'isbn:' . $isbn],
-      'http_errors' => FALSE,
-    ]);
-
-    $status = $response->getStatusCode();
-    if ($status != 200) {
-      throw new InvalidResponseException('Invalid response. Status: ' . $status . '. Body: ' . $response->getBody());
-    }
-
-    $res = json_decode($response->getBody(), TRUE);
-
-    $totalItems = intval($res['totalItems']);
-    if ($totalItems != 1) {
-      throw new InvalidResponseException('Did not get 1 result. Got: ' . $totalItems);
+    public function forISBN($isbn) 
+    {
+        if (!$this->isValidISBN($isbn)) {
+            throw new InvalidArgumentException('ISBN is not valid. Got: ' . $isbn);
+        }
+
+        // Example: https://www.googleapis.com/books/v1/volumes?q=isbn:9780525953739
+        $response = $this->client->request(
+            'GET', 'volumes', [
+            'query'       => ['q' => 'isbn:' . $isbn],
+            'http_errors' => false,
+            ]
+        );
+
+        $status = $response->getStatusCode();
+        if ($status != 200) {
+            throw new InvalidResponseException('Invalid response. Status: ' . $status . '. Body: ' . $response->getBody());
+        }
+
+        $res = json_decode($response->getBody(), true);
+
+        $totalItems = intval($res['totalItems']);
+        if ($totalItems != 1) {
+            throw new InvalidResponseException('Did not get 1 result. Got: ' . $totalItems);
+        }
+
+        return $this->extractBook($res);
+    }
+
+    /**
+   *
+   */
+    private function extractBook($res) 
+    {
+        $item = $res['items'][0];
+
+        $publishedDate = $this->getOrDefault($item['volumeInfo'], 'publishedDate', null);
+        list($publishedDate, $publishedDateFormat) = $this->parseDate($publishedDate);
+
+        return new Book(
+            $item['volumeInfo']['title'],
+            $this->getOrDefault($item['volumeInfo'], 'subtitle', null),
+            $this->getOrDefault($item['volumeInfo'], 'authors', null),
+            $this->getOrDefault($item['volumeInfo'], 'printType', null),
+            intval($this->getOrDefault($item['volumeInfo'], 'pageCount', null)),
+            $this->getOrDefault($item['volumeInfo'], 'publisher', null),
+            $publishedDate,
+            $publishedDateFormat,
+            $this->getOrDefault($item['volumeInfo'], 'averageRating', null),
+            $item['volumeInfo']['imageLinks']['thumbnail'],
+            $this->getOrDefault($item['volumeInfo'], 'language', null),
+            $this->getOrDefault($item['volumeInfo'], 'categories', [])
+        );
     }
 
-    return $this->extractBook($res);
-  }
-
-  /**
-   *
-   */
-  private function extractBook($res) {
-    $item = $res['items'][0];
-
-    $publishedDate = $this->getOrDefault($item['volumeInfo'], 'publishedDate', NULL);
-    list($publishedDate, $publishedDateFormat) = $this->parseDate($publishedDate);
-
-    return new Book($item['volumeInfo']['title'],
-        $this->getOrDefault($item['volumeInfo'], 'subtitle', NULL),
-        $this->getOrDefault($item['volumeInfo'], 'authors', NULL),
-        $this->getOrDefault($item['volumeInfo'], 'printType', NULL),
-        intval($this->getOrDefault($item['volumeInfo'], 'pageCount', NULL)),
-        $this->getOrDefault($item['volumeInfo'], 'publisher', NULL),
-        $publishedDate,
-        $publishedDateFormat,
-        $this->getOrDefault($item['volumeInfo'], 'averageRating', NULL),
-        $item['volumeInfo']['imageLinks']['thumbnail'],
-        $this->getOrDefault($item['volumeInfo'], 'language', NULL),
-        $this->getOrDefault($item['volumeInfo'], 'categories', []));
-  }
-
-  /**
+    /**
    * Parse the publication date.
    *
    * @param string $rawDate
    *
    * @return array The publication in DateTime and the date format
    */
-  private function parseDate($rawDate) {
-    foreach (['Y-m-d', 'Y-m', 'Y'] as $dateFormat) {
-      $publishedDate = DateTime::createFromFormat($dateFormat . '|', $rawDate);
-      if ($publishedDate !== FALSE) {
-        break;
-      }
-    }
+    private function parseDate($rawDate) 
+    {
+        foreach (['Y-m-d', 'Y-m', 'Y'] as $dateFormat) {
+            $publishedDate = DateTime::createFromFormat($dateFormat . '|', $rawDate);
+            if ($publishedDate !== false) {
+                break;
+            }
+        }
 
-    if ($publishedDate === FALSE) {
-      $publishedDate = NULL;
-    }
+        if ($publishedDate === false) {
+            $publishedDate = null;
+        }
 
-    return [$publishedDate, $dateFormat];
-  }
+        return [$publishedDate, $dateFormat];
+    }
 
-  /**
+    /**
    *
    */
-  private function getOrDefault($array, $key, $default) {
-    if (array_key_exists($key, $array)) {
-      return $array[$key];
-    }
+    private function getOrDefault($array, $key, $default) 
+    {
+        if (array_key_exists($key, $array)) {
+            return $array[$key];
+        }
 
-    return $default;
-  }
+        return $default;
+    }
 
-  /**
+    /**
    * Check if a given ISBN is valid.
    *
    * @param string $isbn
    *
    * @return bool
    */
-  private function isValidISBN($isbn) {
-    return preg_match('/[0-9]{10,13}/', $isbn);
-  }
+    private function isValidISBN($isbn) 
+    {
+        return preg_match('/[0-9]{10,13}/', $isbn);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/PromiseInterface.php
+++ PHP_CodeSniffer
@@ -11,12 +11,13 @@
  *
  * @link https://promisesaplus.com/
  */
-interface PromiseInterface {
-  const PENDING = 'pending';
-  const FULFILLED = 'fulfilled';
-  const REJECTED = 'rejected';
+interface PromiseInterface
+{
+    const PENDING = 'pending';
+    const FULFILLED = 'fulfilled';
+    const REJECTED = 'rejected';
 
-  /**
+    /**
    * Appends fulfillment and rejection handlers to the promise, and returns
    * a new promise resolving to the return value of the called handler.
    *
@@ -27,12 +28,12 @@
    *
    * @return PromiseInterface
    */
-  public function then(
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public function then(
+        callable $onFulfilled = null,
+        callable $onRejected = null
     );
 
-  /**
+    /**
    * Appends a rejection handler callback to the promise, and returns a new
    * promise resolving to the return value of the callback if it is called,
    * or to its original fulfillment value if the promise is instead
@@ -43,9 +44,9 @@
    *
    * @return PromiseInterface
    */
-  public function otherwise(callable $onRejected);
+    public function otherwise(callable $onRejected);
 
-  /**
+    /**
    * Get the state of the promise ("pending", "rejected", or "fulfilled").
    *
    * The three states can be checked against the constants defined on
@@ -53,34 +54,34 @@
    *
    * @return string
    */
-  public function getState();
+    public function getState();
 
-  /**
+    /**
    * Resolve the promise with the given value.
    *
    * @param mixed $value
    *
    * @throws \RuntimeException if the promise is already resolved.
    */
-  public function resolve($value);
+    public function resolve($value);
 
-  /**
+    /**
    * Reject the promise with the given reason.
    *
    * @param mixed $reason
    *
    * @throws \RuntimeException if the promise is already resolved.
    */
-  public function reject($reason);
+    public function reject($reason);
 
-  /**
+    /**
    * Cancels the promise if possible.
    *
    * @link https://github.com/promises-aplus/cancellation-spec/issues/7
    */
-  public function cancel();
+    public function cancel();
 
-  /**
+    /**
    * Waits until the promise completes if possible.
    *
    * Pass $unwrap as true to unwrap the result of the promise, either
@@ -95,6 +96,6 @@
    * @throws \LogicException if the promise has no wait function or if the
    *                         promise does not settle after waiting.
    */
-  public function wait($unwrap = TRUE);
+    public function wait($unwrap = true);
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/functions.php
+++ PHP_CodeSniffer
@@ -24,17 +24,18 @@
  *
  * @return TaskQueueInterface
  */
-function queue(TaskQueueInterface $assign = NULL) {
-  static $queue;
+function queue(TaskQueueInterface $assign = null) 
+{
+    static $queue;
 
-  if ($assign) {
-    $queue = $assign;
-  }
-  elseif (!$queue) {
-    $queue = new TaskQueue();
-  }
+    if ($assign) {
+        $queue = $assign;
+    }
+    elseif (!$queue) {
+        $queue = new TaskQueue();
+    }
 
-  return $queue;
+    return $queue;
 }
 
 /**
@@ -46,22 +47,25 @@
  *
  * @return PromiseInterface
  */
-function task(callable $task) {
-  $queue = queue();
-  $promise = new Promise([$queue, 'run']);
-  $queue->add(function () use ($task, $promise) {
-    try {
-      $promise->resolve($task());
-    }
-    catch (\Throwable $e) {
-      $promise->reject($e);
-    }
-    catch (\Exception $e) {
-      $promise->reject($e);
-    }
-  });
+function task(callable $task) 
+{
+    $queue = queue();
+    $promise = new Promise([$queue, 'run']);
+    $queue->add(
+        function () use ($task, $promise) {
+            try {
+                $promise->resolve($task());
+            }
+            catch (\Throwable $e) {
+                $promise->reject($e);
+            }
+            catch (\Exception $e) {
+                $promise->reject($e);
+            }
+        }
+    );
 
-  return $promise;
+    return $promise;
 }
 
 /**
@@ -72,21 +76,22 @@
  *
  * @return PromiseInterface
  */
-function promise_for($value) {
-  if ($value instanceof PromiseInterface) {
-    return $value;
-  }
-
-  // Return a Guzzle promise that shadows the given promise.
-  if (method_exists($value, 'then')) {
-    $wfn = method_exists($value, 'wait') ? [$value, 'wait'] : NULL;
-    $cfn = method_exists($value, 'cancel') ? [$value, 'cancel'] : NULL;
-    $promise = new Promise($wfn, $cfn);
-    $value->then([$promise, 'resolve'], [$promise, 'reject']);
-    return $promise;
-  }
+function promise_for($value) 
+{
+    if ($value instanceof PromiseInterface) {
+        return $value;
+    }
 
-  return new FulfilledPromise($value);
+    // Return a Guzzle promise that shadows the given promise.
+    if (method_exists($value, 'then')) {
+        $wfn = method_exists($value, 'wait') ? [$value, 'wait'] : null;
+        $cfn = method_exists($value, 'cancel') ? [$value, 'cancel'] : null;
+        $promise = new Promise($wfn, $cfn);
+        $value->then([$promise, 'resolve'], [$promise, 'reject']);
+        return $promise;
+    }
+
+    return new FulfilledPromise($value);
 }
 
 /**
@@ -98,12 +103,13 @@
  *
  * @return PromiseInterface
  */
-function rejection_for($reason) {
-  if ($reason instanceof PromiseInterface) {
-    return $reason;
-  }
+function rejection_for($reason) 
+{
+    if ($reason instanceof PromiseInterface) {
+        return $reason;
+    }
 
-  return new RejectedPromise($reason);
+    return new RejectedPromise($reason);
 }
 
 /**
@@ -113,8 +119,9 @@
  *
  * @return \Exception|\Throwable
  */
-function exception_for($reason) {
-  return $reason instanceof \Exception || $reason instanceof \Throwable
+function exception_for($reason) 
+{
+    return $reason instanceof \Exception || $reason instanceof \Throwable
         ? $reason
         : new RejectionException($reason);
 }
@@ -126,16 +133,17 @@
  *
  * @return \Iterator
  */
-function iter_for($value) {
-  if ($value instanceof \Iterator) {
-    return $value;
-  }
-  elseif (is_array($value)) {
-    return new \ArrayIterator($value);
-  }
-  else {
-    return new \ArrayIterator([$value]);
-  }
+function iter_for($value) 
+{
+    if ($value instanceof \Iterator) {
+        return $value;
+    }
+    elseif (is_array($value)) {
+        return new \ArrayIterator($value);
+    }
+    else {
+        return new \ArrayIterator([$value]);
+    }
 }
 
 /**
@@ -153,22 +161,23 @@
  *
  * @return array
  */
-function inspect(PromiseInterface $promise) {
-  try {
-    return [
-      'state' => PromiseInterface::FULFILLED,
-      'value' => $promise->wait(),
-    ];
-  }
-  catch (RejectionException $e) {
-    return ['state' => PromiseInterface::REJECTED, 'reason' => $e->getReason()];
-  }
-  catch (\Throwable $e) {
-    return ['state' => PromiseInterface::REJECTED, 'reason' => $e];
-  }
-  catch (\Exception $e) {
-    return ['state' => PromiseInterface::REJECTED, 'reason' => $e];
-  }
+function inspect(PromiseInterface $promise) 
+{
+    try {
+        return [
+        'state' => PromiseInterface::FULFILLED,
+        'value' => $promise->wait(),
+        ];
+    }
+    catch (RejectionException $e) {
+        return ['state' => PromiseInterface::REJECTED, 'reason' => $e->getReason()];
+    }
+    catch (\Throwable $e) {
+        return ['state' => PromiseInterface::REJECTED, 'reason' => $e];
+    }
+    catch (\Exception $e) {
+        return ['state' => PromiseInterface::REJECTED, 'reason' => $e];
+    }
 }
 
 /**
@@ -184,13 +193,14 @@
  *
  * @see GuzzleHttp\Promise\inspect for the inspection state array format.
  */
-function inspect_all($promises) {
-  $results = [];
-  foreach ($promises as $key => $promise) {
-    $results[$key] = inspect($promise);
-  }
+function inspect_all($promises) 
+{
+    $results = [];
+    foreach ($promises as $key => $promise) {
+        $results[$key] = inspect($promise);
+    }
 
-  return $results;
+    return $results;
 }
 
 /**
@@ -208,13 +218,14 @@
  * @throws \Exception on error
  * @throws \Throwable on error in PHP >=7
  */
-function unwrap($promises) {
-  $results = [];
-  foreach ($promises as $key => $promise) {
-    $results[$key] = $promise->wait();
-  }
+function unwrap($promises) 
+{
+    $results = [];
+    foreach ($promises as $key => $promise) {
+        $results[$key] = $promise->wait();
+    }
 
-  return $results;
+    return $results;
 }
 
 /**
@@ -230,9 +241,10 @@
  *
  * @return PromiseInterface
  */
-function all($promises) {
-  $results = [];
-  return each(
+function all($promises) 
+{
+    $results = [];
+    return each(
         $promises,
         function ($value, $idx) use (&$results) {
             $results[$idx] = $value;
@@ -240,10 +252,12 @@
         function ($reason, $idx, Promise $aggregate) {
             $aggregate->reject($reason);
         }
-    )->then(function () use (&$results) {
-        ksort($results);
-        return $results;
-    });
+    )->then(
+        function () use (&$results) {
+            ksort($results);
+            return $results;
+        }
+    );
 }
 
 /**
@@ -257,39 +271,40 @@
  * This prommise is rejected with a {@see GuzzleHttp\Promise\AggregateException}
  * if the number of fulfilled promises is less than the desired $count.
  *
- * @param int $count
+ * @param int   $count
  *   Total number of promises.
  * @param mixed $promises
  *   Promises or values.
  *
  * @return PromiseInterface
  */
-function some($count, $promises) {
-  $results = [];
-  $rejections = [];
+function some($count, $promises) 
+{
+    $results = [];
+    $rejections = [];
 
-  return each(
+    return each(
         $promises,
         function ($value, $idx, PromiseInterface $p) use (&$results, $count) {
-          if ($p->getState() !== PromiseInterface::PENDING) {
-            return;
-          }
+            if ($p->getState() !== PromiseInterface::PENDING) {
+                return;
+            }
             $results[$idx] = $value;
-          if (count($results) >= $count) {
-            $p->resolve(NULL);
-          }
+            if (count($results) >= $count) {
+                $p->resolve(null);
+            }
         },
         function ($reason) use (&$rejections) {
             $rejections[] = $reason;
         }
     )->then(
         function () use (&$results, &$rejections, $count) {
-          if (count($results) !== $count) {
-            throw new AggregateException(
-                'Not enough promises to fulfill count',
-                $rejections
-            );
-          }
+            if (count($results) !== $count) {
+                throw new AggregateException(
+                    'Not enough promises to fulfill count',
+                    $rejections
+                );
+            }
             ksort($results);
             return array_values($results);
         }
@@ -305,10 +320,13 @@
  *
  * @return PromiseInterface
  */
-function any($promises) {
-  return some(1, $promises)->then(function ($values) {
-    return $values[0];
-  });
+function any($promises) 
+{
+    return some(1, $promises)->then(
+        function ($values) {
+            return $values[0];
+        }
+    );
 }
 
 /**
@@ -324,10 +342,11 @@
  *
  * @see GuzzleHttp\Promise\inspect for the inspection state array format.
  */
-function settle($promises) {
-  $results = [];
+function settle($promises) 
+{
+    $results = [];
 
-  return each(
+    return each(
         $promises,
         function ($value, $idx) use (&$results) {
             $results[$idx] = ['state' => PromiseInterface::FULFILLED, 'value' => $value];
@@ -335,10 +354,12 @@
         function ($reason, $idx) use (&$results) {
             $results[$idx] = ['state' => PromiseInterface::REJECTED, 'reason' => $reason];
         }
-    )->then(function () use (&$results) {
-        ksort($results);
-        return $results;
-    });
+    )->then(
+        function () use (&$results) {
+            ksort($results);
+            return $results;
+        }
+    );
 }
 
 /**
@@ -354,7 +375,7 @@
  * index, and the aggregate promise. The callback can invoke any necessary side
  * effects and choose to resolve or reject the aggregate promise if needed.
  *
- * @param mixed $iterable
+ * @param mixed    $iterable
  *   Iterator or array to iterate over.
  * @param callable $onFulfilled
  * @param callable $onRejected
@@ -363,13 +384,15 @@
  */
 function each(
     $iterable,
-    callable $onFulfilled = NULL,
-    callable $onRejected = NULL
+    callable $onFulfilled = null,
+    callable $onRejected = null
 ) {
-  return (new EachPromise($iterable, [
-    'fulfilled' => $onFulfilled,
-    'rejected'  => $onRejected,
-  ]))->promise();
+    return (new EachPromise(
+        $iterable, [
+        'fulfilled' => $onFulfilled,
+        'rejected'  => $onRejected,
+        ]
+    ))->promise();
 }
 
 /**
@@ -380,24 +403,26 @@
  * pending promises and returns a numeric concurrency limit value to allow for
  * dynamic a concurrency size.
  *
- * @param mixed $iterable
+ * @param mixed        $iterable
  * @param int|callable $concurrency
- * @param callable $onFulfilled
- * @param callable $onRejected
+ * @param callable     $onFulfilled
+ * @param callable     $onRejected
  *
  * @return PromiseInterface
  */
 function each_limit(
     $iterable,
     $concurrency,
-    callable $onFulfilled = NULL,
-    callable $onRejected = NULL
+    callable $onFulfilled = null,
+    callable $onRejected = null
 ) {
-  return (new EachPromise($iterable, [
-    'fulfilled'   => $onFulfilled,
-    'rejected'    => $onRejected,
-    'concurrency' => $concurrency,
-  ]))->promise();
+    return (new EachPromise(
+        $iterable, [
+        'fulfilled'   => $onFulfilled,
+        'rejected'    => $onRejected,
+        'concurrency' => $concurrency,
+        ]
+    ))->promise();
 }
 
 /**
@@ -405,18 +430,18 @@
  * is rejected. If any promise is rejected, then the aggregate promise is
  * rejected with the encountered rejection.
  *
- * @param mixed $iterable
+ * @param mixed        $iterable
  * @param int|callable $concurrency
- * @param callable $onFulfilled
+ * @param callable     $onFulfilled
  *
  * @return PromiseInterface
  */
 function each_limit_all(
     $iterable,
     $concurrency,
-    callable $onFulfilled = NULL
+    callable $onFulfilled = null
 ) {
-  return each_limit(
+    return each_limit(
         $iterable,
         $concurrency,
         $onFulfilled,
@@ -433,8 +458,9 @@
  *
  * @return bool
  */
-function is_fulfilled(PromiseInterface $promise) {
-  return $promise->getState() === PromiseInterface::FULFILLED;
+function is_fulfilled(PromiseInterface $promise) 
+{
+    return $promise->getState() === PromiseInterface::FULFILLED;
 }
 
 /**
@@ -444,8 +470,9 @@
  *
  * @return bool
  */
-function is_rejected(PromiseInterface $promise) {
-  return $promise->getState() === PromiseInterface::REJECTED;
+function is_rejected(PromiseInterface $promise) 
+{
+    return $promise->getState() === PromiseInterface::REJECTED;
 }
 
 /**
@@ -455,8 +482,9 @@
  *
  * @return bool
  */
-function is_settled(PromiseInterface $promise) {
-  return $promise->getState() !== PromiseInterface::PENDING;
+function is_settled(PromiseInterface $promise) 
+{
+    return $promise->getState() !== PromiseInterface::PENDING;
 }
 
 /**
@@ -466,6 +494,7 @@
  *
  * @return PromiseInterface
  */
-function coroutine(callable $generatorFn) {
-  return new Coroutine($generatorFn);
+function coroutine(callable $generatorFn) 
+{
+    return new Coroutine($generatorFn);
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/functions_include.php
+++ PHP_CodeSniffer
@@ -6,5 +6,5 @@
  */
 
 if (!function_exists('GuzzleHttp\Promise\promise_for')) {
-  require __DIR__ . '/functions.php';
+    include __DIR__ . '/functions.php';
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/CancellationException.php
+++ PHP_CodeSniffer
@@ -5,5 +5,6 @@
 /**
  * Exception that is set as the reason for a promise that has been cancelled.
  */
-class CancellationException extends RejectionException {
+class CancellationException extends RejectionException
+{
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/TaskQueue.php
+++ PHP_CodeSniffer
@@ -11,52 +11,61 @@
  *
  *     GuzzleHttp\Promise\queue()->run();
  */
-class TaskQueue implements TaskQueueInterface {
-  private $enableShutdown = TRUE;
-  private $queue = [];
+class TaskQueue implements TaskQueueInterface
+{
+    private $enableShutdown = true;
+    private $queue = [];
 
-  /**
+    /**
    *
    */
-  public function __construct($withShutdown = TRUE) {
-    if ($withShutdown) {
-      register_shutdown_function(function () {
-        if ($this->enableShutdown) {
-          // Only run the tasks if an E_ERROR didn't occur.
-          $err = error_get_last();
-          if (!$err || ($err['type'] ^ E_ERROR)) {
-            $this->run();
-          }
+    public function __construct($withShutdown = true) 
+    {
+        if ($withShutdown) {
+            register_shutdown_function(
+                function () {
+                    if ($this->enableShutdown) {
+                        // Only run the tasks if an E_ERROR didn't occur.
+                        $err = error_get_last();
+                        if (!$err || ($err['type'] ^ E_ERROR)) {
+                            $this->run();
+                        }
+                    }
+                }
+            );
         }
-      });
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function isEmpty() {
-    return !$this->queue;
-  }
+    public function isEmpty() 
+    {
+        return !$this->queue;
+    }
 
-  /**
+    /**
    *
    */
-  public function add(callable $task) {
-    $this->queue[] = $task;
-  }
+    public function add(callable $task) 
+    {
+        $this->queue[] = $task;
+    }
 
-  /**
+    /**
    *
    */
-  public function run() {
-    /** @var callable $task */
-    while ($task = array_shift($this->queue)) {
-      $task();
+    public function run() 
+    {
+        /**
+ * @var callable $task 
+*/
+        while ($task = array_shift($this->queue)) {
+            $task();
+        }
     }
-  }
 
-  /**
+    /**
    * The task queue will be run and exhausted by default when the process
    * exits IFF the exit is not the result of a PHP E_ERROR error.
    *
@@ -67,8 +76,9 @@
    *
    * Note: This shutdown will occur before any destructors are triggered.
    */
-  public function disableShutdown() {
-    $this->enableShutdown = FALSE;
-  }
+    public function disableShutdown() 
+    {
+        $this->enableShutdown = false;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/PromisorInterface.php
+++ PHP_CodeSniffer
@@ -5,13 +5,14 @@
 /**
  * Interface used with classes that return a promise.
  */
-interface PromisorInterface {
+interface PromisorInterface
+{
 
-  /**
+    /**
    * Returns a promise.
    *
    * @return PromiseInterface
    */
-  public function promise();
+    public function promise();
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/RejectionException.php
+++ PHP_CodeSniffer
@@ -7,45 +7,49 @@
  *
  * The reason value is available via the getReason() method.
  */
-class RejectionException extends \RuntimeException {
-  /**
-   * @var mixedRejectionreason*/
-  private $reason;
+class RejectionException extends \RuntimeException
+{
+    /**
+   * @var mixedRejectionreason
+*/
+    private $reason;
 
-  /**
-   * @param mixed $reason
+    /**
+   * @param mixed  $reason
    *   Rejection reason.
    * @param string $description
    *   Optional description.
    */
-  public function __construct($reason, $description = NULL) {
-    $this->reason = $reason;
-
-    $message = 'The promise was rejected';
-
-    if ($description) {
-      $message .= ' with reason: ' . $description;
-    }
-    elseif (is_string($reason)
-        || (is_object($reason) && method_exists($reason, '__toString'))
-    ) {
-      $message .= ' with reason: ' . $this->reason;
-    }
-    elseif ($reason instanceof \JsonSerializable) {
-      $message .= ' with reason: '
+    public function __construct($reason, $description = null) 
+    {
+        $this->reason = $reason;
+
+        $message = 'The promise was rejected';
+
+        if ($description) {
+            $message .= ' with reason: ' . $description;
+        }
+        elseif (is_string($reason)
+            || (is_object($reason) && method_exists($reason, '__toString'))
+        ) {
+            $message .= ' with reason: ' . $this->reason;
+        }
+        elseif ($reason instanceof \JsonSerializable) {
+            $message .= ' with reason: '
                 . json_encode($this->reason, JSON_PRETTY_PRINT);
-    }
+        }
 
-    parent::__construct($message);
-  }
+        parent::__construct($message);
+    }
 
-  /**
+    /**
    * Returns the rejection reason.
    *
    * @return mixed
    */
-  public function getReason() {
-    return $this->reason;
-  }
+    public function getReason() 
+    {
+        return $this->reason;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/Coroutine.php
+++ PHP_CodeSniffer
@@ -42,134 +42,147 @@
  *
  * @link https://github.com/petkaantonov/bluebird/blob/master/API.md#generators inspiration
  */
-final class Coroutine implements PromiseInterface {
-  /**
+final class Coroutine implements PromiseInterface
+{
+    /**
    * @var PromiseInterface|null
    */
-  private $currentPromise;
+    private $currentPromise;
 
-  /**
+    /**
    * @var \Generator
    */
-  private $generator;
+    private $generator;
 
-  /**
+    /**
    * @var Promise
    */
-  private $result;
+    private $result;
 
-  /**
+    /**
    *
    */
-  public function __construct(callable $generatorFn) {
-    $this->generator = $generatorFn();
-    $this->result = new Promise(function () {
-      while (isset($this->currentPromise)) {
-        $this->currentPromise->wait();
-      }
-    });
-    $this->nextCoroutine($this->generator->current());
-  }
+    public function __construct(callable $generatorFn) 
+    {
+        $this->generator = $generatorFn();
+        $this->result = new Promise(
+            function () {
+                while (isset($this->currentPromise)) {
+                    $this->currentPromise->wait();
+                }
+            }
+        );
+        $this->nextCoroutine($this->generator->current());
+    }
 
-  /**
+    /**
    *
    */
-  public function then(
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public function then(
+        callable $onFulfilled = null,
+        callable $onRejected = null
     ) {
-    return $this->result->then($onFulfilled, $onRejected);
-  }
+        return $this->result->then($onFulfilled, $onRejected);
+    }
 
-  /**
+    /**
    *
    */
-  public function otherwise(callable $onRejected) {
-    return $this->result->otherwise($onRejected);
-  }
+    public function otherwise(callable $onRejected) 
+    {
+        return $this->result->otherwise($onRejected);
+    }
 
-  /**
+    /**
    *
    */
-  public function wait($unwrap = TRUE) {
-    return $this->result->wait($unwrap);
-  }
+    public function wait($unwrap = true) 
+    {
+        return $this->result->wait($unwrap);
+    }
 
-  /**
+    /**
    *
    */
-  public function getState() {
-    return $this->result->getState();
-  }
+    public function getState() 
+    {
+        return $this->result->getState();
+    }
 
-  /**
+    /**
    *
    */
-  public function resolve($value) {
-    $this->result->resolve($value);
-  }
+    public function resolve($value) 
+    {
+        $this->result->resolve($value);
+    }
 
-  /**
+    /**
    *
    */
-  public function reject($reason) {
-    $this->result->reject($reason);
-  }
+    public function reject($reason) 
+    {
+        $this->result->reject($reason);
+    }
 
-  /**
+    /**
    *
    */
-  public function cancel() {
-    $this->currentPromise->cancel();
-    $this->result->cancel();
-  }
+    public function cancel() 
+    {
+        $this->currentPromise->cancel();
+        $this->result->cancel();
+    }
 
-  /**
+    /**
    *
    */
-  private function nextCoroutine($yielded) {
-    $this->currentPromise = promise_for($yielded)
-      ->then([$this, '_handleSuccess'], [$this, '_handleFailure']);
-  }
+    private function nextCoroutine($yielded) 
+    {
+        $this->currentPromise = promise_for($yielded)
+            ->then([$this, '_handleSuccess'], [$this, '_handleFailure']);
+    }
 
-  /**
+    /**
    * @internal
    */
-  public function _handleSuccess($value) {
-    unset($this->currentPromise);
-    try {
-      $next = $this->generator->send($value);
-      if ($this->generator->valid()) {
-        $this->nextCoroutine($next);
-      }
-      else {
-        $this->result->resolve($value);
-      }
-    }
-    catch (Exception $exception) {
-      $this->result->reject($exception);
+    public function _handleSuccess($value) 
+    {
+        unset($this->currentPromise);
+        try {
+            $next = $this->generator->send($value);
+            if ($this->generator->valid()) {
+                $this->nextCoroutine($next);
+            }
+            else {
+                $this->result->resolve($value);
+            }
+        }
+        catch (Exception $exception) {
+            $this->result->reject($exception);
+        }
+        catch (Throwable $throwable) {
+            $this->result->reject($throwable);
+        }
     }
-    catch (Throwable $throwable) {
-      $this->result->reject($throwable);
-    }
-  }
 
-  /**
+    /**
    * @internal
    */
-  public function _handleFailure($reason) {
-    unset($this->currentPromise);
-    try {
-      $nextYield = $this->generator->throw(exception_for($reason));
-      // The throw was caught, so keep iterating on the coroutine.
-      $this->nextCoroutine($nextYield);
-    }
-    catch (Exception $exception) {
-      $this->result->reject($exception);
-    }
-    catch (Throwable $throwable) {
-      $this->result->reject($throwable);
+    public function _handleFailure($reason) 
+    {
+        unset($this->currentPromise);
+        try {
+            $nextYield = $this->generator->throw(exception_for($reason));
+            // The throw was caught, so keep iterating on the coroutine.
+            $this->nextCoroutine($nextYield);
+        }
+        catch (Exception $exception) {
+            $this->result->reject($exception);
+        }
+        catch (Throwable $throwable) {
+            $this->result->reject($throwable);
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/RejectedPromise.php
+++ PHP_CodeSniffer
@@ -8,100 +8,111 @@
  * Thenning off of this promise will invoke the onRejected callback
  * immediately and ignore other callbacks.
  */
-class RejectedPromise implements PromiseInterface {
-  private $reason;
-
-  /**
+class RejectedPromise implements PromiseInterface
+{
+    private $reason;
+
+    /**
    *
    */
-  public function __construct($reason) {
-    if (method_exists($reason, 'then')) {
-      throw new \InvalidArgumentException(
-        'You cannot create a RejectedPromise with a promise.');
-    }
+    public function __construct($reason) 
+    {
+        if (method_exists($reason, 'then')) {
+            throw new \InvalidArgumentException(
+                'You cannot create a RejectedPromise with a promise.'
+            );
+        }
 
-    $this->reason = $reason;
-  }
+        $this->reason = $reason;
+    }
 
-  /**
+    /**
    *
    */
-  public function then(
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public function then(
+        callable $onFulfilled = null,
+        callable $onRejected = null
     ) {
-    // If there's no onRejected callback then just return self.
-    if (!$onRejected) {
-      return $this;
-    }
-
-    $queue = queue();
-    $reason = $this->reason;
-    $p = new Promise([$queue, 'run']);
-    $queue->add(static function () use ($p, $reason, $onRejected) {
-      if ($p->getState() === self::PENDING) {
-        try {
-          // Return a resolved promise if onRejected does not throw.
-          $p->resolve($onRejected($reason));
+        // If there's no onRejected callback then just return self.
+        if (!$onRejected) {
+            return $this;
         }
-        catch (\Throwable $e) {
-          // onRejected threw, so return a rejected promise.
-          $p->reject($e);
-        }
-        catch (\Exception $e) {
-              // onRejected threw, so return a rejected promise.
-              $p->reject($e);
+
+        $queue = queue();
+        $reason = $this->reason;
+        $p = new Promise([$queue, 'run']);
+        $queue->add(
+            static function () use ($p, $reason, $onRejected) {
+            if ($p->getState() === self::PENDING) {
+                try {
+                    // Return a resolved promise if onRejected does not throw.
+                    $p->resolve($onRejected($reason));
+                }
+                catch (\Throwable $e) {
+                    // onRejected threw, so return a rejected promise.
+                    $p->reject($e);
+                }
+                catch (\Exception $e) {
+                      // onRejected threw, so return a rejected promise.
+                      $p->reject($e);
+                }
+            }
         }
-      }
-    });
+        );
 
-    return $p;
-  }
+        return $p;
+    }
 
-  /**
+    /**
    *
    */
-  public function otherwise(callable $onRejected) {
-    return $this->then(NULL, $onRejected);
-  }
+    public function otherwise(callable $onRejected) 
+    {
+        return $this->then(null, $onRejected);
+    }
 
-  /**
+    /**
    *
    */
-  public function wait($unwrap = TRUE, $defaultDelivery = NULL) {
-    if ($unwrap) {
-      throw exception_for($this->reason);
+    public function wait($unwrap = true, $defaultDelivery = null) 
+    {
+        if ($unwrap) {
+            throw exception_for($this->reason);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function getState() {
-    return self::REJECTED;
-  }
+    public function getState() 
+    {
+        return self::REJECTED;
+    }
 
-  /**
+    /**
    *
    */
-  public function resolve($value) {
-    throw new \LogicException("Cannot resolve a rejected promise");
-  }
+    public function resolve($value) 
+    {
+        throw new \LogicException("Cannot resolve a rejected promise");
+    }
 
-  /**
+    /**
    *
    */
-  public function reject($reason) {
-    if ($reason !== $this->reason) {
-      throw new \LogicException("Cannot reject a rejected promise");
+    public function reject($reason) 
+    {
+        if ($reason !== $this->reason) {
+            throw new \LogicException("Cannot reject a rejected promise");
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function cancel() {
-    // Pass.
-  }
+    public function cancel() 
+    {
+        // Pass.
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/EachPromise.php
+++ PHP_CodeSniffer
@@ -6,34 +6,41 @@
  * Represents a promise that iterates over many promises and invokes
  * side-effect functions in the process.
  */
-class EachPromise implements PromisorInterface {
-  private $pending = [];
+class EachPromise implements PromisorInterface
+{
+    private $pending = [];
+
+    /**
+   * @var \Iterator
+*/
+    private $iterable;
+
+    /**
+   * @var callable|int
+*/
+    private $concurrency;
+
+    /**
+   * @var callable
+*/
+    private $onFulfilled;
+
+    /**
+   * @var callable
+*/
+    private $onRejected;
+
+    /**
+   * @var Promise
+*/
+    private $aggregate;
+
+    /**
+   * @var bool
+*/
+    private $mutex;
 
-  /**
-   * @var \Iterator*/
-  private $iterable;
-
-  /**
-   * @var callable|int*/
-  private $concurrency;
-
-  /**
-   * @var callable*/
-  private $onFulfilled;
-
-  /**
-   * @var callable*/
-  private $onRejected;
-
-  /**
-   * @var Promise*/
-  private $aggregate;
-
-  /**
-   * @var bool*/
-  private $mutex;
-
-  /**
+    /**
    * Configuration hash can include the following key value pairs:.
    *
    * - fulfilled: (callable) Invoked when a promise fulfills. The function
@@ -56,202 +63,212 @@
    * @param array $config
    *   Configuration options.
    */
-  public function __construct($iterable, array $config = []) {
-    $this->iterable = iter_for($iterable);
+    public function __construct($iterable, array $config = []) 
+    {
+        $this->iterable = iter_for($iterable);
 
-    if (isset($config['concurrency'])) {
-      $this->concurrency = $config['concurrency'];
-    }
+        if (isset($config['concurrency'])) {
+            $this->concurrency = $config['concurrency'];
+        }
 
-    if (isset($config['fulfilled'])) {
-      $this->onFulfilled = $config['fulfilled'];
-    }
+        if (isset($config['fulfilled'])) {
+            $this->onFulfilled = $config['fulfilled'];
+        }
 
-    if (isset($config['rejected'])) {
-      $this->onRejected = $config['rejected'];
+        if (isset($config['rejected'])) {
+            $this->onRejected = $config['rejected'];
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function promise() {
-    if ($this->aggregate) {
-      return $this->aggregate;
-    }
+    public function promise() 
+    {
+        if ($this->aggregate) {
+            return $this->aggregate;
+        }
 
-    try {
-      $this->createPromise();
-      $this->iterable->rewind();
-      $this->refillPending();
-    }
-    catch (\Throwable $e) {
-      $this->aggregate->reject($e);
-    }
-    catch (\Exception $e) {
-      $this->aggregate->reject($e);
-    }
+        try {
+            $this->createPromise();
+            $this->iterable->rewind();
+            $this->refillPending();
+        }
+        catch (\Throwable $e) {
+            $this->aggregate->reject($e);
+        }
+        catch (\Exception $e) {
+            $this->aggregate->reject($e);
+        }
 
-    return $this->aggregate;
-  }
+        return $this->aggregate;
+    }
 
-  /**
+    /**
    *
    */
-  private function createPromise() {
-    $this->mutex = FALSE;
-    $this->aggregate = new Promise(function () {
-      reset($this->pending);
-      if (empty($this->pending) && !$this->iterable->valid()) {
-        $this->aggregate->resolve(NULL);
-        return;
-      }
-
-      // Consume a potentially fluctuating list of promises while
-      // ensuring that indexes are maintained (precluding array_shift).
-      while ($promise = current($this->pending)) {
-        next($this->pending);
-        $promise->wait();
-        if ($this->aggregate->getState() !== PromiseInterface::PENDING) {
-          return;
-        }
-      }
-    });
-
-    // Clear the references when the promise is resolved.
-    $clearFn = function () {
-      $this->iterable = $this->concurrency = $this->pending = NULL;
-      $this->onFulfilled = $this->onRejected = NULL;
-    };
+    private function createPromise() 
+    {
+        $this->mutex = false;
+        $this->aggregate = new Promise(
+            function () {
+                reset($this->pending);
+                if (empty($this->pending) && !$this->iterable->valid()) {
+                    $this->aggregate->resolve(null);
+                    return;
+                }
+
+                // Consume a potentially fluctuating list of promises while
+                // ensuring that indexes are maintained (precluding array_shift).
+                while ($promise = current($this->pending)) {
+                    next($this->pending);
+                    $promise->wait();
+                    if ($this->aggregate->getState() !== PromiseInterface::PENDING) {
+                        return;
+                    }
+                }
+            }
+        );
+
+        // Clear the references when the promise is resolved.
+        $clearFn = function () {
+            $this->iterable = $this->concurrency = $this->pending = null;
+            $this->onFulfilled = $this->onRejected = null;
+        };
 
-    $this->aggregate->then($clearFn, $clearFn);
-  }
+        $this->aggregate->then($clearFn, $clearFn);
+    }
 
-  /**
+    /**
    *
    */
-  private function refillPending() {
-    if (!$this->concurrency) {
-      // Add all pending promises.
-      while ($this->addPending() && $this->advanceIterator()) {
-      }
-      return;
-    }
+    private function refillPending() 
+    {
+        if (!$this->concurrency) {
+            // Add all pending promises.
+            while ($this->addPending() && $this->advanceIterator()) {
+            }
+            return;
+        }
 
-    // Add only up to N pending promises.
-    $concurrency = is_callable($this->concurrency)
+        // Add only up to N pending promises.
+        $concurrency = is_callable($this->concurrency)
             ? call_user_func($this->concurrency, count($this->pending))
             : $this->concurrency;
-    $concurrency = max($concurrency - count($this->pending), 0);
-    // Concurrency may be set to 0 to disallow new promises.
-    if (!$concurrency) {
-      return;
-    }
-    // Add the first pending promise.
-    $this->addPending();
-    // Note this is special handling for concurrency=1 so that we do
-    // not advance the iterator after adding the first promise. This
-    // helps work around issues with generators that might not have the
-    // next value to yield until promise callbacks are called.
-    while (--$concurrency
+        $concurrency = max($concurrency - count($this->pending), 0);
+        // Concurrency may be set to 0 to disallow new promises.
+        if (!$concurrency) {
+            return;
+        }
+        // Add the first pending promise.
+        $this->addPending();
+        // Note this is special handling for concurrency=1 so that we do
+        // not advance the iterator after adding the first promise. This
+        // helps work around issues with generators that might not have the
+        // next value to yield until promise callbacks are called.
+        while (--$concurrency
         && $this->advanceIterator()
         && $this->addPending()) {
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function addPending() {
-    if (!$this->iterable || !$this->iterable->valid()) {
-      return FALSE;
-    }
+    private function addPending() 
+    {
+        if (!$this->iterable || !$this->iterable->valid()) {
+            return false;
+        }
 
-    $promise = promise_for($this->iterable->current());
-    $idx = $this->iterable->key();
+        $promise = promise_for($this->iterable->current());
+        $idx = $this->iterable->key();
 
-    $this->pending[$idx] = $promise->then(
-        function ($value) use ($idx) {
-          if ($this->onFulfilled) {
-            call_user_func(
-                $this->onFulfilled, $value, $idx, $this->aggregate
-            );
-          }
-            $this->step($idx);
-        },
-        function ($reason) use ($idx) {
-          if ($this->onRejected) {
-            call_user_func(
-                $this->onRejected, $reason, $idx, $this->aggregate
-            );
-          }
-            $this->step($idx);
-        }
-    );
+        $this->pending[$idx] = $promise->then(
+            function ($value) use ($idx) {
+                if ($this->onFulfilled) {
+                    call_user_func(
+                        $this->onFulfilled, $value, $idx, $this->aggregate
+                    );
+                }
+                $this->step($idx);
+            },
+            function ($reason) use ($idx) {
+                if ($this->onRejected) {
+                    call_user_func(
+                        $this->onRejected, $reason, $idx, $this->aggregate
+                    );
+                }
+                $this->step($idx);
+            }
+        );
 
-    return TRUE;
-  }
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  private function advanceIterator() {
-    // Place a lock on the iterator so that we ensure to not recurse,
-    // preventing fatal generator errors.
-    if ($this->mutex) {
-      return FALSE;
-    }
+    private function advanceIterator() 
+    {
+        // Place a lock on the iterator so that we ensure to not recurse,
+        // preventing fatal generator errors.
+        if ($this->mutex) {
+            return false;
+        }
 
-    $this->mutex = TRUE;
+        $this->mutex = true;
 
-    try {
-      $this->iterable->next();
-      $this->mutex = FALSE;
-      return TRUE;
-    }
-    catch (\Throwable $e) {
-      $this->aggregate->reject($e);
-      $this->mutex = FALSE;
-      return FALSE;
-    }
-    catch (\Exception $e) {
-      $this->aggregate->reject($e);
-      $this->mutex = FALSE;
-      return FALSE;
+        try {
+            $this->iterable->next();
+            $this->mutex = false;
+            return true;
+        }
+        catch (\Throwable $e) {
+            $this->aggregate->reject($e);
+            $this->mutex = false;
+            return false;
+        }
+        catch (\Exception $e) {
+            $this->aggregate->reject($e);
+            $this->mutex = false;
+            return false;
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function step($idx) {
-    // If the promise was already resolved, then ignore this step.
-    if ($this->aggregate->getState() !== PromiseInterface::PENDING) {
-      return;
-    }
+    private function step($idx) 
+    {
+        // If the promise was already resolved, then ignore this step.
+        if ($this->aggregate->getState() !== PromiseInterface::PENDING) {
+            return;
+        }
 
-    unset($this->pending[$idx]);
+        unset($this->pending[$idx]);
 
-    // Only refill pending promises if we are not locked, preventing the
-    // EachPromise to recursively invoke the provided iterator, which
-    // cause a fatal error: "Cannot resume an already running generator".
-    if ($this->advanceIterator() && !$this->checkIfFinished()) {
-      // Add more pending promises if possible.
-      $this->refillPending();
+        // Only refill pending promises if we are not locked, preventing the
+        // EachPromise to recursively invoke the provided iterator, which
+        // cause a fatal error: "Cannot resume an already running generator".
+        if ($this->advanceIterator() && !$this->checkIfFinished()) {
+            // Add more pending promises if possible.
+            $this->refillPending();
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function checkIfFinished() {
-    if (!$this->pending && !$this->iterable->valid()) {
-      // Resolve the promise if there's nothing left to do.
-      $this->aggregate->resolve(NULL);
-      return TRUE;
-    }
+    private function checkIfFinished() 
+    {
+        if (!$this->pending && !$this->iterable->valid()) {
+            // Resolve the promise if there's nothing left to do.
+            $this->aggregate->resolve(null);
+            return true;
+        }
 
-    return FALSE;
-  }
+        return false;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/AggregateException.php
+++ PHP_CodeSniffer
@@ -5,16 +5,18 @@
 /**
  * Exception thrown when too many errors occur in the some() or any() methods.
  */
-class AggregateException extends RejectionException {
+class AggregateException extends RejectionException
+{
 
-  /**
+    /**
    *
    */
-  public function __construct($msg, array $reasons) {
-    parent::__construct(
-        $reasons,
-        sprintf('%s; %d rejected promises', $msg, count($reasons))
-    );
-  }
+    public function __construct($msg, array $reasons) 
+    {
+        parent::__construct(
+            $reasons,
+            sprintf('%s; %d rejected promises', $msg, count($reasons))
+        );
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/FulfilledPromise.php
+++ PHP_CodeSniffer
@@ -8,95 +8,106 @@
  * Thenning off of this promise will invoke the onFulfilled callback
  * immediately and ignore other callbacks.
  */
-class FulfilledPromise implements PromiseInterface {
-  private $value;
-
-  /**
+class FulfilledPromise implements PromiseInterface
+{
+    private $value;
+
+    /**
    *
    */
-  public function __construct($value) {
-    if (method_exists($value, 'then')) {
-      throw new \InvalidArgumentException(
-        'You cannot create a FulfilledPromise with a promise.');
-    }
+    public function __construct($value) 
+    {
+        if (method_exists($value, 'then')) {
+            throw new \InvalidArgumentException(
+                'You cannot create a FulfilledPromise with a promise.'
+            );
+        }
 
-    $this->value = $value;
-  }
+        $this->value = $value;
+    }
 
-  /**
+    /**
    *
    */
-  public function then(
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public function then(
+        callable $onFulfilled = null,
+        callable $onRejected = null
     ) {
-    // Return itself if there is no onFulfilled function.
-    if (!$onFulfilled) {
-      return $this;
-    }
-
-    $queue = queue();
-    $p = new Promise([$queue, 'run']);
-    $value = $this->value;
-    $queue->add(static function () use ($p, $value, $onFulfilled) {
-      if ($p->getState() === self::PENDING) {
-        try {
-          $p->resolve($onFulfilled($value));
+        // Return itself if there is no onFulfilled function.
+        if (!$onFulfilled) {
+            return $this;
         }
-        catch (\Throwable $e) {
-          $p->reject($e);
-        }
-        catch (\Exception $e) {
-              $p->reject($e);
+
+        $queue = queue();
+        $p = new Promise([$queue, 'run']);
+        $value = $this->value;
+        $queue->add(
+            static function () use ($p, $value, $onFulfilled) {
+            if ($p->getState() === self::PENDING) {
+                try {
+                    $p->resolve($onFulfilled($value));
+                }
+                catch (\Throwable $e) {
+                    $p->reject($e);
+                }
+                catch (\Exception $e) {
+                      $p->reject($e);
+                }
+            }
         }
-      }
-    });
+        );
 
-    return $p;
-  }
+        return $p;
+    }
 
-  /**
+    /**
    *
    */
-  public function otherwise(callable $onRejected) {
-    return $this->then(NULL, $onRejected);
-  }
+    public function otherwise(callable $onRejected) 
+    {
+        return $this->then(null, $onRejected);
+    }
 
-  /**
+    /**
    *
    */
-  public function wait($unwrap = TRUE, $defaultDelivery = NULL) {
-    return $unwrap ? $this->value : NULL;
-  }
+    public function wait($unwrap = true, $defaultDelivery = null) 
+    {
+        return $unwrap ? $this->value : null;
+    }
 
-  /**
+    /**
    *
    */
-  public function getState() {
-    return self::FULFILLED;
-  }
+    public function getState() 
+    {
+        return self::FULFILLED;
+    }
 
-  /**
+    /**
    *
    */
-  public function resolve($value) {
-    if ($value !== $this->value) {
-      throw new \LogicException("Cannot resolve a fulfilled promise");
+    public function resolve($value) 
+    {
+        if ($value !== $this->value) {
+            throw new \LogicException("Cannot resolve a fulfilled promise");
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function reject($reason) {
-    throw new \LogicException("Cannot reject a fulfilled promise");
-  }
+    public function reject($reason) 
+    {
+        throw new \LogicException("Cannot reject a fulfilled promise");
+    }
 
-  /**
+    /**
    *
    */
-  public function cancel() {
-    // Pass.
-  }
+    public function cancel() 
+    {
+        // Pass.
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/promises/src/TaskQueueInterface.php
+++ PHP_CodeSniffer
@@ -5,26 +5,27 @@
 /**
  *
  */
-interface TaskQueueInterface {
+interface TaskQueueInterface
+{
 
-  /**
+    /**
    * Returns true if the queue is empty.
    *
    * @return bool
    */
-  public function isEmpty();
+    public function isEmpty();
 
-  /**
+    /**
    * Adds a task to the queue that will be executed the next time run is
    * called.
    *
    * @param callable $task
    */
-  public function add(callable $task);
+    public function add(callable $task);
 
-  /**
+    /**
    * Execute all of the pending task in the queue.
    */
-  public function run();
+    public function run();
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/functions.php
+++ PHP_CodeSniffer
@@ -21,29 +21,32 @@
  *
  * @return string
  */
-function str(MessageInterface $message) {
-  if ($message instanceof RequestInterface) {
-    $msg = trim($message->getMethod() . ' '
-            . $message->getRequestTarget())
+function str(MessageInterface $message) 
+{
+    if ($message instanceof RequestInterface) {
+        $msg = trim(
+            $message->getMethod() . ' '
+            . $message->getRequestTarget()
+        )
             . ' HTTP/' . $message->getProtocolVersion();
-    if (!$message->hasHeader('host')) {
-      $msg .= "\r\nHost: " . $message->getUri()->getHost();
+        if (!$message->hasHeader('host')) {
+              $msg .= "\r\nHost: " . $message->getUri()->getHost();
+        }
     }
-  }
-  elseif ($message instanceof ResponseInterface) {
-    $msg = 'HTTP/' . $message->getProtocolVersion() . ' '
+    elseif ($message instanceof ResponseInterface) {
+        $msg = 'HTTP/' . $message->getProtocolVersion() . ' '
             . $message->getStatusCode() . ' '
             . $message->getReasonPhrase();
-  }
-  else {
-    throw new \InvalidArgumentException('Unknown message type');
-  }
-
-  foreach ($message->getHeaders() as $name => $values) {
-    $msg .= "\r\n{$name}: " . implode(', ', $values);
-  }
+    }
+    else {
+        throw new \InvalidArgumentException('Unknown message type');
+    }
+
+    foreach ($message->getHeaders() as $name => $values) {
+        $msg .= "\r\n{$name}: " . implode(', ', $values);
+    }
 
-  return "{$msg}\r\n\r\n" . $message->getBody();
+    return "{$msg}\r\n\r\n" . $message->getBody();
 }
 
 /**
@@ -59,15 +62,16 @@
  *
  * @throws \InvalidArgumentException
  */
-function uri_for($uri) {
-  if ($uri instanceof UriInterface) {
-    return $uri;
-  }
-  elseif (is_string($uri)) {
-    return new Uri($uri);
-  }
+function uri_for($uri) 
+{
+    if ($uri instanceof UriInterface) {
+        return $uri;
+    }
+    elseif (is_string($uri)) {
+        return new Uri($uri);
+    }
 
-  throw new \InvalidArgumentException('URI must be a string or UriInterface');
+    throw new \InvalidArgumentException('URI must be a string or UriInterface');
 }
 
 /**
@@ -79,55 +83,58 @@
  *
  * @param resource|string|null|int|float|bool|StreamInterface|callable $resource
  *   Entity body data.
- * @param array $options
+ * @param array                                                        $options
  *   Additional options.
  *
  * @return Stream
  *
  * @throws \InvalidArgumentException if the $resource arg is not valid.
  */
-function stream_for($resource = '', array $options = []) {
-  if (is_scalar($resource)) {
-    $stream = fopen('php://temp', 'r+');
-    if ($resource !== '') {
-      fwrite($stream, $resource);
-      fseek($stream, 0);
+function stream_for($resource = '', array $options = []) 
+{
+    if (is_scalar($resource)) {
+        $stream = fopen('php://temp', 'r+');
+        if ($resource !== '') {
+            fwrite($stream, $resource);
+            fseek($stream, 0);
+        }
+        return new Stream($stream, $options);
     }
-    return new Stream($stream, $options);
-  }
 
-  switch (gettype($resource)) {
+    switch (gettype($resource)) {
     case 'resource':
-      return new Stream($resource, $options);
+        return new Stream($resource, $options);
 
     case 'object':
-      if ($resource instanceof StreamInterface) {
-        return $resource;
-      }
-      elseif ($resource instanceof \Iterator) {
-        return new PumpStream(function () use ($resource) {
-          if (!$resource->valid()) {
-            return FALSE;
-          }
-          $result = $resource->current();
-          $resource->next();
-          return $result;
-        }, $options);
-      }
-      elseif (method_exists($resource, '__toString')) {
-        return stream_for((string) $resource, $options);
-      }
-      break;
+        if ($resource instanceof StreamInterface) {
+            return $resource;
+        }
+        elseif ($resource instanceof \Iterator) {
+            return new PumpStream(
+                function () use ($resource) {
+                    if (!$resource->valid()) {
+                        return false;
+                    }
+                    $result = $resource->current();
+                    $resource->next();
+                    return $result;
+                }, $options
+            );
+        }
+        elseif (method_exists($resource, '__toString')) {
+            return stream_for((string) $resource, $options);
+        }
+        break;
 
     case 'NULL':
-      return new Stream(fopen('php://temp', 'r+'), $options);
-  }
+        return new Stream(fopen('php://temp', 'r+'), $options);
+    }
 
-  if (is_callable($resource)) {
-    return new PumpStream($resource, $options);
-  }
+    if (is_callable($resource)) {
+        return new PumpStream($resource, $options);
+    }
 
-  throw new \InvalidArgumentException('Invalid resource type: ' . gettype($resource));
+    throw new \InvalidArgumentException('Invalid resource type: ' . gettype($resource));
 }
 
 /**
@@ -141,29 +148,30 @@
  *
  * @return array Returns the parsed header values.
  */
-function parse_header($header) {
-  static $trimmed = "\"'  \n\t\r";
-  $params = $matches = [];
-
-  foreach (normalize_header($header) as $val) {
-    $part = [];
-    foreach (preg_split('/;(?=([^"]*"[^"]*")*[^"]*$)/', $val) as $kvp) {
-      if (preg_match_all('/<[^>]+>|[^=]+/', $kvp, $matches)) {
-        $m = $matches[0];
-        if (isset($m[1])) {
-          $part[trim($m[0], $trimmed)] = trim($m[1], $trimmed);
+function parse_header($header) 
+{
+    static $trimmed = "\"'  \n\t\r";
+    $params = $matches = [];
+
+    foreach (normalize_header($header) as $val) {
+        $part = [];
+        foreach (preg_split('/;(?=([^"]*"[^"]*")*[^"]*$)/', $val) as $kvp) {
+            if (preg_match_all('/<[^>]+>|[^=]+/', $kvp, $matches)) {
+                $m = $matches[0];
+                if (isset($m[1])) {
+                    $part[trim($m[0], $trimmed)] = trim($m[1], $trimmed);
+                }
+                else {
+                    $part[] = trim($m[0], $trimmed);
+                }
+            }
         }
-        else {
-          $part[] = trim($m[0], $trimmed);
+        if ($part) {
+            $params[] = $part;
         }
-      }
-    }
-    if ($part) {
-      $params[] = $part;
     }
-  }
 
-  return $params;
+    return $params;
 }
 
 /**
@@ -175,25 +183,26 @@
  *
  * @return array Returns the normalized header field values.
  */
-function normalize_header($header) {
-  if (!is_array($header)) {
-    return array_map('trim', explode(',', $header));
-  }
-
-  $result = [];
-  foreach ($header as $value) {
-    foreach ((array) $value as $v) {
-      if (strpos($v, ',') === FALSE) {
-        $result[] = $v;
-        continue;
-      }
-      foreach (preg_split('/,(?=([^"]*"[^"]*")*[^"]*$)/', $v) as $vv) {
-        $result[] = trim($vv);
-      }
+function normalize_header($header) 
+{
+    if (!is_array($header)) {
+        return array_map('trim', explode(',', $header));
+    }
+
+    $result = [];
+    foreach ($header as $value) {
+        foreach ((array) $value as $v) {
+            if (strpos($v, ',') === false) {
+                $result[] = $v;
+                continue;
+            }
+            foreach (preg_split('/,(?=([^"]*"[^"]*")*[^"]*$)/', $v) as $vv) {
+                $result[] = trim($vv);
+            }
+        }
     }
-  }
 
-  return $result;
+    return $result;
 }
 
 /**
@@ -210,64 +219,65 @@
  *
  * @param \Psr\Http\Message\RequestInterface $request
  *   Request to clone and modify.
- * @param array $changes
+ * @param array                              $changes
  *   Changes to apply.
  *
  * @return \Psr\Http\Message\RequestInterface
  */
-function modify_request(RequestInterface $request, array $changes) {
-  if (!$changes) {
-    return $request;
-  }
-
-  $headers = $request->getHeaders();
-
-  if (!isset($changes['uri'])) {
-    $uri = $request->getUri();
-  }
-  else {
-    // Remove the host header if one is on the URI.
-    if ($host = $changes['uri']->getHost()) {
-      $changes['set_headers']['Host'] = $host;
-
-      if ($port = $changes['uri']->getPort()) {
-        $standardPorts = ['http' => 80, 'https' => 443];
-        $scheme = $changes['uri']->getScheme();
-        if (isset($standardPorts[$scheme]) && $port != $standardPorts[$scheme]) {
-          $changes['set_headers']['Host'] .= ':' . $port;
-        }
-      }
-    }
-    $uri = $changes['uri'];
-  }
-
-  if (!empty($changes['remove_headers'])) {
-    $headers = _caseless_remove($changes['remove_headers'], $headers);
-  }
-
-  if (!empty($changes['set_headers'])) {
-    $headers = _caseless_remove(array_keys($changes['set_headers']), $headers);
-    $headers = $changes['set_headers'] + $headers;
-  }
-
-  if (isset($changes['query'])) {
-    $uri = $uri->withQuery($changes['query']);
-  }
+function modify_request(RequestInterface $request, array $changes) 
+{
+    if (!$changes) {
+        return $request;
+    }
 
-  if ($request instanceof ServerRequestInterface) {
-    return new ServerRequest(
-        isset($changes['method']) ? $changes['method'] : $request->getMethod(),
-        $uri,
-        $headers,
-        isset($changes['body']) ? $changes['body'] : $request->getBody(),
-        isset($changes['version'])
+    $headers = $request->getHeaders();
+
+    if (!isset($changes['uri'])) {
+        $uri = $request->getUri();
+    }
+    else {
+        // Remove the host header if one is on the URI.
+        if ($host = $changes['uri']->getHost()) {
+            $changes['set_headers']['Host'] = $host;
+
+            if ($port = $changes['uri']->getPort()) {
+                $standardPorts = ['http' => 80, 'https' => 443];
+                $scheme = $changes['uri']->getScheme();
+                if (isset($standardPorts[$scheme]) && $port != $standardPorts[$scheme]) {
+                    $changes['set_headers']['Host'] .= ':' . $port;
+                }
+            }
+        }
+        $uri = $changes['uri'];
+    }
+
+    if (!empty($changes['remove_headers'])) {
+        $headers = _caseless_remove($changes['remove_headers'], $headers);
+    }
+
+    if (!empty($changes['set_headers'])) {
+        $headers = _caseless_remove(array_keys($changes['set_headers']), $headers);
+        $headers = $changes['set_headers'] + $headers;
+    }
+
+    if (isset($changes['query'])) {
+        $uri = $uri->withQuery($changes['query']);
+    }
+
+    if ($request instanceof ServerRequestInterface) {
+        return new ServerRequest(
+            isset($changes['method']) ? $changes['method'] : $request->getMethod(),
+            $uri,
+            $headers,
+            isset($changes['body']) ? $changes['body'] : $request->getBody(),
+            isset($changes['version'])
             ? $changes['version']
             : $request->getProtocolVersion(),
-        $request->getServerParams()
-    );
-  }
+            $request->getServerParams()
+        );
+    }
 
-  return new Request(
+    return new Request(
         isset($changes['method']) ? $changes['method'] : $request->getMethod(),
         $uri,
         $headers,
@@ -289,12 +299,13 @@
  *
  * @throws \RuntimeException
  */
-function rewind_body(MessageInterface $message) {
-  $body = $message->getBody();
+function rewind_body(MessageInterface $message) 
+{
+    $body = $message->getBody();
 
-  if ($body->tell()) {
-    $body->rewind();
-  }
+    if ($body->tell()) {
+        $body->rewind();
+    }
 }
 
 /**
@@ -312,26 +323,33 @@
  *
  * @throws \RuntimeException if the file cannot be opened
  */
-function try_fopen($filename, $mode) {
-  $ex = NULL;
-  set_error_handler(function () use ($filename, $mode, &$ex) {
-    $ex = new \RuntimeException(sprintf(
-        'Unable to open %s using mode %s: %s',
-        $filename,
-        $mode,
-        func_get_args()[1]
-    ));
-  });
-
-  $handle = fopen($filename, $mode);
-  restore_error_handler();
-
-  if ($ex) {
-    /** @var $ex \RuntimeException */
-    throw $ex;
-  }
+function try_fopen($filename, $mode) 
+{
+    $ex = null;
+    set_error_handler(
+        function () use ($filename, $mode, &$ex) {
+            $ex = new \RuntimeException(
+                sprintf(
+                    'Unable to open %s using mode %s: %s',
+                    $filename,
+                    $mode,
+                    func_get_args()[1]
+                )
+            );
+        }
+    );
 
-  return $handle;
+    $handle = fopen($filename, $mode);
+    restore_error_handler();
+
+    if ($ex) {
+        /**
+ * @var $ex \RuntimeException 
+*/
+        throw $ex;
+    }
+
+    return $handle;
 }
 
 /**
@@ -340,7 +358,7 @@
  *
  * @param \Psr\Http\Message\StreamInterface $stream
  *   Stream to read.
- * @param int $maxLen
+ * @param int                               $maxLen
  *   Maximum number of bytes to read. Pass -1
  *   to read the entire stream.
  *
@@ -348,33 +366,34 @@
  *
  * @throws \RuntimeException on error.
  */
-function copy_to_string(StreamInterface $stream, $maxLen = -1) {
-  $buffer = '';
-
-  if ($maxLen === -1) {
-    while (!$stream->eof()) {
-      $buf = $stream->read(1048576);
-      // Using a loose equality here to match on '' and false.
-      if ($buf == NULL) {
-        break;
-      }
-      $buffer .= $buf;
+function copy_to_string(StreamInterface $stream, $maxLen = -1) 
+{
+    $buffer = '';
+
+    if ($maxLen === -1) {
+        while (!$stream->eof()) {
+            $buf = $stream->read(1048576);
+            // Using a loose equality here to match on '' and false.
+            if ($buf == null) {
+                break;
+            }
+            $buffer .= $buf;
+        }
+        return $buffer;
     }
-    return $buffer;
-  }
 
-  $len = 0;
-  while (!$stream->eof() && $len < $maxLen) {
-    $buf = $stream->read($maxLen - $len);
-    // Using a loose equality here to match on '' and false.
-    if ($buf == NULL) {
-      break;
-    }
-    $buffer .= $buf;
-    $len = strlen($buffer);
-  }
+    $len = 0;
+    while (!$stream->eof() && $len < $maxLen) {
+        $buf = $stream->read($maxLen - $len);
+        // Using a loose equality here to match on '' and false.
+        if ($buf == null) {
+            break;
+        }
+        $buffer .= $buf;
+        $len = strlen($buffer);
+    }
 
-  return $buffer;
+    return $buffer;
 }
 
 /**
@@ -385,7 +404,7 @@
  *   Stream to read from.
  * @param \Psr\Http\Message\StreamInterface $dest
  *   Stream to write to.
- * @param int $maxLen
+ * @param int                               $maxLen
  *   Maximum number of bytes to read. Pass -1
  *   to read the entire stream.
  *
@@ -396,27 +415,27 @@
     StreamInterface $dest,
     $maxLen = -1
 ) {
-  $bufferSize = 8192;
+    $bufferSize = 8192;
 
-  if ($maxLen === -1) {
-    while (!$source->eof()) {
-      if (!$dest->write($source->read($bufferSize))) {
-        break;
-      }
+    if ($maxLen === -1) {
+        while (!$source->eof()) {
+            if (!$dest->write($source->read($bufferSize))) {
+                break;
+            }
+        }
     }
-  }
-  else {
-    $remaining = $maxLen;
-    while ($remaining > 0 && !$source->eof()) {
-      $buf = $source->read(min($bufferSize, $remaining));
-      $len = strlen($buf);
-      if (!$len) {
-        break;
-      }
-      $remaining -= $len;
-      $dest->write($buf);
+    else {
+        $remaining = $maxLen;
+        while ($remaining > 0 && !$source->eof()) {
+            $buf = $source->read(min($bufferSize, $remaining));
+            $len = strlen($buf);
+            if (!$len) {
+                break;
+            }
+            $remaining -= $len;
+            $dest->write($buf);
+        }
     }
-  }
 }
 
 /**
@@ -424,9 +443,9 @@
  *
  * @param \Psr\Http\Message\StreamInterface $stream
  *   Stream to calculate the hash for.
- * @param string $algo
+ * @param string                            $algo
  *   Hash algorithm (e.g. md5, crc32, etc)
- * @param bool $rawOutput
+ * @param bool                              $rawOutput
  *   Whether or not to use raw output.
  *
  * @return string Returns the hash of the stream
@@ -436,23 +455,23 @@
 function hash(
     StreamInterface $stream,
     $algo,
-    $rawOutput = FALSE
+    $rawOutput = false
 ) {
-  $pos = $stream->tell();
+    $pos = $stream->tell();
 
-  if ($pos > 0) {
-    $stream->rewind();
-  }
+    if ($pos > 0) {
+        $stream->rewind();
+    }
 
-  $ctx = hash_init($algo);
-  while (!$stream->eof()) {
-    hash_update($ctx, $stream->read(1048576));
-  }
+    $ctx = hash_init($algo);
+    while (!$stream->eof()) {
+        hash_update($ctx, $stream->read(1048576));
+    }
 
-  $out = hash_final($ctx, (bool) $rawOutput);
-  $stream->seek($pos);
+    $out = hash_final($ctx, (bool) $rawOutput);
+    $stream->seek($pos);
 
-  return $out;
+    return $out;
 }
 
 /**
@@ -460,28 +479,29 @@
  *
  * @param \Psr\Http\Message\StreamInterface $stream
  *   Stream to read from.
- * @param int $maxLength
+ * @param int                               $maxLength
  *   Maximum buffer length.
  *
  * @return string|bool
  */
-function readline(StreamInterface $stream, $maxLength = NULL) {
-  $buffer = '';
-  $size = 0;
-
-  while (!$stream->eof()) {
-    // Using a loose equality here to match on '' and false.
-    if (NULL == ($byte = $stream->read(1))) {
-      return $buffer;
-    }
-    $buffer .= $byte;
-    // Break when a new line is found or the max length - 1 is reached.
-    if ($byte === "\n" || ++$size === $maxLength - 1) {
-      break;
+function readline(StreamInterface $stream, $maxLength = null) 
+{
+    $buffer = '';
+    $size = 0;
+
+    while (!$stream->eof()) {
+        // Using a loose equality here to match on '' and false.
+        if (null == ($byte = $stream->read(1))) {
+            return $buffer;
+        }
+        $buffer .= $byte;
+        // Break when a new line is found or the max length - 1 is reached.
+        if ($byte === "\n" || ++$size === $maxLength - 1) {
+            break;
+        }
     }
-  }
 
-  return $buffer;
+    return $buffer;
 }
 
 /**
@@ -492,16 +512,17 @@
  *
  * @return Request
  */
-function parse_request($message) {
-  $data = _parse_message($message);
-  $matches = [];
-  if (!preg_match('/^[\S]+\s+([a-zA-Z]+:\/\/|\/).*/', $data['start-line'], $matches)) {
-    throw new \InvalidArgumentException('Invalid request string');
-  }
-  $parts = explode(' ', $data['start-line'], 3);
-  $version = isset($parts[2]) ? explode('/', $parts[2])[1] : '1.1';
+function parse_request($message) 
+{
+    $data = _parse_message($message);
+    $matches = [];
+    if (!preg_match('/^[\S]+\s+([a-zA-Z]+:\/\/|\/).*/', $data['start-line'], $matches)) {
+        throw new \InvalidArgumentException('Invalid request string');
+    }
+    $parts = explode(' ', $data['start-line'], 3);
+    $version = isset($parts[2]) ? explode('/', $parts[2])[1] : '1.1';
 
-  $request = new Request(
+    $request = new Request(
         $parts[0],
         $matches[1] === '/' ? _parse_request_uri($parts[1], $data['headers']) : $parts[1],
         $data['headers'],
@@ -509,7 +530,7 @@
         $version
     );
 
-  return $matches[1] === '/' ? $request : $request->withRequestTarget($parts[1]);
+    return $matches[1] === '/' ? $request : $request->withRequestTarget($parts[1]);
 }
 
 /**
@@ -520,22 +541,23 @@
  *
  * @return Response
  */
-function parse_response($message) {
-  $data = _parse_message($message);
-  // According to https://tools.ietf.org/html/rfc7230#section-3.1.2 the space
-  // between status-code and reason-phrase is required. But browsers accept
-  // responses without space and reason as well.
-  if (!preg_match('/^HTTP\/.* [0-9]{3}( .*|$)/', $data['start-line'])) {
-    throw new \InvalidArgumentException('Invalid response string');
-  }
-  $parts = explode(' ', $data['start-line'], 3);
+function parse_response($message) 
+{
+    $data = _parse_message($message);
+    // According to https://tools.ietf.org/html/rfc7230#section-3.1.2 the space
+    // between status-code and reason-phrase is required. But browsers accept
+    // responses without space and reason as well.
+    if (!preg_match('/^HTTP\/.* [0-9]{3}( .*|$)/', $data['start-line'])) {
+        throw new \InvalidArgumentException('Invalid response string');
+    }
+    $parts = explode(' ', $data['start-line'], 3);
 
-  return new Response(
+    return new Response(
         $parts[1],
         $data['headers'],
         $data['body'],
         explode('/', $parts[0])[1],
-        isset($parts[2]) ? $parts[2] : NULL
+        isset($parts[2]) ? $parts[2] : null
     );
 }
 
@@ -547,53 +569,54 @@
  * PHP style arrays into an associative array (e.g., foo[a]=1&foo[b]=2 will
  * be parsed into ['foo[a]' => '1', 'foo[b]' => '2']).
  *
- * @param string $str
+ * @param string      $str
  *   Query string to parse.
  * @param bool|string $urlEncoding
  *   How the query string is encoded.
  *
  * @return array
  */
-function parse_query($str, $urlEncoding = TRUE) {
-  $result = [];
+function parse_query($str, $urlEncoding = true) 
+{
+    $result = [];
 
-  if ($str === '') {
-    return $result;
-  }
+    if ($str === '') {
+        return $result;
+    }
 
-  if ($urlEncoding === TRUE) {
-    $decoder = function ($value) {
-      return rawurldecode(str_replace('+', ' ', $value));
-    };
-  }
-  elseif ($urlEncoding == PHP_QUERY_RFC3986) {
-    $decoder = 'rawurldecode';
-  }
-  elseif ($urlEncoding == PHP_QUERY_RFC1738) {
-    $decoder = 'urldecode';
-  }
-  else {
-    $decoder = function ($str) {
-      return $str;
-    };
-  }
-
-  foreach (explode('&', $str) as $kvp) {
-    $parts = explode('=', $kvp, 2);
-    $key = $decoder($parts[0]);
-    $value = isset($parts[1]) ? $decoder($parts[1]) : NULL;
-    if (!isset($result[$key])) {
-      $result[$key] = $value;
+    if ($urlEncoding === true) {
+        $decoder = function ($value) {
+            return rawurldecode(str_replace('+', ' ', $value));
+        };
+    }
+    elseif ($urlEncoding == PHP_QUERY_RFC3986) {
+        $decoder = 'rawurldecode';
+    }
+    elseif ($urlEncoding == PHP_QUERY_RFC1738) {
+        $decoder = 'urldecode';
     }
     else {
-      if (!is_array($result[$key])) {
-        $result[$key] = [$result[$key]];
-      }
-      $result[$key][] = $value;
+        $decoder = function ($str) {
+            return $str;
+        };
+    }
+
+    foreach (explode('&', $str) as $kvp) {
+        $parts = explode('=', $kvp, 2);
+        $key = $decoder($parts[0]);
+        $value = isset($parts[1]) ? $decoder($parts[1]) : null;
+        if (!isset($result[$key])) {
+            $result[$key] = $value;
+        }
+        else {
+            if (!is_array($result[$key])) {
+                $result[$key] = [$result[$key]];
+            }
+            $result[$key][] = $value;
+        }
     }
-  }
 
-  return $result;
+    return $result;
 }
 
 /**
@@ -603,7 +626,7 @@
  * string. This function does not modify the provided keys when an array is
  * encountered (like http_build_query would).
  *
- * @param array $params
+ * @param array     $params
  *   Query string parameters.
  * @param int|false $encoding
  *   Set to false to not encode, PHP_QUERY_RFC3986
@@ -612,48 +635,49 @@
  *
  * @return string
  */
-function build_query(array $params, $encoding = PHP_QUERY_RFC3986) {
-  if (!$params) {
-    return '';
-  }
-
-  if ($encoding === FALSE) {
-    $encoder = function ($str) {
-      return $str;
-    };
-  }
-  elseif ($encoding === PHP_QUERY_RFC3986) {
-    $encoder = 'rawurlencode';
-  }
-  elseif ($encoding === PHP_QUERY_RFC1738) {
-    $encoder = 'urlencode';
-  }
-  else {
-    throw new \InvalidArgumentException('Invalid type');
-  }
-
-  $qs = '';
-  foreach ($params as $k => $v) {
-    $k = $encoder($k);
-    if (!is_array($v)) {
-      $qs .= $k;
-      if ($v !== NULL) {
-        $qs .= '=' . $encoder($v);
-      }
-      $qs .= '&';
+function build_query(array $params, $encoding = PHP_QUERY_RFC3986) 
+{
+    if (!$params) {
+        return '';
+    }
+
+    if ($encoding === false) {
+        $encoder = function ($str) {
+            return $str;
+        };
+    }
+    elseif ($encoding === PHP_QUERY_RFC3986) {
+        $encoder = 'rawurlencode';
+    }
+    elseif ($encoding === PHP_QUERY_RFC1738) {
+        $encoder = 'urlencode';
     }
     else {
-      foreach ($v as $vv) {
-        $qs .= $k;
-        if ($vv !== NULL) {
-          $qs .= '=' . $encoder($vv);
+        throw new \InvalidArgumentException('Invalid type');
+    }
+
+    $qs = '';
+    foreach ($params as $k => $v) {
+        $k = $encoder($k);
+        if (!is_array($v)) {
+            $qs .= $k;
+            if ($v !== null) {
+                $qs .= '=' . $encoder($v);
+            }
+            $qs .= '&';
+        }
+        else {
+            foreach ($v as $vv) {
+                $qs .= $k;
+                if ($vv !== null) {
+                    $qs .= '=' . $encoder($vv);
+                }
+                $qs .= '&';
+            }
         }
-        $qs .= '&';
-      }
     }
-  }
 
-  return $qs ? (string) substr($qs, 0, -1) : '';
+    return $qs ? (string) substr($qs, 0, -1) : '';
 }
 
 /**
@@ -663,8 +687,9 @@
  *
  * @return null|string
  */
-function mimetype_from_filename($filename) {
-  return mimetype_from_extension(pathinfo($filename, PATHINFO_EXTENSION));
+function mimetype_from_filename($filename) 
+{
+    return mimetype_from_extension(pathinfo($filename, PATHINFO_EXTENSION));
 }
 
 /**
@@ -677,8 +702,9 @@
  *
  * @link http://svn.apache.org/repos/asf/httpd/httpd/branches/1.3.x/conf/mime.types
  */
-function mimetype_from_extension($extension) {
-  static $mimetypes = [
+function mimetype_from_extension($extension) 
+{
+    static $mimetypes = [
     '7z' => 'application/x-7z-compressed',
     'aac' => 'audio/x-aac',
     'ai' => 'application/postscript',
@@ -777,13 +803,13 @@
     'yaml' => 'text/yaml',
     'yml' => 'text/yaml',
     'zip' => 'application/zip',
-  ];
+    ];
 
-  $extension = strtolower($extension);
+    $extension = strtolower($extension);
 
-  return isset($mimetypes[$extension])
+    return isset($mimetypes[$extension])
         ? $mimetypes[$extension]
-        : NULL;
+        : null;
 }
 
 /**
@@ -800,34 +826,35 @@
  *
  * @internal
  */
-function _parse_message($message) {
-  if (!$message) {
-    throw new \InvalidArgumentException('Invalid message');
-  }
-
-  // Iterate over each line in the message, accounting for line endings.
-  $lines = preg_split('/(\\r?\\n)/', $message, -1, PREG_SPLIT_DELIM_CAPTURE);
-  $result = ['start-line' => array_shift($lines), 'headers' => [], 'body' => ''];
-  array_shift($lines);
-
-  for ($i = 0, $totalLines = count($lines); $i < $totalLines; $i += 2) {
-    $line = $lines[$i];
-    // If two line breaks were encountered, then this is the end of body.
-    if (empty($line)) {
-      if ($i < $totalLines - 1) {
-        $result['body'] = implode('', array_slice($lines, $i + 2));
-      }
-      break;
-    }
-    if (strpos($line, ':')) {
-      $parts = explode(':', $line, 2);
-      $key = trim($parts[0]);
-      $value = isset($parts[1]) ? trim($parts[1]) : '';
-      $result['headers'][$key][] = $value;
+function _parse_message($message) 
+{
+    if (!$message) {
+        throw new \InvalidArgumentException('Invalid message');
+    }
+
+    // Iterate over each line in the message, accounting for line endings.
+    $lines = preg_split('/(\\r?\\n)/', $message, -1, PREG_SPLIT_DELIM_CAPTURE);
+    $result = ['start-line' => array_shift($lines), 'headers' => [], 'body' => ''];
+    array_shift($lines);
+
+    for ($i = 0, $totalLines = count($lines); $i < $totalLines; $i += 2) {
+        $line = $lines[$i];
+        // If two line breaks were encountered, then this is the end of body.
+        if (empty($line)) {
+            if ($i < $totalLines - 1) {
+                $result['body'] = implode('', array_slice($lines, $i + 2));
+            }
+            break;
+        }
+        if (strpos($line, ':')) {
+            $parts = explode(':', $line, 2);
+            $key = trim($parts[0]);
+            $value = isset($parts[1]) ? trim($parts[1]) : '';
+            $result['headers'][$key][] = $value;
+        }
     }
-  }
 
-  return $result;
+    return $result;
 }
 
 /**
@@ -835,43 +862,48 @@
  *
  * @param string $path
  *   Path from the start-line.
- * @param array $headers
+ * @param array  $headers
  *   Array of headers (each value an array).
  *
  * @return string
  *
  * @internal
  */
-function _parse_request_uri($path, array $headers) {
-  $hostKey = array_filter(array_keys($headers), function ($k) {
-    return strtolower($k) === 'host';
-  });
+function _parse_request_uri($path, array $headers) 
+{
+    $hostKey = array_filter(
+        array_keys($headers), function ($k) {
+            return strtolower($k) === 'host';
+        }
+    );
 
-  // If no host is found, then a full URI cannot be constructed.
-  if (!$hostKey) {
-    return $path;
-  }
+    // If no host is found, then a full URI cannot be constructed.
+    if (!$hostKey) {
+        return $path;
+    }
 
-  $host = $headers[reset($hostKey)][0];
-  $scheme = substr($host, -4) === ':443' ? 'https' : 'http';
+    $host = $headers[reset($hostKey)][0];
+    $scheme = substr($host, -4) === ':443' ? 'https' : 'http';
 
-  return $scheme . '://' . $host . '/' . ltrim($path, '/');
+    return $scheme . '://' . $host . '/' . ltrim($path, '/');
 }
 
 /**
- * @internal */
-function _caseless_remove($keys, array $data) {
-  $result = [];
+ * @internal 
+*/
+function _caseless_remove($keys, array $data) 
+{
+    $result = [];
 
-  foreach ($keys as &$key) {
-    $key = strtolower($key);
-  }
+    foreach ($keys as &$key) {
+        $key = strtolower($key);
+    }
 
-  foreach ($data as $k => $v) {
-    if (!in_array(strtolower($k), $keys)) {
-      $result[$k] = $v;
+    foreach ($data as $k => $v) {
+        if (!in_array(strtolower($k), $keys)) {
+            $result[$k] = $v;
+        }
     }
-  }
 
-  return $result;
+    return $result;
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/FnStream.php
+++ PHP_CodeSniffer
@@ -10,174 +10,198 @@
  * Allows for easy testing and extension of a provided stream without needing
  * to create a concrete class for a simple extension point.
  */
-class FnStream implements StreamInterface {
-  /**
-   * @var array*/
-  private $methods;
-
-  /**
-   * @var arrayMethodsthatmustbeimplementedinthegivenarray*/
-  private static $slots = ['__toString', 'close', 'detach', 'rewind',
+class FnStream implements StreamInterface
+{
+    /**
+   * @var array
+*/
+    private $methods;
+
+    /**
+   * @var arrayMethodsthatmustbeimplementedinthegivenarray
+*/
+    private static $slots = ['__toString', 'close', 'detach', 'rewind',
     'getSize', 'tell', 'eof', 'isSeekable', 'seek', 'isWritable', 'write',
     'isReadable', 'read', 'getContents', 'getMetadata',
-  ];
+    ];
 
-  /**
+    /**
    * @param array $methods
    *   Hash of method name to a callable.
    */
-  public function __construct(array $methods) {
-    $this->methods = $methods;
-
-    // Create the functions on the class.
-    foreach ($methods as $name => $fn) {
-      $this->{'_fn_' . $name} = $fn;
+    public function __construct(array $methods) 
+    {
+        $this->methods = $methods;
+
+        // Create the functions on the class.
+        foreach ($methods as $name => $fn) {
+            $this->{'_fn_' . $name} = $fn;
+        }
     }
-  }
 
-  /**
+    /**
    * Lazily determine which methods are not implemented.
    *
    * @throws \BadMethodCallException
    */
-  public function __get($name) {
-    throw new \BadMethodCallException(str_replace('_fn_', '', $name)
-        . '() is not implemented in the FnStream');
-  }
+    public function __get($name) 
+    {
+        throw new \BadMethodCallException(
+            str_replace('_fn_', '', $name)
+            . '() is not implemented in the FnStream'
+        );
+    }
 
-  /**
+    /**
    * The close method is called on the underlying stream only if possible.
    */
-  public function __destruct() {
-    if (isset($this->_fn_close)) {
-      call_user_func($this->_fn_close);
+    public function __destruct() 
+    {
+        if (isset($this->_fn_close)) {
+            call_user_func($this->_fn_close);
+        }
     }
-  }
 
-  /**
+    /**
    * Adds custom functionality to an underlying stream by intercepting
    * specific method calls.
    *
    * @param \Psr\Http\Message\StreamInterface $stream
    *   Stream to decorate.
-   * @param array $methods
+   * @param array                             $methods
    *   Hash of method name to a closure.
    *
    * @return FnStream
    */
-  public static function decorate(StreamInterface $stream, array $methods) {
-    // If any of the required methods were not provided, then simply
-    // proxy to the decorated stream.
-    foreach (array_diff(self::$slots, array_keys($methods)) as $diff) {
-      $methods[$diff] = [$stream, $diff];
-    }
+    public static function decorate(StreamInterface $stream, array $methods) 
+    {
+        // If any of the required methods were not provided, then simply
+        // proxy to the decorated stream.
+        foreach (array_diff(self::$slots, array_keys($methods)) as $diff) {
+            $methods[$diff] = [$stream, $diff];
+        }
 
-    return new self($methods);
-  }
+        return new self($methods);
+    }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    return call_user_func($this->_fn___toString);
-  }
+    public function __toString() 
+    {
+        return call_user_func($this->_fn___toString);
+    }
 
-  /**
+    /**
    *
    */
-  public function close() {
-    return call_user_func($this->_fn_close);
-  }
+    public function close() 
+    {
+        return call_user_func($this->_fn_close);
+    }
 
-  /**
+    /**
    *
    */
-  public function detach() {
-    return call_user_func($this->_fn_detach);
-  }
+    public function detach() 
+    {
+        return call_user_func($this->_fn_detach);
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    return call_user_func($this->_fn_getSize);
-  }
+    public function getSize() 
+    {
+        return call_user_func($this->_fn_getSize);
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    return call_user_func($this->_fn_tell);
-  }
+    public function tell() 
+    {
+        return call_user_func($this->_fn_tell);
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return call_user_func($this->_fn_eof);
-  }
+    public function eof() 
+    {
+        return call_user_func($this->_fn_eof);
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return call_user_func($this->_fn_isSeekable);
-  }
+    public function isSeekable() 
+    {
+        return call_user_func($this->_fn_isSeekable);
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    call_user_func($this->_fn_rewind);
-  }
+    public function rewind() 
+    {
+        call_user_func($this->_fn_rewind);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    call_user_func($this->_fn_seek, $offset, $whence);
-  }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        call_user_func($this->_fn_seek, $offset, $whence);
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return call_user_func($this->_fn_isWritable);
-  }
+    public function isWritable() 
+    {
+        return call_user_func($this->_fn_isWritable);
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    return call_user_func($this->_fn_write, $string);
-  }
+    public function write($string) 
+    {
+        return call_user_func($this->_fn_write, $string);
+    }
 
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return call_user_func($this->_fn_isReadable);
-  }
+    public function isReadable() 
+    {
+        return call_user_func($this->_fn_isReadable);
+    }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    return call_user_func($this->_fn_read, $length);
-  }
+    public function read($length) 
+    {
+        return call_user_func($this->_fn_read, $length);
+    }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    return call_user_func($this->_fn_getContents);
-  }
+    public function getContents() 
+    {
+        return call_user_func($this->_fn_getContents);
+    }
 
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    return call_user_func($this->_fn_getMetadata, $key);
-  }
+    public function getMetadata($key = null) 
+    {
+        return call_user_func($this->_fn_getMetadata, $key);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/UriNormalizer.php
+++ PHP_CodeSniffer
@@ -11,23 +11,24 @@
  *
  * @link https://tools.ietf.org/html/rfc3986#section-6
  */
-final class UriNormalizer {
-  /**
+final class UriNormalizer
+{
+    /**
      * Default normalizations which only include the ones that preserve semantics.
      *
      * Self::CAPITALIZE_PERCENT_ENCODING | self::DECODE_UNRESERVED_CHARACTERS | self::CONVERT_EMPTY_PATH |
      * self::REMOVE_DEFAULT_HOST | self::REMOVE_DEFAULT_PORT | self::REMOVE_DOT_SEGMENTS.
      */
-  const PRESERVING_NORMALIZATIONS = 63;
+    const PRESERVING_NORMALIZATIONS = 63;
 
-  /**
+    /**
      * All letters within a percent-encoding triplet (e.g., "%3A") are case-insensitive, and should be capitalized.
      *
      * Example: http://example.org/a%c2%b1b → http://example.org/a%C2%B1b.
      */
-  const CAPITALIZE_PERCENT_ENCODING = 1;
+    const CAPITALIZE_PERCENT_ENCODING = 1;
 
-  /**
+    /**
      * Decodes percent-encoded octets of unreserved characters.
      *
      * For consistency, percent-encoded octets in the ranges of ALPHA (%41–%5A and %61–%7A), DIGIT (%30–%39),
@@ -36,16 +37,16 @@
      *
      * Example: http://example.org/%7Eusern%61me/ → http://example.org/~username/
      */
-  const DECODE_UNRESERVED_CHARACTERS = 2;
+    const DECODE_UNRESERVED_CHARACTERS = 2;
 
-  /**
+    /**
      * Converts the empty path to "/" for http and https URIs.
      *
      * Example: http://example.org → http://example.org/
      */
-  const CONVERT_EMPTY_PATH = 4;
+    const CONVERT_EMPTY_PATH = 4;
 
-  /**
+    /**
      * Removes the default host of the given URI scheme from the URI.
      *
      * Only the "file" scheme defines the default host "localhost".
@@ -56,16 +57,16 @@
      *
      * Example: file://localhost/myfile → file:///myfile
      */
-  const REMOVE_DEFAULT_HOST = 8;
+    const REMOVE_DEFAULT_HOST = 8;
 
-  /**
+    /**
      * Removes the default port of the given URI scheme from the URI.
      *
      * Example: http://example.org:80/ → http://example.org/
      */
-  const REMOVE_DEFAULT_PORT = 16;
+    const REMOVE_DEFAULT_PORT = 16;
 
-  /**
+    /**
      * Removes unnecessary dot-segments.
      *
      * Dot-segments in relative-path references are not removed as it would
@@ -73,9 +74,9 @@
      *
      * Example: http://example.org/../a/b/../c/./d.html → http://example.org/a/c/d.html
      */
-  const REMOVE_DOT_SEGMENTS = 32;
+    const REMOVE_DOT_SEGMENTS = 32;
 
-  /**
+    /**
      * Paths which include two or more adjacent slashes are converted to one.
      *
      * Webservers usually ignore duplicate slashes and treat those URIs equivalent.
@@ -84,9 +85,9 @@
      *
      * Example: http://example.org//foo///bar.html → http://example.org/foo/bar.html
      */
-  const REMOVE_DUPLICATE_SLASHES = 64;
+    const REMOVE_DUPLICATE_SLASHES = 64;
 
-  /**
+    /**
      * Sort query parameters with their values in alphabetical order.
      *
      * However, the order of parameters in a URI may be significant (this is not defined by the standard).
@@ -97,9 +98,9 @@
      * Note: The sorting is neither locale nor Unicode aware (the URI query does not get decoded at all) as the
      * purpose is to be able to compare URIs in a reproducible way, not to have the params sorted perfectly.
      */
-  const SORT_QUERY_PARAMETERS = 128;
+    const SORT_QUERY_PARAMETERS = 128;
 
-  /**
+    /**
    * Returns a normalized URI.
    *
    * The scheme and host component are already normalized to lowercase per PSR-7 UriInterface.
@@ -112,54 +113,55 @@
    *
    * @param \Psr\Http\Message\UriInterface $uri
    *   The URI to normalize.
-   * @param int $flags
+   * @param int                            $flags
    *   A bitmask of normalizations to apply, see constants.
    *
    * @return \Psr\Http\Message\UriInterface The normalized URI
    *
    * @link https://tools.ietf.org/html/rfc3986#section-6.2
    */
-  public static function normalize(UriInterface $uri, $flags = self::PRESERVING_NORMALIZATIONS) {
-    if ($flags & self::CAPITALIZE_PERCENT_ENCODING) {
-      $uri = self::capitalizePercentEncoding($uri);
-    }
-
-    if ($flags & self::DECODE_UNRESERVED_CHARACTERS) {
-      $uri = self::decodeUnreservedCharacters($uri);
-    }
-
-    if ($flags & self::CONVERT_EMPTY_PATH && $uri->getPath() === '' &&
-        ($uri->getScheme() === 'http' || $uri->getScheme() === 'https')
-    ) {
-      $uri = $uri->withPath('/');
-    }
-
-    if ($flags & self::REMOVE_DEFAULT_HOST && $uri->getScheme() === 'file' && $uri->getHost() === 'localhost') {
-      $uri = $uri->withHost('');
-    }
-
-    if ($flags & self::REMOVE_DEFAULT_PORT && $uri->getPort() !== NULL && Uri::isDefaultPort($uri)) {
-      $uri = $uri->withPort(NULL);
-    }
-
-    if ($flags & self::REMOVE_DOT_SEGMENTS && !Uri::isRelativePathReference($uri)) {
-      $uri = $uri->withPath(UriResolver::removeDotSegments($uri->getPath()));
-    }
-
-    if ($flags & self::REMOVE_DUPLICATE_SLASHES) {
-      $uri = $uri->withPath(preg_replace('#//++#', '/', $uri->getPath()));
-    }
+    public static function normalize(UriInterface $uri, $flags = self::PRESERVING_NORMALIZATIONS) 
+    {
+        if ($flags & self::CAPITALIZE_PERCENT_ENCODING) {
+            $uri = self::capitalizePercentEncoding($uri);
+        }
+
+        if ($flags & self::DECODE_UNRESERVED_CHARACTERS) {
+            $uri = self::decodeUnreservedCharacters($uri);
+        }
+
+        if ($flags & self::CONVERT_EMPTY_PATH && $uri->getPath() === '' 
+            && ($uri->getScheme() === 'http' || $uri->getScheme() === 'https')
+        ) {
+            $uri = $uri->withPath('/');
+        }
+
+        if ($flags & self::REMOVE_DEFAULT_HOST && $uri->getScheme() === 'file' && $uri->getHost() === 'localhost') {
+            $uri = $uri->withHost('');
+        }
+
+        if ($flags & self::REMOVE_DEFAULT_PORT && $uri->getPort() !== null && Uri::isDefaultPort($uri)) {
+            $uri = $uri->withPort(null);
+        }
+
+        if ($flags & self::REMOVE_DOT_SEGMENTS && !Uri::isRelativePathReference($uri)) {
+            $uri = $uri->withPath(UriResolver::removeDotSegments($uri->getPath()));
+        }
+
+        if ($flags & self::REMOVE_DUPLICATE_SLASHES) {
+            $uri = $uri->withPath(preg_replace('#//++#', '/', $uri->getPath()));
+        }
+
+        if ($flags & self::SORT_QUERY_PARAMETERS && $uri->getQuery() !== '') {
+            $queryKeyValues = explode('&', $uri->getQuery());
+            sort($queryKeyValues);
+            $uri = $uri->withQuery(implode('&', $queryKeyValues));
+        }
 
-    if ($flags & self::SORT_QUERY_PARAMETERS && $uri->getQuery() !== '') {
-      $queryKeyValues = explode('&', $uri->getQuery());
-      sort($queryKeyValues);
-      $uri = $uri->withQuery(implode('&', $queryKeyValues));
+        return $uri;
     }
 
-    return $uri;
-  }
-
-  /**
+    /**
    * Whether two URIs can be considered equivalent.
    *
    * Both URIs are normalized automatically before comparison with the given $normalizations bitmask. The method also
@@ -171,58 +173,62 @@
    *   An URI to compare.
    * @param \Psr\Http\Message\UriInterface $uri2
    *   An URI to compare.
-   * @param int $normalizations
+   * @param int                            $normalizations
    *   A bitmask of normalizations to apply, see constants.
    *
    * @return bool
    *
    * @link https://tools.ietf.org/html/rfc3986#section-6.1
    */
-  public static function isEquivalent(UriInterface $uri1, UriInterface $uri2, $normalizations = self::PRESERVING_NORMALIZATIONS) {
-    return (string) self::normalize($uri1, $normalizations) === (string) self::normalize($uri2, $normalizations);
-  }
+    public static function isEquivalent(UriInterface $uri1, UriInterface $uri2, $normalizations = self::PRESERVING_NORMALIZATIONS) 
+    {
+        return (string) self::normalize($uri1, $normalizations) === (string) self::normalize($uri2, $normalizations);
+    }
 
-  /**
+    /**
    *
    */
-  private static function capitalizePercentEncoding(UriInterface $uri) {
-    $regex = '/(?:%[A-Fa-f0-9]{2})++/';
+    private static function capitalizePercentEncoding(UriInterface $uri) 
+    {
+        $regex = '/(?:%[A-Fa-f0-9]{2})++/';
+
+        $callback = function (array $match) {
+            return strtoupper($match[0]);
+        };
 
-    $callback = function (array $match) {
-      return strtoupper($match[0]);
-    };
-
-    return
+        return
             $uri->withPath(
-            preg_replace_callback($regex, $callback, $uri->getPath())
-        )->withQuery(
-            preg_replace_callback($regex, $callback, $uri->getQuery())
-        );
-  }
+                preg_replace_callback($regex, $callback, $uri->getPath())
+            )->withQuery(
+                preg_replace_callback($regex, $callback, $uri->getQuery())
+            );
+    }
 
-  /**
+    /**
    *
    */
-  private static function decodeUnreservedCharacters(UriInterface $uri) {
-    $regex = '/%(?:2D|2E|5F|7E|3[0-9]|[46][1-9A-F]|[57][0-9A])/i';
-
-    $callback = function (array $match) {
-      return rawurldecode($match[0]);
-    };
+    private static function decodeUnreservedCharacters(UriInterface $uri) 
+    {
+        $regex = '/%(?:2D|2E|5F|7E|3[0-9]|[46][1-9A-F]|[57][0-9A])/i';
+
+        $callback = function (array $match) {
+            return rawurldecode($match[0]);
+        };
 
-    return
+        return
             $uri->withPath(
-            preg_replace_callback($regex, $callback, $uri->getPath())
-        )->withQuery(
-            preg_replace_callback($regex, $callback, $uri->getQuery())
-        );
-  }
+                preg_replace_callback($regex, $callback, $uri->getPath())
+            )->withQuery(
+                preg_replace_callback($regex, $callback, $uri->getQuery())
+            );
+    }
 
-  /**
+    /**
    *
    */
-  private function __construct() {
-    // Cannot be instantiated.
-  }
+    private function __construct() 
+    {
+        // Cannot be instantiated.
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/functions_include.php
+++ PHP_CodeSniffer
@@ -6,5 +6,5 @@
  */
 
 if (!function_exists('GuzzleHttp\Psr7\str')) {
-  require __DIR__ . '/functions.php';
+    include __DIR__ . '/functions.php';
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/MessageTrait.php
+++ PHP_CodeSniffer
@@ -7,190 +7,207 @@
 /**
  * Trait implementing functionality common to requests and responses.
  */
-trait MessageTrait {
-  /**
-   * @var arrayMapofallregisteredheadersasoriginalnamearrayofvalues*/
-  private $headers = [];
+trait MessageTrait
+{
+    /**
+   * @var arrayMapofallregisteredheadersasoriginalnamearrayofvalues
+*/
+    private $headers = [];
 
-  /**
-   * @var arrayMapoflowercaseheadernameoriginalnameatregistration*/
-  private $headerNames = [];
+    /**
+   * @var arrayMapoflowercaseheadernameoriginalnameatregistration
+*/
+    private $headerNames = [];
 
-  /**
-   * @var string*/
-  private $protocol = '1.1';
+    /**
+   * @var string
+*/
+    private $protocol = '1.1';
 
-  /**
-   * @var \Psr\Http\Message\StreamInterface*/
-  private $stream;
+    /**
+   * @var \Psr\Http\Message\StreamInterface
+*/
+    private $stream;
 
-  /**
+    /**
    *
    */
-  public function getProtocolVersion() {
-    return $this->protocol;
-  }
+    public function getProtocolVersion() 
+    {
+        return $this->protocol;
+    }
 
-  /**
+    /**
    *
    */
-  public function withProtocolVersion($version) {
-    if ($this->protocol === $version) {
-      return $this;
-    }
+    public function withProtocolVersion($version) 
+    {
+        if ($this->protocol === $version) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->protocol = $version;
-    return $new;
-  }
+        $new = clone $this;
+        $new->protocol = $version;
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function getHeaders() {
-    return $this->headers;
-  }
+    public function getHeaders() 
+    {
+        return $this->headers;
+    }
 
-  /**
+    /**
    *
    */
-  public function hasHeader($header) {
-    return isset($this->headerNames[strtolower($header)]);
-  }
+    public function hasHeader($header) 
+    {
+        return isset($this->headerNames[strtolower($header)]);
+    }
 
-  /**
+    /**
    *
    */
-  public function getHeader($header) {
-    $header = strtolower($header);
+    public function getHeader($header) 
+    {
+        $header = strtolower($header);
 
-    if (!isset($this->headerNames[$header])) {
-      return [];
-    }
+        if (!isset($this->headerNames[$header])) {
+            return [];
+        }
 
-    $header = $this->headerNames[$header];
+        $header = $this->headerNames[$header];
 
-    return $this->headers[$header];
-  }
+        return $this->headers[$header];
+    }
 
-  /**
+    /**
    *
    */
-  public function getHeaderLine($header) {
-    return implode(', ', $this->getHeader($header));
-  }
+    public function getHeaderLine($header) 
+    {
+        return implode(', ', $this->getHeader($header));
+    }
 
-  /**
+    /**
    *
    */
-  public function withHeader($header, $value) {
-    if (!is_array($value)) {
-      $value = [$value];
-    }
+    public function withHeader($header, $value) 
+    {
+        if (!is_array($value)) {
+            $value = [$value];
+        }
 
-    $value = $this->trimHeaderValues($value);
-    $normalized = strtolower($header);
+        $value = $this->trimHeaderValues($value);
+        $normalized = strtolower($header);
 
-    $new = clone $this;
-    if (isset($new->headerNames[$normalized])) {
-      unset($new->headers[$new->headerNames[$normalized]]);
-    }
-    $new->headerNames[$normalized] = $header;
-    $new->headers[$header] = $value;
+        $new = clone $this;
+        if (isset($new->headerNames[$normalized])) {
+            unset($new->headers[$new->headerNames[$normalized]]);
+        }
+        $new->headerNames[$normalized] = $header;
+        $new->headers[$header] = $value;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withAddedHeader($header, $value) {
-    if (!is_array($value)) {
-      $value = [$value];
-    }
+    public function withAddedHeader($header, $value) 
+    {
+        if (!is_array($value)) {
+            $value = [$value];
+        }
 
-    $value = $this->trimHeaderValues($value);
-    $normalized = strtolower($header);
+        $value = $this->trimHeaderValues($value);
+        $normalized = strtolower($header);
 
-    $new = clone $this;
-    if (isset($new->headerNames[$normalized])) {
-      $header = $this->headerNames[$normalized];
-      $new->headers[$header] = array_merge($this->headers[$header], $value);
-    }
-    else {
-      $new->headerNames[$normalized] = $header;
-      $new->headers[$header] = $value;
-    }
+        $new = clone $this;
+        if (isset($new->headerNames[$normalized])) {
+            $header = $this->headerNames[$normalized];
+            $new->headers[$header] = array_merge($this->headers[$header], $value);
+        }
+        else {
+            $new->headerNames[$normalized] = $header;
+            $new->headers[$header] = $value;
+        }
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withoutHeader($header) {
-    $normalized = strtolower($header);
+    public function withoutHeader($header) 
+    {
+        $normalized = strtolower($header);
 
-    if (!isset($this->headerNames[$normalized])) {
-      return $this;
-    }
+        if (!isset($this->headerNames[$normalized])) {
+            return $this;
+        }
 
-    $header = $this->headerNames[$normalized];
+        $header = $this->headerNames[$normalized];
 
-    $new = clone $this;
-    unset($new->headers[$header], $new->headerNames[$normalized]);
+        $new = clone $this;
+        unset($new->headers[$header], $new->headerNames[$normalized]);
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function getBody() {
-    if (!$this->stream) {
-      $this->stream = stream_for('');
-    }
+    public function getBody() 
+    {
+        if (!$this->stream) {
+            $this->stream = stream_for('');
+        }
 
-    return $this->stream;
-  }
+        return $this->stream;
+    }
 
-  /**
+    /**
    *
    */
-  public function withBody(StreamInterface $body) {
-    if ($body === $this->stream) {
-      return $this;
-    }
+    public function withBody(StreamInterface $body) 
+    {
+        if ($body === $this->stream) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->stream = $body;
-    return $new;
-  }
+        $new = clone $this;
+        $new->stream = $body;
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  private function setHeaders(array $headers) {
-    $this->headerNames = $this->headers = [];
-    foreach ($headers as $header => $value) {
-      if (!is_array($value)) {
-        $value = [$value];
-      }
+    private function setHeaders(array $headers) 
+    {
+        $this->headerNames = $this->headers = [];
+        foreach ($headers as $header => $value) {
+            if (!is_array($value)) {
+                $value = [$value];
+            }
 
-      $value = $this->trimHeaderValues($value);
-      $normalized = strtolower($header);
-      if (isset($this->headerNames[$normalized])) {
-        $header = $this->headerNames[$normalized];
-        $this->headers[$header] = array_merge($this->headers[$header], $value);
-      }
-      else {
-        $this->headerNames[$normalized] = $header;
-        $this->headers[$header] = $value;
-      }
+            $value = $this->trimHeaderValues($value);
+            $normalized = strtolower($header);
+            if (isset($this->headerNames[$normalized])) {
+                $header = $this->headerNames[$normalized];
+                $this->headers[$header] = array_merge($this->headers[$header], $value);
+            }
+            else {
+                $this->headerNames[$normalized] = $header;
+                $this->headers[$header] = $value;
+            }
+        }
     }
-  }
 
-  /**
+    /**
    * Trims whitespace from the header values.
    *
    * Spaces and tabs ought to be excluded by parsers when extracting the field value from a header field.
@@ -205,10 +222,13 @@
    *
    * @see https://tools.ietf.org/html/rfc7230#section-3.2.4
    */
-  private function trimHeaderValues(array $values) {
-    return array_map(function ($value) {
-      return trim($value, " \t");
-    }, $values);
-  }
+    private function trimHeaderValues(array $values) 
+    {
+        return array_map(
+            function ($value) {
+                return trim($value, " \t");
+            }, $values
+        );
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/CachingStream.php
+++ PHP_CodeSniffer
@@ -8,18 +8,21 @@
  * Stream decorator that can cache previously read bytes from a sequentially
  * read stream.
  */
-class CachingStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class CachingStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
+
+    /**
+   * @var \Psr\Http\Message\StreamInterfaceStreambeingwrapped
+*/
+    private $remoteStream;
+
+    /**
+   * @var intNumberofbytestoskipreadingduetoawriteonthebuffer
+*/
+    private $skipReadBytes = 0;
 
-  /**
-   * @var \Psr\Http\Message\StreamInterfaceStreambeingwrapped*/
-  private $remoteStream;
-
-  /**
-   * @var intNumberofbytestoskipreadingduetoawriteonthebuffer*/
-  private $skipReadBytes = 0;
-
-  /**
+    /**
    * We will treat the buffer object as the body of the stream.
    *
    * @param \Psr\Http\Message\StreamInterface $stream
@@ -27,134 +30,142 @@
    * @param \Psr\Http\Message\StreamInterface $target
    *   Optionally specify where data is cached.
    */
-  public function __construct(
+    public function __construct(
         StreamInterface $stream,
-        StreamInterface $target = NULL
+        StreamInterface $target = null
     ) {
-    $this->remoteStream = $stream;
-    $this->stream = $target ?: new Stream(fopen('php://temp', 'r+'));
-  }
+        $this->remoteStream = $stream;
+        $this->stream = $target ?: new Stream(fopen('php://temp', 'r+'));
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    return max($this->stream->getSize(), $this->remoteStream->getSize());
-  }
+    public function getSize() 
+    {
+        return max($this->stream->getSize(), $this->remoteStream->getSize());
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    if ($whence == SEEK_SET) {
-      $byte = $offset;
-    }
-    elseif ($whence == SEEK_CUR) {
-      $byte = $offset + $this->tell();
-    }
-    elseif ($whence == SEEK_END) {
-      $size = $this->remoteStream->getSize();
-      if ($size === NULL) {
-        $size = $this->cacheEntireStream();
-      }
-      $byte = $size + $offset;
-    }
-    else {
-      throw new \InvalidArgumentException('Invalid whence');
-    }
-
-    $diff = $byte - $this->stream->getSize();
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        if ($whence == SEEK_SET) {
+            $byte = $offset;
+        }
+        elseif ($whence == SEEK_CUR) {
+            $byte = $offset + $this->tell();
+        }
+        elseif ($whence == SEEK_END) {
+            $size = $this->remoteStream->getSize();
+            if ($size === null) {
+                $size = $this->cacheEntireStream();
+            }
+            $byte = $size + $offset;
+        }
+        else {
+            throw new \InvalidArgumentException('Invalid whence');
+        }
 
-    if ($diff > 0) {
-      // Read the remoteStream until we have read in at least the amount
-      // of bytes requested, or we reach the end of the file.
-      while ($diff > 0 && !$this->remoteStream->eof()) {
-        $this->read($diff);
         $diff = $byte - $this->stream->getSize();
-      }
-    }
-    else {
-      // We can just do a normal seek since we've already seen this byte.
-      $this->stream->seek($byte);
+
+        if ($diff > 0) {
+            // Read the remoteStream until we have read in at least the amount
+            // of bytes requested, or we reach the end of the file.
+            while ($diff > 0 && !$this->remoteStream->eof()) {
+                $this->read($diff);
+                $diff = $byte - $this->stream->getSize();
+            }
+        }
+        else {
+            // We can just do a normal seek since we've already seen this byte.
+            $this->stream->seek($byte);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    // Perform a regular read on any previously read data from the buffer.
-    $data = $this->stream->read($length);
-    $remaining = $length - strlen($data);
+    public function read($length) 
+    {
+        // Perform a regular read on any previously read data from the buffer.
+        $data = $this->stream->read($length);
+        $remaining = $length - strlen($data);
 
-    // More data was requested so read from the remote stream.
-    if ($remaining) {
-      // If data was written to the buffer in a position that would have
-      // been filled from the remote stream, then we must skip bytes on
-      // the remote stream to emulate overwriting bytes from that
-      // position. This mimics the behavior of other PHP stream wrappers.
-      $remoteData = $this->remoteStream->read(
-        $remaining + $this->skipReadBytes
-      );
+        // More data was requested so read from the remote stream.
+        if ($remaining) {
+            // If data was written to the buffer in a position that would have
+            // been filled from the remote stream, then we must skip bytes on
+            // the remote stream to emulate overwriting bytes from that
+            // position. This mimics the behavior of other PHP stream wrappers.
+            $remoteData = $this->remoteStream->read(
+                $remaining + $this->skipReadBytes
+            );
 
-      if ($this->skipReadBytes) {
-        $len = strlen($remoteData);
-        $remoteData = substr($remoteData, $this->skipReadBytes);
-        $this->skipReadBytes = max(0, $this->skipReadBytes - $len);
-      }
+            if ($this->skipReadBytes) {
+                  $len = strlen($remoteData);
+                  $remoteData = substr($remoteData, $this->skipReadBytes);
+                  $this->skipReadBytes = max(0, $this->skipReadBytes - $len);
+            }
 
-      $data .= $remoteData;
-      $this->stream->write($remoteData);
-    }
+            $data .= $remoteData;
+            $this->stream->write($remoteData);
+        }
 
-    return $data;
-  }
+        return $data;
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    // When appending to the end of the currently read stream, you'll want
-    // to skip bytes from being read from the remote stream to emulate
-    // other stream wrappers. Basically replacing bytes of data of a fixed
-    // length.
-    $overflow = (strlen($string) + $this->tell()) - $this->remoteStream->tell();
-    if ($overflow > 0) {
-      $this->skipReadBytes += $overflow;
-    }
+    public function write($string) 
+    {
+        // When appending to the end of the currently read stream, you'll want
+        // to skip bytes from being read from the remote stream to emulate
+        // other stream wrappers. Basically replacing bytes of data of a fixed
+        // length.
+        $overflow = (strlen($string) + $this->tell()) - $this->remoteStream->tell();
+        if ($overflow > 0) {
+            $this->skipReadBytes += $overflow;
+        }
 
-    return $this->stream->write($string);
-  }
+        return $this->stream->write($string);
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return $this->stream->eof() && $this->remoteStream->eof();
-  }
+    public function eof() 
+    {
+        return $this->stream->eof() && $this->remoteStream->eof();
+    }
 
-  /**
+    /**
    * Close both the remote stream and buffer stream.
    */
-  public function close() {
-    $this->remoteStream->close() && $this->stream->close();
-  }
+    public function close() 
+    {
+        $this->remoteStream->close() && $this->stream->close();
+    }
 
-  /**
+    /**
    *
    */
-  private function cacheEntireStream() {
-    $target = new FnStream(['write' => 'strlen']);
-    copy_to_stream($this, $target);
+    private function cacheEntireStream() 
+    {
+        $target = new FnStream(['write' => 'strlen']);
+        copy_to_stream($this, $target);
 
-    return $this->tell();
-  }
+        return $this->tell();
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/PumpStream.php
+++ PHP_CodeSniffer
@@ -14,192 +14,215 @@
  * the read() function of the PumpStream. The provided callable MUST return
  * false when there is no more data to read.
  */
-class PumpStream implements StreamInterface {
-  /**
-   * @var callable*/
-  private $source;
-
-  /**
-   * @var int*/
-  private $size;
-
-  /**
-   * @var int*/
-  private $tellPos = 0;
-
-  /**
-   * @var array*/
-  private $metadata;
-
-  /**
-   * @var BufferStream*/
-  private $buffer;
+class PumpStream implements StreamInterface
+{
+    /**
+   * @var callable
+*/
+    private $source;
+
+    /**
+   * @var int
+*/
+    private $size;
+
+    /**
+   * @var int
+*/
+    private $tellPos = 0;
+
+    /**
+   * @var array
+*/
+    private $metadata;
+
+    /**
+   * @var BufferStream
+*/
+    private $buffer;
 
-  /**
+    /**
    * @param callable $source
    *   Source of the stream data. The callable MAY
    *   accept an integer argument used to control the
    *                         amount of data to return. The callable MUST
    *                         return a string when called, or false on error
    *                         or EOF.
-   * @param array $options
+   * @param array    $options
    *   Stream options:
    *   - metadata: Hash of metadata to use with stream.
    *                         - size: Size of the stream, if known.
    */
-  public function __construct(callable $source, array $options = []) {
-    $this->source = $source;
-    $this->size = isset($options['size']) ? $options['size'] : NULL;
-    $this->metadata = isset($options['metadata']) ? $options['metadata'] : [];
-    $this->buffer = new BufferStream();
-  }
+    public function __construct(callable $source, array $options = []) 
+    {
+        $this->source = $source;
+        $this->size = isset($options['size']) ? $options['size'] : null;
+        $this->metadata = isset($options['metadata']) ? $options['metadata'] : [];
+        $this->buffer = new BufferStream();
+    }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    try {
-      return copy_to_string($this);
-    }
-    catch (\Exception $e) {
-      return '';
+    public function __toString() 
+    {
+        try {
+            return copy_to_string($this);
+        }
+        catch (\Exception $e) {
+            return '';
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function close() {
-    $this->detach();
-  }
+    public function close() 
+    {
+        $this->detach();
+    }
 
-  /**
+    /**
    *
    */
-  public function detach() {
-    $this->tellPos = FALSE;
-    $this->source = NULL;
-  }
+    public function detach() 
+    {
+        $this->tellPos = false;
+        $this->source = null;
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    return $this->size;
-  }
+    public function getSize() 
+    {
+        return $this->size;
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    return $this->tellPos;
-  }
+    public function tell() 
+    {
+        return $this->tellPos;
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return !$this->source;
-  }
+    public function eof() 
+    {
+        return !$this->source;
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return FALSE;
-  }
+    public function isSeekable() 
+    {
+        return false;
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    throw new \RuntimeException('Cannot seek a PumpStream');
-  }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        throw new \RuntimeException('Cannot seek a PumpStream');
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return FALSE;
-  }
+    public function isWritable() 
+    {
+        return false;
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    throw new \RuntimeException('Cannot write to a PumpStream');
-  }
+    public function write($string) 
+    {
+        throw new \RuntimeException('Cannot write to a PumpStream');
+    }
 
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return TRUE;
-  }
+    public function isReadable() 
+    {
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    $data = $this->buffer->read($length);
-    $readLen = strlen($data);
-    $this->tellPos += $readLen;
-    $remaining = $length - $readLen;
+    public function read($length) 
+    {
+        $data = $this->buffer->read($length);
+        $readLen = strlen($data);
+        $this->tellPos += $readLen;
+        $remaining = $length - $readLen;
 
-    if ($remaining) {
-      $this->pump($remaining);
-      $data .= $this->buffer->read($remaining);
-      $this->tellPos += strlen($data) - $readLen;
-    }
+        if ($remaining) {
+            $this->pump($remaining);
+            $data .= $this->buffer->read($remaining);
+            $this->tellPos += strlen($data) - $readLen;
+        }
 
-    return $data;
-  }
+        return $data;
+    }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    $result = '';
-    while (!$this->eof()) {
-      $result .= $this->read(1000000);
-    }
+    public function getContents() 
+    {
+        $result = '';
+        while (!$this->eof()) {
+            $result .= $this->read(1000000);
+        }
 
-    return $result;
-  }
+        return $result;
+    }
 
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    if (!$key) {
-      return $this->metadata;
-    }
+    public function getMetadata($key = null) 
+    {
+        if (!$key) {
+            return $this->metadata;
+        }
 
-    return isset($this->metadata[$key]) ? $this->metadata[$key] : NULL;
-  }
+        return isset($this->metadata[$key]) ? $this->metadata[$key] : null;
+    }
 
-  /**
+    /**
    *
    */
-  private function pump($length) {
-    if ($this->source) {
-      do {
-        $data = call_user_func($this->source, $length);
-        if ($data === FALSE || $data === NULL) {
-          $this->source = NULL;
-          return;
+    private function pump($length) 
+    {
+        if ($this->source) {
+            do {
+                $data = call_user_func($this->source, $length);
+                if ($data === false || $data === null) {
+                    $this->source = null;
+                    return;
+                }
+                $this->buffer->write($data);
+                $length -= strlen($data);
+            } while ($length > 0);
         }
-        $this->buffer->write($data);
-        $length -= strlen($data);
-      } while ($length > 0);
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/NoSeekStream.php
+++ PHP_CodeSniffer
@@ -7,21 +7,24 @@
 /**
  * Stream decorator that prevents a stream from being seeked.
  */
-class NoSeekStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class NoSeekStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    throw new \RuntimeException('Cannot seek a NoSeekStream');
-  }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        throw new \RuntimeException('Cannot seek a NoSeekStream');
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return FALSE;
-  }
+    public function isSeekable() 
+    {
+        return false;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/Response.php
+++ PHP_CodeSniffer
@@ -7,12 +7,14 @@
 /**
  * PSR-7 response implementation.
  */
-class Response implements ResponseInterface {
-  use MessageTrait;
-
-  /**
-   * @var arrayMapofstandardHTTPstatuscodereasonphrases*/
-  private static $phrases = [
+class Response implements ResponseInterface
+{
+    use MessageTrait;
+
+    /**
+   * @var arrayMapofstandardHTTPstatuscodereasonphrases
+*/
+    private static $phrases = [
     100 => 'Continue',
     101 => 'Switching Protocols',
     102 => 'Processing',
@@ -71,77 +73,82 @@
     507 => 'Insufficient Storage',
     508 => 'Loop Detected',
     511 => 'Network Authentication Required',
-  ];
+    ];
 
-  /**
-   * @var string*/
-  private $reasonPhrase = '';
-
-  /**
-   * @var int*/
-  private $statusCode = 200;
+    /**
+   * @var string
+*/
+    private $reasonPhrase = '';
+
+    /**
+   * @var int
+*/
+    private $statusCode = 200;
 
-  /**
-   * @param int $status
+    /**
+   * @param int                                  $status
    *   Status code.
-   * @param array $headers
+   * @param array                                $headers
    *   Response headers.
    * @param string|null|resource|StreamInterface $body
    *   Response body.
-   * @param string $version
+   * @param string                               $version
    *   Protocol version.
-   * @param string|null $reason
+   * @param string|null                          $reason
    *   Reason phrase (when empty a default will be used based on the status code)
    */
-  public function __construct(
+    public function __construct(
         $status = 200,
         array $headers = [],
-        $body = NULL,
+        $body = null,
         $version = '1.1',
-        $reason = NULL
+        $reason = null
     ) {
-    $this->statusCode = (int) $status;
+        $this->statusCode = (int) $status;
 
-    if ($body !== '' && $body !== NULL) {
-      $this->stream = stream_for($body);
-    }
+        if ($body !== '' && $body !== null) {
+            $this->stream = stream_for($body);
+        }
+
+        $this->setHeaders($headers);
+        if ($reason == '' && isset(self::$phrases[$this->statusCode])) {
+            $this->reasonPhrase = self::$phrases[$this->statusCode];
+        }
+        else {
+            $this->reasonPhrase = (string) $reason;
+        }
 
-    $this->setHeaders($headers);
-    if ($reason == '' && isset(self::$phrases[$this->statusCode])) {
-      $this->reasonPhrase = self::$phrases[$this->statusCode];
-    }
-    else {
-      $this->reasonPhrase = (string) $reason;
+        $this->protocol = $version;
     }
 
-    $this->protocol = $version;
-  }
-
-  /**
+    /**
    *
    */
-  public function getStatusCode() {
-    return $this->statusCode;
-  }
+    public function getStatusCode() 
+    {
+        return $this->statusCode;
+    }
 
-  /**
+    /**
    *
    */
-  public function getReasonPhrase() {
-    return $this->reasonPhrase;
-  }
+    public function getReasonPhrase() 
+    {
+        return $this->reasonPhrase;
+    }
 
-  /**
+    /**
    *
    */
-  public function withStatus($code, $reasonPhrase = '') {
-    $new = clone $this;
-    $new->statusCode = (int) $code;
-    if ($reasonPhrase == '' && isset(self::$phrases[$new->statusCode])) {
-      $reasonPhrase = self::$phrases[$new->statusCode];
+    public function withStatus($code, $reasonPhrase = '') 
+    {
+        $new = clone $this;
+        $new->statusCode = (int) $code;
+        if ($reasonPhrase == '' && isset(self::$phrases[$new->statusCode])) {
+            $reasonPhrase = self::$phrases[$new->statusCode];
+        }
+        $new->reasonPhrase = $reasonPhrase;
+        return $new;
     }
-    $new->reasonPhrase = $reasonPhrase;
-    return $new;
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/InflateStream.php
+++ PHP_CodeSniffer
@@ -15,40 +15,43 @@
  * @link http://tools.ietf.org/html/rfc1952
  * @link http://php.net/manual/en/filters.compression.php
  */
-class InflateStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class InflateStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
 
-  /**
+    /**
    *
    */
-  public function __construct(StreamInterface $stream) {
-    // Read the first 10 bytes, ie. gzip header.
-    $header = $stream->read(10);
-    $filenameHeaderLength = $this->getLengthOfPossibleFilenameHeader($stream, $header);
-    // Skip the header, that is 10 + length of filename + 1 (nil) bytes.
-    $stream = new LimitStream($stream, -1, 10 + $filenameHeaderLength);
-    $resource = StreamWrapper::getResource($stream);
-    stream_filter_append($resource, 'zlib.inflate', STREAM_FILTER_READ);
-    $this->stream = new Stream($resource);
-  }
+    public function __construct(StreamInterface $stream) 
+    {
+        // Read the first 10 bytes, ie. gzip header.
+        $header = $stream->read(10);
+        $filenameHeaderLength = $this->getLengthOfPossibleFilenameHeader($stream, $header);
+        // Skip the header, that is 10 + length of filename + 1 (nil) bytes.
+        $stream = new LimitStream($stream, -1, 10 + $filenameHeaderLength);
+        $resource = StreamWrapper::getResource($stream);
+        stream_filter_append($resource, 'zlib.inflate', STREAM_FILTER_READ);
+        $this->stream = new Stream($resource);
+    }
 
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface $stream
    * @param $header
    * @return int
    */
-  private function getLengthOfPossibleFilenameHeader(StreamInterface $stream, $header) {
-    $filename_header_length = 0;
+    private function getLengthOfPossibleFilenameHeader(StreamInterface $stream, $header) 
+    {
+        $filename_header_length = 0;
 
-    if (substr(bin2hex($header), 6, 2) === '08') {
-      // We have a filename, read until nil.
-      $filename_header_length = 1;
-      while ($stream->read(1) !== chr(0)) {
-        $filename_header_length++;
-      }
-    }
+        if (substr(bin2hex($header), 6, 2) === '08') {
+            // We have a filename, read until nil.
+            $filename_header_length = 1;
+            while ($stream->read(1) !== chr(0)) {
+                $filename_header_length++;
+            }
+        }
 
-    return $filename_header_length;
-  }
+        return $filename_header_length;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/StreamWrapper.php
+++ PHP_CodeSniffer
@@ -7,20 +7,24 @@
 /**
  * Converts Guzzle streams into PHP stream resources.
  */
-class StreamWrapper {
-  /**
-   * @var resource*/
-  public $context;
-
-  /**
-   * @var \Psr\Http\Message\StreamInterface*/
-  private $stream;
-
-  /**
-   * @var stringrrorw*/
-  private $mode;
+class StreamWrapper
+{
+    /**
+   * @var resource
+*/
+    public $context;
+
+    /**
+   * @var \Psr\Http\Message\StreamInterface
+*/
+    private $stream;
+
+    /**
+   * @var stringrrorw
+*/
+    private $mode;
 
-  /**
+    /**
    * Returns a resource representing the stream.
    *
    * @param \Psr\Http\Message\StreamInterface $stream
@@ -30,112 +34,127 @@
    *
    * @throws \InvalidArgumentException if stream is not readable or writable
    */
-  public static function getResource(StreamInterface $stream) {
-    self::register();
-
-    if ($stream->isReadable()) {
-      $mode = $stream->isWritable() ? 'r+' : 'r';
-    }
-    elseif ($stream->isWritable()) {
-      $mode = 'w';
+    public static function getResource(StreamInterface $stream) 
+    {
+        self::register();
+
+        if ($stream->isReadable()) {
+            $mode = $stream->isWritable() ? 'r+' : 'r';
+        }
+        elseif ($stream->isWritable()) {
+            $mode = 'w';
+        }
+        else {
+            throw new \InvalidArgumentException(
+                'The stream must be readable, '
+                . 'writable, or both.'
+            );
+        }
+
+        return fopen(
+            'guzzle://stream', $mode, null, stream_context_create(
+                [
+                'guzzle' => ['stream' => $stream],
+                ]
+            )
+        );
     }
-    else {
-      throw new \InvalidArgumentException('The stream must be readable, '
-        . 'writable, or both.');
-    }
-
-    return fopen('guzzle://stream', $mode, NULL, stream_context_create([
-      'guzzle' => ['stream' => $stream],
-    ]));
-  }
 
-  /**
+    /**
    * Registers the stream wrapper if needed.
    */
-  public static function register() {
-    if (!in_array('guzzle', stream_get_wrappers())) {
-      stream_wrapper_register('guzzle', __CLASS__);
+    public static function register() 
+    {
+        if (!in_array('guzzle', stream_get_wrappers())) {
+            stream_wrapper_register('guzzle', __CLASS__);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function stream_open($path, $mode, $options, &$opened_path) {
-    $options = stream_context_get_options($this->context);
+    public function stream_open($path, $mode, $options, &$opened_path) 
+    {
+        $options = stream_context_get_options($this->context);
 
-    if (!isset($options['guzzle']['stream'])) {
-      return FALSE;
-    }
+        if (!isset($options['guzzle']['stream'])) {
+            return false;
+        }
 
-    $this->mode = $mode;
-    $this->stream = $options['guzzle']['stream'];
+        $this->mode = $mode;
+        $this->stream = $options['guzzle']['stream'];
 
-    return TRUE;
-  }
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_read($count) {
-    return $this->stream->read($count);
-  }
+    public function stream_read($count) 
+    {
+        return $this->stream->read($count);
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_write($data) {
-    return (int) $this->stream->write($data);
-  }
+    public function stream_write($data) 
+    {
+        return (int) $this->stream->write($data);
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_tell() {
-    return $this->stream->tell();
-  }
+    public function stream_tell() 
+    {
+        return $this->stream->tell();
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_eof() {
-    return $this->stream->eof();
-  }
+    public function stream_eof() 
+    {
+        return $this->stream->eof();
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_seek($offset, $whence) {
-    $this->stream->seek($offset, $whence);
+    public function stream_seek($offset, $whence) 
+    {
+        $this->stream->seek($offset, $whence);
 
-    return TRUE;
-  }
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function stream_stat() {
-    static $modeMap = [
-      'r'  => 33060,
-      'r+' => 33206,
-      'w'  => 33188,
-    ];
-
-    return [
-      'dev'     => 0,
-      'ino'     => 0,
-      'mode'    => $modeMap[$this->mode],
-      'nlink'   => 0,
-      'uid'     => 0,
-      'gid'     => 0,
-      'rdev'    => 0,
-      'size'    => $this->stream->getSize() ?: 0,
-      'atime'   => 0,
-      'mtime'   => 0,
-      'ctime'   => 0,
-      'blksize' => 0,
-      'blocks'  => 0,
-    ];
-  }
+    public function stream_stat() 
+    {
+        static $modeMap = [
+        'r'  => 33060,
+        'r+' => 33206,
+        'w'  => 33188,
+        ];
+
+        return [
+        'dev'     => 0,
+        'ino'     => 0,
+        'mode'    => $modeMap[$this->mode],
+        'nlink'   => 0,
+        'uid'     => 0,
+        'gid'     => 0,
+        'rdev'    => 0,
+        'size'    => $this->stream->getSize() ?: 0,
+        'atime'   => 0,
+        'mtime'   => 0,
+        'ctime'   => 0,
+        'blksize' => 0,
+        'blocks'  => 0,
+        ];
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/Stream.php
+++ PHP_CodeSniffer
@@ -9,58 +9,60 @@
  *
  * @var $stream
  */
-class Stream implements StreamInterface {
-  private $stream;
-  private $size;
-  private $seekable;
-  private $readable;
-  private $writable;
-  private $uri;
-  private $customMetadata;
-
-  /**
-   * @var arrayHashofreadableandwritablestreamtypes*/
-  private static $readWriteHash = [
+class Stream implements StreamInterface
+{
+    private $stream;
+    private $size;
+    private $seekable;
+    private $readable;
+    private $writable;
+    private $uri;
+    private $customMetadata;
+
+    /**
+   * @var arrayHashofreadableandwritablestreamtypes
+*/
+    private static $readWriteHash = [
     'read' => [
-      'r' => TRUE,
-      'w+' => TRUE,
-      'r+' => TRUE,
-      'x+' => TRUE,
-      'c+' => TRUE,
-      'rb' => TRUE,
-      'w+b' => TRUE,
-      'r+b' => TRUE,
-      'x+b' => TRUE,
-      'c+b' => TRUE,
-      'rt' => TRUE,
-      'w+t' => TRUE,
-      'r+t' => TRUE,
-      'x+t' => TRUE,
-      'c+t' => TRUE,
-      'a+' => TRUE,
+      'r' => true,
+      'w+' => true,
+      'r+' => true,
+      'x+' => true,
+      'c+' => true,
+      'rb' => true,
+      'w+b' => true,
+      'r+b' => true,
+      'x+b' => true,
+      'c+b' => true,
+      'rt' => true,
+      'w+t' => true,
+      'r+t' => true,
+      'x+t' => true,
+      'c+t' => true,
+      'a+' => true,
     ],
     'write' => [
-      'w' => TRUE,
-      'w+' => TRUE,
-      'rw' => TRUE,
-      'r+' => TRUE,
-      'x+' => TRUE,
-      'c+' => TRUE,
-      'wb' => TRUE,
-      'w+b' => TRUE,
-      'r+b' => TRUE,
-      'x+b' => TRUE,
-      'c+b' => TRUE,
-      'w+t' => TRUE,
-      'r+t' => TRUE,
-      'x+t' => TRUE,
-      'c+t' => TRUE,
-      'a' => TRUE,
-      'a+' => TRUE,
+      'w' => true,
+      'w+' => true,
+      'rw' => true,
+      'r+' => true,
+      'x+' => true,
+      'c+' => true,
+      'wb' => true,
+      'w+b' => true,
+      'r+b' => true,
+      'x+b' => true,
+      'c+b' => true,
+      'w+t' => true,
+      'r+t' => true,
+      'x+t' => true,
+      'c+t' => true,
+      'a' => true,
+      'a+' => true,
     ],
-  ];
+    ];
 
-  /**
+    /**
    * This constructor accepts an associative array of options.
    *
    * - size: (int) If a read stream would otherwise have an indeterminate
@@ -71,250 +73,270 @@
    *
    * @param resource $stream
    *   Stream resource to wrap.
-   * @param array $options
+   * @param array    $options
    *   Associative array of options.
    *
    * @throws \InvalidArgumentException if the stream is not a stream resource
    */
-  public function __construct($stream, $options = []) {
-    if (!is_resource($stream)) {
-      throw new \InvalidArgumentException('Stream must be a resource');
-    }
-
-    if (isset($options['size'])) {
-      $this->size = $options['size'];
-    }
+    public function __construct($stream, $options = []) 
+    {
+        if (!is_resource($stream)) {
+            throw new \InvalidArgumentException('Stream must be a resource');
+        }
+
+        if (isset($options['size'])) {
+            $this->size = $options['size'];
+        }
 
-    $this->customMetadata = isset($options['metadata'])
+        $this->customMetadata = isset($options['metadata'])
             ? $options['metadata']
             : [];
 
-    $this->stream = $stream;
-    $meta = stream_get_meta_data($this->stream);
-    $this->seekable = $meta['seekable'];
-    $this->readable = isset(self::$readWriteHash['read'][$meta['mode']]);
-    $this->writable = isset(self::$readWriteHash['write'][$meta['mode']]);
-    $this->uri = $this->getMetadata('uri');
-  }
+        $this->stream = $stream;
+        $meta = stream_get_meta_data($this->stream);
+        $this->seekable = $meta['seekable'];
+        $this->readable = isset(self::$readWriteHash['read'][$meta['mode']]);
+        $this->writable = isset(self::$readWriteHash['write'][$meta['mode']]);
+        $this->uri = $this->getMetadata('uri');
+    }
 
-  /**
+    /**
    *
    */
-  public function __get($name) {
-    if ($name == 'stream') {
-      throw new \RuntimeException('The stream is detached');
-    }
+    public function __get($name) 
+    {
+        if ($name == 'stream') {
+            throw new \RuntimeException('The stream is detached');
+        }
 
-    throw new \BadMethodCallException('No value for ' . $name);
-  }
+        throw new \BadMethodCallException('No value for ' . $name);
+    }
 
-  /**
+    /**
    * Closes the stream when the destructed.
    */
-  public function __destruct() {
-    $this->close();
-  }
+    public function __destruct() 
+    {
+        $this->close();
+    }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    try {
-      $this->seek(0);
-      return (string) stream_get_contents($this->stream);
-    }
-    catch (\Exception $e) {
-      return '';
+    public function __toString() 
+    {
+        try {
+            $this->seek(0);
+            return (string) stream_get_contents($this->stream);
+        }
+        catch (\Exception $e) {
+            return '';
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    $contents = stream_get_contents($this->stream);
+    public function getContents() 
+    {
+        $contents = stream_get_contents($this->stream);
 
-    if ($contents === FALSE) {
-      throw new \RuntimeException('Unable to read stream contents');
-    }
+        if ($contents === false) {
+            throw new \RuntimeException('Unable to read stream contents');
+        }
 
-    return $contents;
-  }
+        return $contents;
+    }
 
-  /**
+    /**
    *
    */
-  public function close() {
-    if (isset($this->stream)) {
-      if (is_resource($this->stream)) {
-        fclose($this->stream);
-      }
-      $this->detach();
+    public function close() 
+    {
+        if (isset($this->stream)) {
+            if (is_resource($this->stream)) {
+                fclose($this->stream);
+            }
+            $this->detach();
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function detach() {
-    if (!isset($this->stream)) {
-      return NULL;
-    }
+    public function detach() 
+    {
+        if (!isset($this->stream)) {
+            return null;
+        }
 
-    $result = $this->stream;
-    unset($this->stream);
-    $this->size = $this->uri = NULL;
-    $this->readable = $this->writable = $this->seekable = FALSE;
+        $result = $this->stream;
+        unset($this->stream);
+        $this->size = $this->uri = null;
+        $this->readable = $this->writable = $this->seekable = false;
 
-    return $result;
-  }
+        return $result;
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    if ($this->size !== NULL) {
-      return $this->size;
-    }
+    public function getSize() 
+    {
+        if ($this->size !== null) {
+            return $this->size;
+        }
 
-    if (!isset($this->stream)) {
-      return NULL;
-    }
+        if (!isset($this->stream)) {
+            return null;
+        }
 
-    // Clear the stat cache if the stream has a URI.
-    if ($this->uri) {
-      clearstatcache(TRUE, $this->uri);
-    }
+        // Clear the stat cache if the stream has a URI.
+        if ($this->uri) {
+            clearstatcache(true, $this->uri);
+        }
 
-    $stats = fstat($this->stream);
-    if (isset($stats['size'])) {
-      $this->size = $stats['size'];
-      return $this->size;
-    }
+        $stats = fstat($this->stream);
+        if (isset($stats['size'])) {
+            $this->size = $stats['size'];
+            return $this->size;
+        }
 
-    return NULL;
-  }
+        return null;
+    }
 
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return $this->readable;
-  }
+    public function isReadable() 
+    {
+        return $this->readable;
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return $this->writable;
-  }
+    public function isWritable() 
+    {
+        return $this->writable;
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return $this->seekable;
-  }
+    public function isSeekable() 
+    {
+        return $this->seekable;
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return !$this->stream || feof($this->stream);
-  }
+    public function eof() 
+    {
+        return !$this->stream || feof($this->stream);
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    $result = ftell($this->stream);
+    public function tell() 
+    {
+        $result = ftell($this->stream);
 
-    if ($result === FALSE) {
-      throw new \RuntimeException('Unable to determine stream position');
-    }
+        if ($result === false) {
+            throw new \RuntimeException('Unable to determine stream position');
+        }
 
-    return $result;
-  }
+        return $result;
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    if (!$this->seekable) {
-      throw new \RuntimeException('Stream is not seekable');
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        if (!$this->seekable) {
+            throw new \RuntimeException('Stream is not seekable');
+        }
+        elseif (fseek($this->stream, $offset, $whence) === -1) {
+            throw new \RuntimeException(
+                'Unable to seek to stream position '
+                . $offset . ' with whence ' . var_export($whence, true)
+            );
+        }
     }
-    elseif (fseek($this->stream, $offset, $whence) === -1) {
-      throw new \RuntimeException('Unable to seek to stream position '
-        . $offset . ' with whence ' . var_export($whence, TRUE));
-    }
-  }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    if (!$this->readable) {
-      throw new \RuntimeException('Cannot read from non-readable stream');
-    }
-    if ($length < 0) {
-      throw new \RuntimeException('Length parameter cannot be negative');
-    }
+    public function read($length) 
+    {
+        if (!$this->readable) {
+            throw new \RuntimeException('Cannot read from non-readable stream');
+        }
+        if ($length < 0) {
+            throw new \RuntimeException('Length parameter cannot be negative');
+        }
 
-    if (0 === $length) {
-      return '';
-    }
+        if (0 === $length) {
+            return '';
+        }
 
-    $string = fread($this->stream, $length);
-    if (FALSE === $string) {
-      throw new \RuntimeException('Unable to read from stream');
-    }
+        $string = fread($this->stream, $length);
+        if (false === $string) {
+            throw new \RuntimeException('Unable to read from stream');
+        }
 
-    return $string;
-  }
+        return $string;
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    if (!$this->writable) {
-      throw new \RuntimeException('Cannot write to a non-writable stream');
-    }
+    public function write($string) 
+    {
+        if (!$this->writable) {
+            throw new \RuntimeException('Cannot write to a non-writable stream');
+        }
 
-    // We can't know the size after writing anything.
-    $this->size = NULL;
-    $result = fwrite($this->stream, $string);
+        // We can't know the size after writing anything.
+        $this->size = null;
+        $result = fwrite($this->stream, $string);
 
-    if ($result === FALSE) {
-      throw new \RuntimeException('Unable to write to stream');
-    }
+        if ($result === false) {
+            throw new \RuntimeException('Unable to write to stream');
+        }
 
-    return $result;
-  }
+        return $result;
+    }
 
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    if (!isset($this->stream)) {
-      return $key ? NULL : [];
-    }
-    elseif (!$key) {
-      return $this->customMetadata + stream_get_meta_data($this->stream);
-    }
-    elseif (isset($this->customMetadata[$key])) {
-      return $this->customMetadata[$key];
-    }
+    public function getMetadata($key = null) 
+    {
+        if (!isset($this->stream)) {
+            return $key ? null : [];
+        }
+        elseif (!$key) {
+            return $this->customMetadata + stream_get_meta_data($this->stream);
+        }
+        elseif (isset($this->customMetadata[$key])) {
+            return $this->customMetadata[$key];
+        }
 
-    $meta = stream_get_meta_data($this->stream);
+        $meta = stream_get_meta_data($this->stream);
 
-    return isset($meta[$key]) ? $meta[$key] : NULL;
-  }
+        return isset($meta[$key]) ? $meta[$key] : null;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/Request.php
+++ PHP_CodeSniffer
@@ -9,157 +9,168 @@
 /**
  * PSR-7 request implementation.
  */
-class Request implements RequestInterface {
-  use MessageTrait;
+class Request implements RequestInterface
+{
+    use MessageTrait;
+
+    /**
+   * @var string
+*/
+    private $method;
+
+    /**
+   * @var null|string
+*/
+    private $requestTarget;
+
+    /**
+   * @var \Psr\Http\Message\UriInterface
+*/
+    private $uri;
 
-  /**
-   * @var string*/
-  private $method;
-
-  /**
-   * @var null|string*/
-  private $requestTarget;
-
-  /**
-   * @var \Psr\Http\Message\UriInterface*/
-  private $uri;
-
-  /**
-   * @param string $method
+    /**
+   * @param string                               $method
    *   HTTP method.
-   * @param string|UriInterface $uri
+   * @param string|UriInterface                  $uri
    *   URI.
-   * @param array $headers
+   * @param array                                $headers
    *   Request headers.
    * @param string|null|resource|StreamInterface $body
    *   Request body.
-   * @param string $version
+   * @param string                               $version
    *   Protocol version.
    */
-  public function __construct(
+    public function __construct(
         $method,
         $uri,
         array $headers = [],
-        $body = NULL,
+        $body = null,
         $version = '1.1'
     ) {
-    if (!($uri instanceof UriInterface)) {
-      $uri = new Uri($uri);
-    }
+        if (!($uri instanceof UriInterface)) {
+            $uri = new Uri($uri);
+        }
 
-    $this->method = strtoupper($method);
-    $this->uri = $uri;
-    $this->setHeaders($headers);
-    $this->protocol = $version;
+        $this->method = strtoupper($method);
+        $this->uri = $uri;
+        $this->setHeaders($headers);
+        $this->protocol = $version;
 
-    if (!$this->hasHeader('Host')) {
-      $this->updateHostFromUri();
-    }
+        if (!$this->hasHeader('Host')) {
+            $this->updateHostFromUri();
+        }
 
-    if ($body !== '' && $body !== NULL) {
-      $this->stream = stream_for($body);
+        if ($body !== '' && $body !== null) {
+            $this->stream = stream_for($body);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function getRequestTarget() {
-    if ($this->requestTarget !== NULL) {
-      return $this->requestTarget;
-    }
+    public function getRequestTarget() 
+    {
+        if ($this->requestTarget !== null) {
+            return $this->requestTarget;
+        }
 
-    $target = $this->uri->getPath();
-    if ($target == '') {
-      $target = '/';
-    }
-    if ($this->uri->getQuery() != '') {
-      $target .= '?' . $this->uri->getQuery();
-    }
+        $target = $this->uri->getPath();
+        if ($target == '') {
+            $target = '/';
+        }
+        if ($this->uri->getQuery() != '') {
+            $target .= '?' . $this->uri->getQuery();
+        }
 
-    return $target;
-  }
+        return $target;
+    }
 
-  /**
+    /**
    *
    */
-  public function withRequestTarget($requestTarget) {
-    if (preg_match('#\s#', $requestTarget)) {
-      throw new InvalidArgumentException(
-        'Invalid request target provided; cannot contain whitespace'
-      );
-    }
+    public function withRequestTarget($requestTarget) 
+    {
+        if (preg_match('#\s#', $requestTarget)) {
+            throw new InvalidArgumentException(
+                'Invalid request target provided; cannot contain whitespace'
+            );
+        }
 
-    $new = clone $this;
-    $new->requestTarget = $requestTarget;
-    return $new;
-  }
+        $new = clone $this;
+        $new->requestTarget = $requestTarget;
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function getMethod() {
-    return $this->method;
-  }
+    public function getMethod() 
+    {
+        return $this->method;
+    }
 
-  /**
+    /**
    *
    */
-  public function withMethod($method) {
-    $new = clone $this;
-    $new->method = strtoupper($method);
-    return $new;
-  }
+    public function withMethod($method) 
+    {
+        $new = clone $this;
+        $new->method = strtoupper($method);
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function getUri() {
-    return $this->uri;
-  }
+    public function getUri() 
+    {
+        return $this->uri;
+    }
 
-  /**
+    /**
    *
    */
-  public function withUri(UriInterface $uri, $preserveHost = FALSE) {
-    if ($uri === $this->uri) {
-      return $this;
-    }
+    public function withUri(UriInterface $uri, $preserveHost = false) 
+    {
+        if ($uri === $this->uri) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->uri = $uri;
+        $new = clone $this;
+        $new->uri = $uri;
 
-    if (!$preserveHost) {
-      $new->updateHostFromUri();
-    }
+        if (!$preserveHost) {
+            $new->updateHostFromUri();
+        }
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  private function updateHostFromUri() {
-    $host = $this->uri->getHost();
+    private function updateHostFromUri() 
+    {
+        $host = $this->uri->getHost();
 
-    if ($host == '') {
-      return;
-    }
+        if ($host == '') {
+            return;
+        }
 
-    if (($port = $this->uri->getPort()) !== NULL) {
-      $host .= ':' . $port;
-    }
+        if (($port = $this->uri->getPort()) !== null) {
+            $host .= ':' . $port;
+        }
 
-    if (isset($this->headerNames['host'])) {
-      $header = $this->headerNames['host'];
-    }
-    else {
-      $header = 'Host';
-      $this->headerNames['host'] = 'Host';
+        if (isset($this->headerNames['host'])) {
+            $header = $this->headerNames['host'];
+        }
+        else {
+            $header = 'Host';
+            $this->headerNames['host'] = 'Host';
+        }
+        // Ensure Host is the first header.
+        // See: http://tools.ietf.org/html/rfc7230#section-5.4
+        $this->headers = [$header => [$host]] + $this->headers;
     }
-    // Ensure Host is the first header.
-    // See: http://tools.ietf.org/html/rfc7230#section-5.4
-    $this->headers = [$header => [$host]] + $this->headers;
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/DroppingStream.php
+++ PHP_CodeSniffer
@@ -8,39 +8,42 @@
  * Stream decorator that begins dropping data once the size of the underlying
  * stream becomes too full.
  */
-class DroppingStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class DroppingStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
 
-  private $maxLength;
+    private $maxLength;
 
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface $stream
    *   Underlying stream to decorate.
-   * @param int $maxLength
+   * @param int                               $maxLength
    *   Maximum size before dropping data.
    */
-  public function __construct(StreamInterface $stream, $maxLength) {
-    $this->stream = $stream;
-    $this->maxLength = $maxLength;
-  }
+    public function __construct(StreamInterface $stream, $maxLength) 
+    {
+        $this->stream = $stream;
+        $this->maxLength = $maxLength;
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    $diff = $this->maxLength - $this->stream->getSize();
-
-    // Begin returning 0 when the underlying stream is too large.
-    if ($diff <= 0) {
-      return 0;
-    }
+    public function write($string) 
+    {
+        $diff = $this->maxLength - $this->stream->getSize();
+
+        // Begin returning 0 when the underlying stream is too large.
+        if ($diff <= 0) {
+            return 0;
+        }
+
+        // Write the stream or a subset of the stream if needed.
+        if (strlen($string) < $diff) {
+            return $this->stream->write($string);
+        }
 
-    // Write the stream or a subset of the stream if needed.
-    if (strlen($string) < $diff) {
-      return $this->stream->write($string);
+        return $this->stream->write(substr($string, 0, $diff));
     }
 
-    return $this->stream->write(substr($string, 0, $diff));
-  }
-
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/LazyOpenStream.php
+++ PHP_CodeSniffer
@@ -8,35 +8,40 @@
  * Lazily reads or writes to a file that is opened only after an IO operation
  * take place on the stream.
  */
-class LazyOpenStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class LazyOpenStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
 
-  /**
-   * @var stringFiletoopen*/
-  private $filename;
+    /**
+   * @var stringFiletoopen
+*/
+    private $filename;
 
-  /**
-   * @var string*/
-  private $mode;
+    /**
+   * @var string
+*/
+    private $mode;
 
-  /**
+    /**
    * @param string $filename
    *   File to lazily open.
    * @param string $mode
    *   fopen mode to use when opening the stream.
    */
-  public function __construct($filename, $mode) {
-    $this->filename = $filename;
-    $this->mode = $mode;
-  }
+    public function __construct($filename, $mode) 
+    {
+        $this->filename = $filename;
+        $this->mode = $mode;
+    }
 
-  /**
+    /**
    * Creates the underlying stream lazily when required.
    *
    * @return \Psr\Http\Message\StreamInterface
    */
-  protected function createStream() {
-    return stream_for(try_fopen($this->filename, $this->mode));
-  }
+    protected function createStream() 
+    {
+        return stream_for(try_fopen($this->filename, $this->mode));
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/BufferStream.php
+++ PHP_CodeSniffer
@@ -12,11 +12,12 @@
  * what the configured high water mark of the stream is, or the maximum
  * preferred size of the buffer.
  */
-class BufferStream implements StreamInterface {
-  private $hwm;
-  private $buffer = '';
+class BufferStream implements StreamInterface
+{
+    private $hwm;
+    private $buffer = '';
 
-  /**
+    /**
    * @param int $hwm
    *   High water mark, representing the preferred maximum
    *   buffer size. If the size of the buffer exceeds the high
@@ -24,140 +25,156 @@
    *                 but will return false to inform writers to slow down
    *                 until the buffer has been drained by reading from it.
    */
-  public function __construct($hwm = 16384) {
-    $this->hwm = $hwm;
-  }
+    public function __construct($hwm = 16384) 
+    {
+        $this->hwm = $hwm;
+    }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    return $this->getContents();
-  }
+    public function __toString() 
+    {
+        return $this->getContents();
+    }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    $buffer = $this->buffer;
-    $this->buffer = '';
+    public function getContents() 
+    {
+        $buffer = $this->buffer;
+        $this->buffer = '';
 
-    return $buffer;
-  }
+        return $buffer;
+    }
 
-  /**
+    /**
    *
    */
-  public function close() {
-    $this->buffer = '';
-  }
+    public function close() 
+    {
+        $this->buffer = '';
+    }
 
-  /**
+    /**
    *
    */
-  public function detach() {
-    $this->close();
-  }
+    public function detach() 
+    {
+        $this->close();
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    return strlen($this->buffer);
-  }
+    public function getSize() 
+    {
+        return strlen($this->buffer);
+    }
 
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return TRUE;
-  }
+    public function isReadable() 
+    {
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return TRUE;
-  }
+    public function isWritable() 
+    {
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return FALSE;
-  }
+    public function isSeekable() 
+    {
+        return false;
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    throw new \RuntimeException('Cannot seek a BufferStream');
-  }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        throw new \RuntimeException('Cannot seek a BufferStream');
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return strlen($this->buffer) === 0;
-  }
+    public function eof() 
+    {
+        return strlen($this->buffer) === 0;
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    throw new \RuntimeException('Cannot determine the position of a BufferStream');
-  }
+    public function tell() 
+    {
+        throw new \RuntimeException('Cannot determine the position of a BufferStream');
+    }
 
-  /**
+    /**
    * Reads data from the buffer.
    */
-  public function read($length) {
-    $currentLength = strlen($this->buffer);
+    public function read($length) 
+    {
+        $currentLength = strlen($this->buffer);
+
+        if ($length >= $currentLength) {
+            // No need to slice the buffer because we don't have enough data.
+            $result = $this->buffer;
+            $this->buffer = '';
+        }
+        else {
+            // Slice up the result to provide a subset of the buffer.
+            $result = substr($this->buffer, 0, $length);
+            $this->buffer = substr($this->buffer, $length);
+        }
 
-    if ($length >= $currentLength) {
-      // No need to slice the buffer because we don't have enough data.
-      $result = $this->buffer;
-      $this->buffer = '';
-    }
-    else {
-      // Slice up the result to provide a subset of the buffer.
-      $result = substr($this->buffer, 0, $length);
-      $this->buffer = substr($this->buffer, $length);
+        return $result;
     }
 
-    return $result;
-  }
-
-  /**
+    /**
    * Writes data to the buffer.
    */
-  public function write($string) {
-    $this->buffer .= $string;
+    public function write($string) 
+    {
+        $this->buffer .= $string;
+
+        // TODO: What should happen here?
+        if (strlen($this->buffer) >= $this->hwm) {
+            return false;
+        }
 
-    // TODO: What should happen here?
-    if (strlen($this->buffer) >= $this->hwm) {
-      return FALSE;
+        return strlen($string);
     }
 
-    return strlen($string);
-  }
-
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    if ($key == 'hwm') {
-      return $this->hwm;
-    }
+    public function getMetadata($key = null) 
+    {
+        if ($key == 'hwm') {
+            return $this->hwm;
+        }
 
-    return $key ? NULL : [];
-  }
+        return $key ? null : [];
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/Uri.php
+++ PHP_CodeSniffer
@@ -11,16 +11,17 @@
  * @author Tobias Schultze
  * @author Matthew Weier O'Phinney
  */
-class Uri implements UriInterface {
-  /**
+class Uri implements UriInterface
+{
+    /**
      * Absolute http and https URIs require a host per RFC 7230 Section 2.7
      * but in generic URIs the host can be empty. So for http(s) URIs
      * we apply this default host when no host is given yet to form a
      * valid URI.
      */
-  const HTTP_DEFAULT_HOST = 'localhost';
+    const HTTP_DEFAULT_HOST = 'localhost';
 
-  private static $defaultPorts = [
+    private static $defaultPorts = [
     'http'  => 80,
     'https' => 443,
     'ftp' => 21,
@@ -32,69 +33,78 @@
     'imap' => 143,
     'pop' => 110,
     'ldap' => 389,
-  ];
+    ];
 
-  private static $charUnreserved = 'a-zA-Z0-9_\-\.~';
-  private static $charSubDelims = '!\$&\'\(\)\*\+,;=';
-  private static $replaceQuery = ['=' => '%3D', '&' => '%26'];
+    private static $charUnreserved = 'a-zA-Z0-9_\-\.~';
+    private static $charSubDelims = '!\$&\'\(\)\*\+,;=';
+    private static $replaceQuery = ['=' => '%3D', '&' => '%26'];
+
+    /**
+   * @var stringUrischeme
+*/
+    private $scheme = '';
+
+    /**
+   * @var stringUriuserinfo
+*/
+    private $userInfo = '';
+
+    /**
+   * @var stringUrihost
+*/
+    private $host = '';
+
+    /**
+   * @var int|nullUriport
+*/
+    private $port;
+
+    /**
+   * @var stringUripath
+*/
+    private $path = '';
+
+    /**
+   * @var stringUriquerystring
+*/
+    private $query = '';
+
+    /**
+   * @var stringUrifragment
+*/
+    private $fragment = '';
 
-  /**
-   * @var stringUrischeme*/
-  private $scheme = '';
-
-  /**
-   * @var stringUriuserinfo*/
-  private $userInfo = '';
-
-  /**
-   * @var stringUrihost*/
-  private $host = '';
-
-  /**
-   * @var int|nullUriport*/
-  private $port;
-
-  /**
-   * @var stringUripath*/
-  private $path = '';
-
-  /**
-   * @var stringUriquerystring*/
-  private $query = '';
-
-  /**
-   * @var stringUrifragment*/
-  private $fragment = '';
-
-  /**
+    /**
    * @param string $uri
    *   URI to parse.
    */
-  public function __construct($uri = '') {
-    // Weak type check to also accept null until we can add scalar type hints.
-    if ($uri != '') {
-      $parts = parse_url($uri);
-      if ($parts === FALSE) {
-        throw new \InvalidArgumentException("Unable to parse URI: $uri");
-      }
-      $this->applyParts($parts);
-    }
-  }
-
-  /**
-   *
-   */
-  public function __toString() {
-    return self::composeComponents(
-        $this->scheme,
-        $this->getAuthority(),
-        $this->path,
-        $this->query,
-        $this->fragment
-    );
-  }
+    public function __construct($uri = '') 
+    {
+        // Weak type check to also accept null until we can add scalar type hints.
+        if ($uri != '') {
+            $parts = parse_url($uri);
+            if ($parts === false) {
+                throw new \InvalidArgumentException("Unable to parse URI: $uri");
+            }
+            $this->applyParts($parts);
+        }
+    }
+
+    /**
+   *
+   */
+    public function __toString() 
+    {
+        return self::composeComponents(
+            $this->scheme,
+            $this->getAuthority(),
+            $this->path,
+            $this->query,
+            $this->fragment
+        );
+    }
 
-  /**
+    /**
    * Composes a URI reference string from its various components.
    *
    * Usually this method does not need to be called manually but instead is used indirectly via
@@ -120,32 +130,33 @@
    *
    * @link https://tools.ietf.org/html/rfc3986#section-5.3
    */
-  public static function composeComponents($scheme, $authority, $path, $query, $fragment) {
-    $uri = '';
+    public static function composeComponents($scheme, $authority, $path, $query, $fragment) 
+    {
+        $uri = '';
 
-    // Weak type checks to also accept null until we can add scalar type hints.
-    if ($scheme != '') {
-      $uri .= $scheme . ':';
-    }
+        // Weak type checks to also accept null until we can add scalar type hints.
+        if ($scheme != '') {
+            $uri .= $scheme . ':';
+        }
 
-    if ($authority != ''|| $scheme === 'file') {
-      $uri .= '//' . $authority;
-    }
+        if ($authority != ''|| $scheme === 'file') {
+            $uri .= '//' . $authority;
+        }
 
-    $uri .= $path;
+        $uri .= $path;
 
-    if ($query != '') {
-      $uri .= '?' . $query;
-    }
+        if ($query != '') {
+            $uri .= '?' . $query;
+        }
 
-    if ($fragment != '') {
-      $uri .= '#' . $fragment;
-    }
+        if ($fragment != '') {
+            $uri .= '#' . $fragment;
+        }
 
-    return $uri;
-  }
+        return $uri;
+    }
 
-  /**
+    /**
    * Whether the URI has the default port of the current scheme.
    *
    * `Psr\Http\Message\UriInterface::getPort` may return null or the standard port. This method can be used
@@ -155,12 +166,13 @@
    *
    * @return bool
    */
-  public static function isDefaultPort(UriInterface $uri) {
-    return $uri->getPort() === NULL
+    public static function isDefaultPort(UriInterface $uri) 
+    {
+        return $uri->getPort() === null
             || (isset(self::$defaultPorts[$uri->getScheme()]) && $uri->getPort() === self::$defaultPorts[$uri->getScheme()]);
-  }
+    }
 
-  /**
+    /**
    * Whether the URI is absolute, i.e. it has a scheme.
    *
    * An instance of UriInterface can either be an absolute URI or a relative reference. This method returns true
@@ -174,16 +186,17 @@
    *
    * @return bool
    *
-   * @see Uri::isNetworkPathReference
-   * @see Uri::isAbsolutePathReference
-   * @see Uri::isRelativePathReference
+   * @see  Uri::isNetworkPathReference
+   * @see  Uri::isAbsolutePathReference
+   * @see  Uri::isRelativePathReference
    * @link https://tools.ietf.org/html/rfc3986#section-4
    */
-  public static function isAbsolute(UriInterface $uri) {
-    return $uri->getScheme() !== '';
-  }
+    public static function isAbsolute(UriInterface $uri) 
+    {
+        return $uri->getScheme() !== '';
+    }
 
-  /**
+    /**
    * Whether the URI is a network-path reference.
    *
    * A relative reference that begins with two slash characters is termed an network-path reference.
@@ -194,11 +207,12 @@
    *
    * @link https://tools.ietf.org/html/rfc3986#section-4.2
    */
-  public static function isNetworkPathReference(UriInterface $uri) {
-    return $uri->getScheme() === '' && $uri->getAuthority() !== '';
-  }
+    public static function isNetworkPathReference(UriInterface $uri) 
+    {
+        return $uri->getScheme() === '' && $uri->getAuthority() !== '';
+    }
 
-  /**
+    /**
    * Whether the URI is a absolute-path reference.
    *
    * A relative reference that begins with a single slash character is termed an absolute-path reference.
@@ -209,14 +223,15 @@
    *
    * @link https://tools.ietf.org/html/rfc3986#section-4.2
    */
-  public static function isAbsolutePathReference(UriInterface $uri) {
-    return $uri->getScheme() === ''
+    public static function isAbsolutePathReference(UriInterface $uri) 
+    {
+        return $uri->getScheme() === ''
             && $uri->getAuthority() === ''
             && isset($uri->getPath()[0])
             && $uri->getPath()[0] === '/';
-  }
+    }
 
-  /**
+    /**
    * Whether the URI is a relative-path reference.
    *
    * A relative reference that does not begin with a slash character is termed a relative-path reference.
@@ -227,20 +242,21 @@
    *
    * @link https://tools.ietf.org/html/rfc3986#section-4.2
    */
-  public static function isRelativePathReference(UriInterface $uri) {
-    return $uri->getScheme() === ''
+    public static function isRelativePathReference(UriInterface $uri) 
+    {
+        return $uri->getScheme() === ''
             && $uri->getAuthority() === ''
             && (!isset($uri->getPath()[0]) || $uri->getPath()[0] !== '/');
-  }
+    }
 
-  /**
+    /**
    * Whether the URI is a same-document reference.
    *
    * A same-document reference refers to a URI that is, aside from its fragment
    * component, identical to the base URI. When no base URI is given, only an empty
    * URI reference (apart from its fragment) is considered a same-document reference.
    *
-   * @param \Psr\Http\Message\UriInterface $uri
+   * @param \Psr\Http\Message\UriInterface      $uri
    *   The URI to check.
    * @param \Psr\Http\Message\UriInterface|null $base
    *   An optional base URI to compare against.
@@ -249,20 +265,21 @@
    *
    * @link https://tools.ietf.org/html/rfc3986#section-4.4
    */
-  public static function isSameDocumentReference(UriInterface $uri, UriInterface $base = NULL) {
-    if ($base !== NULL) {
-      $uri = UriResolver::resolve($base, $uri);
+    public static function isSameDocumentReference(UriInterface $uri, UriInterface $base = null) 
+    {
+        if ($base !== null) {
+            $uri = UriResolver::resolve($base, $uri);
 
-      return ($uri->getScheme() === $base->getScheme())
+            return ($uri->getScheme() === $base->getScheme())
                 && ($uri->getAuthority() === $base->getAuthority())
                 && ($uri->getPath() === $base->getPath())
                 && ($uri->getQuery() === $base->getQuery());
-    }
+        }
 
-    return $uri->getScheme() === '' && $uri->getAuthority() === '' && $uri->getPath() === '' && $uri->getQuery() === '';
-  }
+        return $uri->getScheme() === '' && $uri->getAuthority() === '' && $uri->getPath() === '' && $uri->getQuery() === '';
+    }
 
-  /**
+    /**
    * Removes dot segments from a path and returns the new path.
    *
    * @param string $path
@@ -270,34 +287,36 @@
    * @return string
    *
    * @deprecated since version 1.4. Use UriResolver::removeDotSegments instead.
-   * @see UriResolver::removeDotSegments
+   * @see        UriResolver::removeDotSegments
    */
-  public static function removeDotSegments($path) {
-    return UriResolver::removeDotSegments($path);
-  }
+    public static function removeDotSegments($path) 
+    {
+        return UriResolver::removeDotSegments($path);
+    }
 
-  /**
+    /**
    * Converts the relative URI into a new URI that is resolved against the base URI.
    *
    * @param \Psr\Http\Message\UriInterface $base
    *   Base URI.
-   * @param string|UriInterface $rel
+   * @param string|UriInterface            $rel
    *   Relative URI.
    *
    * @return \Psr\Http\Message\UriInterface
    *
    * @deprecated since version 1.4. Use UriResolver::resolve instead.
-   * @see UriResolver::resolve
+   * @see        UriResolver::resolve
    */
-  public static function resolve(UriInterface $base, $rel) {
-    if (!($rel instanceof UriInterface)) {
-      $rel = new self($rel);
-    }
+    public static function resolve(UriInterface $base, $rel) 
+    {
+        if (!($rel instanceof UriInterface)) {
+            $rel = new self($rel);
+        }
 
-    return UriResolver::resolve($base, $rel);
-  }
+        return UriResolver::resolve($base, $rel);
+    }
 
-  /**
+    /**
    * Creates a new URI with a specific query string value removed.
    *
    * Any existing query string values that exactly match the provided key are
@@ -305,26 +324,29 @@
    *
    * @param \Psr\Http\Message\UriInterface $uri
    *   URI to use as a base.
-   * @param string $key
+   * @param string                         $key
    *   Query string key to remove.
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  public static function withoutQueryValue(UriInterface $uri, $key) {
-    $current = $uri->getQuery();
-    if ($current === '') {
-      return $uri;
-    }
-
-    $decodedKey = rawurldecode($key);
-    $result = array_filter(explode('&', $current), function ($part) use ($decodedKey) {
-      return rawurldecode(explode('=', $part)[0]) !== $decodedKey;
-    });
+    public static function withoutQueryValue(UriInterface $uri, $key) 
+    {
+        $current = $uri->getQuery();
+        if ($current === '') {
+            return $uri;
+        }
+
+        $decodedKey = rawurldecode($key);
+        $result = array_filter(
+            explode('&', $current), function ($part) use ($decodedKey) {
+                return rawurldecode(explode('=', $part)[0]) !== $decodedKey;
+            }
+        );
 
-    return $uri->withQuery(implode('&', $result));
-  }
+        return $uri->withQuery(implode('&', $result));
+    }
 
-  /**
+    /**
    * Creates a new URI with a specific query string value.
    *
    * Any existing query string values that exactly match the provided key are
@@ -335,42 +357,45 @@
    *
    * @param \Psr\Http\Message\UriInterface $uri
    *   URI to use as a base.
-   * @param string $key
+   * @param string                         $key
    *   Key to set.
-   * @param string|null $value
+   * @param string|null                    $value
    *   Value to set.
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  public static function withQueryValue(UriInterface $uri, $key, $value) {
-    $current = $uri->getQuery();
-
-    if ($current === '') {
-      $result = [];
-    }
-    else {
-      $decodedKey = rawurldecode($key);
-      $result = array_filter(explode('&', $current), function ($part) use ($decodedKey) {
-        return rawurldecode(explode('=', $part)[0]) !== $decodedKey;
-      });
-    }
-
-    // Query string separators ("=", "&") within the key or value need to be encoded
-    // (while preventing double-encoding) before setting the query string. All other
-    // chars that need percent-encoding will be encoded by withQuery().
-    $key = strtr($key, self::$replaceQuery);
+    public static function withQueryValue(UriInterface $uri, $key, $value) 
+    {
+        $current = $uri->getQuery();
+
+        if ($current === '') {
+            $result = [];
+        }
+        else {
+            $decodedKey = rawurldecode($key);
+            $result = array_filter(
+                explode('&', $current), function ($part) use ($decodedKey) {
+                    return rawurldecode(explode('=', $part)[0]) !== $decodedKey;
+                }
+            );
+        }
+
+        // Query string separators ("=", "&") within the key or value need to be encoded
+        // (while preventing double-encoding) before setting the query string. All other
+        // chars that need percent-encoding will be encoded by withQuery().
+        $key = strtr($key, self::$replaceQuery);
+
+        if ($value !== null) {
+            $result[] = $key . '=' . strtr($value, self::$replaceQuery);
+        }
+        else {
+            $result[] = $key;
+        }
 
-    if ($value !== NULL) {
-      $result[] = $key . '=' . strtr($value, self::$replaceQuery);
-    }
-    else {
-      $result[] = $key;
+        return $uri->withQuery(implode('&', $result));
     }
 
-    return $uri->withQuery(implode('&', $result));
-  }
-
-  /**
+    /**
    * Creates a URI from a hash of `parse_url` components.
    *
    * @param array $parts
@@ -381,296 +406,317 @@
    *
    * @throws \InvalidArgumentException If the components do not form a valid URI.
    */
-  public static function fromParts(array $parts) {
-    $uri = new self();
-    $uri->applyParts($parts);
-    $uri->validateState();
+    public static function fromParts(array $parts) 
+    {
+        $uri = new self();
+        $uri->applyParts($parts);
+        $uri->validateState();
 
-    return $uri;
-  }
+        return $uri;
+    }
 
-  /**
+    /**
    *
    */
-  public function getScheme() {
-    return $this->scheme;
-  }
+    public function getScheme() 
+    {
+        return $this->scheme;
+    }
 
-  /**
+    /**
    *
    */
-  public function getAuthority() {
-    $authority = $this->host;
-    if ($this->userInfo !== '') {
-      $authority = $this->userInfo . '@' . $authority;
-    }
+    public function getAuthority() 
+    {
+        $authority = $this->host;
+        if ($this->userInfo !== '') {
+            $authority = $this->userInfo . '@' . $authority;
+        }
 
-    if ($this->port !== NULL) {
-      $authority .= ':' . $this->port;
-    }
+        if ($this->port !== null) {
+            $authority .= ':' . $this->port;
+        }
 
-    return $authority;
-  }
+        return $authority;
+    }
 
-  /**
+    /**
    *
    */
-  public function getUserInfo() {
-    return $this->userInfo;
-  }
+    public function getUserInfo() 
+    {
+        return $this->userInfo;
+    }
 
-  /**
+    /**
    *
    */
-  public function getHost() {
-    return $this->host;
-  }
+    public function getHost() 
+    {
+        return $this->host;
+    }
 
-  /**
+    /**
    *
    */
-  public function getPort() {
-    return $this->port;
-  }
+    public function getPort() 
+    {
+        return $this->port;
+    }
 
-  /**
+    /**
    *
    */
-  public function getPath() {
-    return $this->path;
-  }
+    public function getPath() 
+    {
+        return $this->path;
+    }
 
-  /**
+    /**
    *
    */
-  public function getQuery() {
-    return $this->query;
-  }
+    public function getQuery() 
+    {
+        return $this->query;
+    }
 
-  /**
+    /**
    *
    */
-  public function getFragment() {
-    return $this->fragment;
-  }
+    public function getFragment() 
+    {
+        return $this->fragment;
+    }
 
-  /**
+    /**
    *
    */
-  public function withScheme($scheme) {
-    $scheme = $this->filterScheme($scheme);
+    public function withScheme($scheme) 
+    {
+        $scheme = $this->filterScheme($scheme);
 
-    if ($this->scheme === $scheme) {
-      return $this;
-    }
+        if ($this->scheme === $scheme) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->scheme = $scheme;
-    $new->removeDefaultPort();
-    $new->validateState();
+        $new = clone $this;
+        $new->scheme = $scheme;
+        $new->removeDefaultPort();
+        $new->validateState();
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withUserInfo($user, $password = NULL) {
-    $info = $user;
-    if ($password != '') {
-      $info .= ':' . $password;
-    }
+    public function withUserInfo($user, $password = null) 
+    {
+        $info = $user;
+        if ($password != '') {
+            $info .= ':' . $password;
+        }
 
-    if ($this->userInfo === $info) {
-      return $this;
-    }
+        if ($this->userInfo === $info) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->userInfo = $info;
-    $new->validateState();
+        $new = clone $this;
+        $new->userInfo = $info;
+        $new->validateState();
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withHost($host) {
-    $host = $this->filterHost($host);
+    public function withHost($host) 
+    {
+        $host = $this->filterHost($host);
 
-    if ($this->host === $host) {
-      return $this;
-    }
+        if ($this->host === $host) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->host = $host;
-    $new->validateState();
+        $new = clone $this;
+        $new->host = $host;
+        $new->validateState();
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withPort($port) {
-    $port = $this->filterPort($port);
+    public function withPort($port) 
+    {
+        $port = $this->filterPort($port);
 
-    if ($this->port === $port) {
-      return $this;
-    }
+        if ($this->port === $port) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->port = $port;
-    $new->removeDefaultPort();
-    $new->validateState();
+        $new = clone $this;
+        $new->port = $port;
+        $new->removeDefaultPort();
+        $new->validateState();
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withPath($path) {
-    $path = $this->filterPath($path);
+    public function withPath($path) 
+    {
+        $path = $this->filterPath($path);
 
-    if ($this->path === $path) {
-      return $this;
-    }
+        if ($this->path === $path) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->path = $path;
-    $new->validateState();
+        $new = clone $this;
+        $new->path = $path;
+        $new->validateState();
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withQuery($query) {
-    $query = $this->filterQueryAndFragment($query);
+    public function withQuery($query) 
+    {
+        $query = $this->filterQueryAndFragment($query);
 
-    if ($this->query === $query) {
-      return $this;
-    }
+        if ($this->query === $query) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->query = $query;
+        $new = clone $this;
+        $new->query = $query;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    *
    */
-  public function withFragment($fragment) {
-    $fragment = $this->filterQueryAndFragment($fragment);
+    public function withFragment($fragment) 
+    {
+        $fragment = $this->filterQueryAndFragment($fragment);
 
-    if ($this->fragment === $fragment) {
-      return $this;
-    }
+        if ($this->fragment === $fragment) {
+            return $this;
+        }
 
-    $new = clone $this;
-    $new->fragment = $fragment;
+        $new = clone $this;
+        $new->fragment = $fragment;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * Apply parse_url parts to a URI.
    *
    * @param array $parts
    *   Array of parse_url parts to apply.
    */
-  private function applyParts(array $parts) {
-    $this->scheme = isset($parts['scheme'])
+    private function applyParts(array $parts) 
+    {
+        $this->scheme = isset($parts['scheme'])
             ? $this->filterScheme($parts['scheme'])
             : '';
-    $this->userInfo = isset($parts['user']) ? $parts['user'] : '';
-    $this->host = isset($parts['host'])
+        $this->userInfo = isset($parts['user']) ? $parts['user'] : '';
+        $this->host = isset($parts['host'])
             ? $this->filterHost($parts['host'])
             : '';
-    $this->port = isset($parts['port'])
+        $this->port = isset($parts['port'])
             ? $this->filterPort($parts['port'])
-            : NULL;
-    $this->path = isset($parts['path'])
+            : null;
+        $this->path = isset($parts['path'])
             ? $this->filterPath($parts['path'])
             : '';
-    $this->query = isset($parts['query'])
+        $this->query = isset($parts['query'])
             ? $this->filterQueryAndFragment($parts['query'])
             : '';
-    $this->fragment = isset($parts['fragment'])
+        $this->fragment = isset($parts['fragment'])
             ? $this->filterQueryAndFragment($parts['fragment'])
             : '';
-    if (isset($parts['pass'])) {
-      $this->userInfo .= ':' . $parts['pass'];
-    }
+        if (isset($parts['pass'])) {
+            $this->userInfo .= ':' . $parts['pass'];
+        }
 
-    $this->removeDefaultPort();
-  }
+        $this->removeDefaultPort();
+    }
 
-  /**
+    /**
    * @param string $scheme
    *
    * @return string
    *
    * @throws \InvalidArgumentException If the scheme is invalid.
    */
-  private function filterScheme($scheme) {
-    if (!is_string($scheme)) {
-      throw new \InvalidArgumentException('Scheme must be a string');
-    }
+    private function filterScheme($scheme) 
+    {
+        if (!is_string($scheme)) {
+            throw new \InvalidArgumentException('Scheme must be a string');
+        }
 
-    return strtolower($scheme);
-  }
+        return strtolower($scheme);
+    }
 
-  /**
+    /**
    * @param string $host
    *
    * @return string
    *
    * @throws \InvalidArgumentException If the host is invalid.
    */
-  private function filterHost($host) {
-    if (!is_string($host)) {
-      throw new \InvalidArgumentException('Host must be a string');
-    }
+    private function filterHost($host) 
+    {
+        if (!is_string($host)) {
+            throw new \InvalidArgumentException('Host must be a string');
+        }
 
-    return strtolower($host);
-  }
+        return strtolower($host);
+    }
 
-  /**
+    /**
    * @param int|null $port
    *
    * @return int|null
    *
    * @throws \InvalidArgumentException If the port is invalid.
    */
-  private function filterPort($port) {
-    if ($port === NULL) {
-      return NULL;
-    }
+    private function filterPort($port) 
+    {
+        if ($port === null) {
+            return null;
+        }
 
-    $port = (int) $port;
-    if (1 > $port || 0xffff < $port) {
-      throw new \InvalidArgumentException(
-        sprintf('Invalid port: %d. Must be between 1 and 65535', $port)
-      );
-    }
+        $port = (int) $port;
+        if (1 > $port || 0xffff < $port) {
+            throw new \InvalidArgumentException(
+                sprintf('Invalid port: %d. Must be between 1 and 65535', $port)
+            );
+        }
 
-    return $port;
-  }
+        return $port;
+    }
 
-  /**
+    /**
    *
    */
-  private function removeDefaultPort() {
-    if ($this->port !== NULL && self::isDefaultPort($this)) {
-      $this->port = NULL;
+    private function removeDefaultPort() 
+    {
+        if ($this->port !== null && self::isDefaultPort($this)) {
+            $this->port = null;
+        }
     }
-  }
 
-  /**
+    /**
    * Filters the path of a URI.
    *
    * @param string $path
@@ -679,19 +725,20 @@
    *
    * @throws \InvalidArgumentException If the path is invalid.
    */
-  private function filterPath($path) {
-    if (!is_string($path)) {
-      throw new \InvalidArgumentException('Path must be a string');
+    private function filterPath($path) 
+    {
+        if (!is_string($path)) {
+            throw new \InvalidArgumentException('Path must be a string');
+        }
+
+        return preg_replace_callback(
+            '/(?:[^' . self::$charUnreserved . self::$charSubDelims . '%:@\/]++|%(?![A-Fa-f0-9]{2}))/',
+            [$this, 'rawurlencodeMatchZero'],
+            $path
+        );
     }
 
-    return preg_replace_callback(
-        '/(?:[^' . self::$charUnreserved . self::$charSubDelims . '%:@\/]++|%(?![A-Fa-f0-9]{2}))/',
-        [$this, 'rawurlencodeMatchZero'],
-        $path
-    );
-  }
-
-  /**
+    /**
    * Filters the query string or fragment of a URI.
    *
    * @param string $str
@@ -700,50 +747,53 @@
    *
    * @throws \InvalidArgumentException If the query or fragment is invalid.
    */
-  private function filterQueryAndFragment($str) {
-    if (!is_string($str)) {
-      throw new \InvalidArgumentException('Query and fragment must be a string');
+    private function filterQueryAndFragment($str) 
+    {
+        if (!is_string($str)) {
+            throw new \InvalidArgumentException('Query and fragment must be a string');
+        }
+
+        return preg_replace_callback(
+            '/(?:[^' . self::$charUnreserved . self::$charSubDelims . '%:@\/\?]++|%(?![A-Fa-f0-9]{2}))/',
+            [$this, 'rawurlencodeMatchZero'],
+            $str
+        );
     }
 
-    return preg_replace_callback(
-        '/(?:[^' . self::$charUnreserved . self::$charSubDelims . '%:@\/\?]++|%(?![A-Fa-f0-9]{2}))/',
-        [$this, 'rawurlencodeMatchZero'],
-        $str
-    );
-  }
-
-  /**
-   *
-   */
-  private function rawurlencodeMatchZero(array $match) {
-    return rawurlencode($match[0]);
-  }
-
-  /**
+    /**
    *
    */
-  private function validateState() {
-    if ($this->host === '' && ($this->scheme === 'http' || $this->scheme === 'https')) {
-      $this->host = self::HTTP_DEFAULT_HOST;
-    }
-
-    if ($this->getAuthority() === '') {
-      if (0 === strpos($this->path, '//')) {
-        throw new \InvalidArgumentException('The path of a URI without an authority must not start with two slashes "//"');
-      }
-      if ($this->scheme === '' && FALSE !== strpos(explode('/', $this->path, 2)[0], ':')) {
-        throw new \InvalidArgumentException('A relative URI must not have a path beginning with a segment containing a colon');
-      }
-    }
-    elseif (isset($this->path[0]) && $this->path[0] !== '/') {
-      @trigger_error(
-        'The path of a URI with an authority must start with a slash "/" or be empty. Automagically fixing the URI ' .
-        'by adding a leading slash to the path is deprecated since version 1.4 and will throw an exception instead.',
-        E_USER_DEPRECATED
-        );
-      $this->path = '/' . $this->path;
-      // Throw new \InvalidArgumentException('The path of a URI with an authority must start with a slash "/" or be empty');.
+    private function rawurlencodeMatchZero(array $match) 
+    {
+        return rawurlencode($match[0]);
+    }
+
+    /**
+   *
+   */
+    private function validateState() 
+    {
+        if ($this->host === '' && ($this->scheme === 'http' || $this->scheme === 'https')) {
+            $this->host = self::HTTP_DEFAULT_HOST;
+        }
+
+        if ($this->getAuthority() === '') {
+            if (0 === strpos($this->path, '//')) {
+                throw new \InvalidArgumentException('The path of a URI without an authority must not start with two slashes "//"');
+            }
+            if ($this->scheme === '' && false !== strpos(explode('/', $this->path, 2)[0], ':')) {
+                throw new \InvalidArgumentException('A relative URI must not have a path beginning with a segment containing a colon');
+            }
+        }
+        elseif (isset($this->path[0]) && $this->path[0] !== '/') {
+            @trigger_error(
+                'The path of a URI with an authority must start with a slash "/" or be empty. Automagically fixing the URI ' .
+                'by adding a leading slash to the path is deprecated since version 1.4 and will throw an exception instead.',
+                E_USER_DEPRECATED
+            );
+            $this->path = '/' . $this->path;
+            // Throw new \InvalidArgumentException('The path of a URI with an authority must start with a slash "/" or be empty');.
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/StreamDecoratorTrait.php
+++ PHP_CodeSniffer
@@ -9,17 +9,19 @@
  *
  * @property StreamInterface stream
  */
-trait StreamDecoratorTrait {
+trait StreamDecoratorTrait
+{
 
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface $stream
    *   Stream to decorate.
    */
-  public function __construct(StreamInterface $stream) {
-    $this->stream = $stream;
-  }
+    public function __construct(StreamInterface $stream) 
+    {
+        $this->stream = $stream;
+    }
 
-  /**
+    /**
    * Magic method used to create a new stream if streams are not added in
    * the constructor of a decorator (e.g., LazyOpenStream).
    *
@@ -28,157 +30,177 @@
    *
    * @return \Psr\Http\Message\StreamInterface
    */
-  public function __get($name) {
-    if ($name == 'stream') {
-      $this->stream = $this->createStream();
-      return $this->stream;
-    }
+    public function __get($name) 
+    {
+        if ($name == 'stream') {
+            $this->stream = $this->createStream();
+            return $this->stream;
+        }
 
-    throw new \UnexpectedValueException("$name not found on class");
-  }
+        throw new \UnexpectedValueException("$name not found on class");
+    }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    try {
-      if ($this->isSeekable()) {
-        $this->seek(0);
-      }
-      return $this->getContents();
-    }
-    catch (\Exception $e) {
-      // Really, PHP? https://bugs.php.net/bug.php?id=53648
-      trigger_error('StreamDecorator::__toString exception: '
-        . (string) $e, E_USER_ERROR);
-      return '';
+    public function __toString() 
+    {
+        try {
+            if ($this->isSeekable()) {
+                $this->seek(0);
+            }
+            return $this->getContents();
+        }
+        catch (\Exception $e) {
+            // Really, PHP? https://bugs.php.net/bug.php?id=53648
+            trigger_error(
+                'StreamDecorator::__toString exception: '
+                . (string) $e, E_USER_ERROR
+            );
+            return '';
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    return copy_to_string($this);
-  }
+    public function getContents() 
+    {
+        return copy_to_string($this);
+    }
 
-  /**
+    /**
    * Allow decorators to implement custom methods.
    *
    * @param string $method
    *   Missing method name.
-   * @param array $args
+   * @param array  $args
    *   Method arguments.
    *
    * @return mixed
    */
-  public function __call($method, array $args) {
-    $result = call_user_func_array([$this->stream, $method], $args);
+    public function __call($method, array $args) 
+    {
+        $result = call_user_func_array([$this->stream, $method], $args);
 
-    // Always return the wrapped object if the result is a return $this.
-    return $result === $this->stream ? $this : $result;
-  }
+        // Always return the wrapped object if the result is a return $this.
+        return $result === $this->stream ? $this : $result;
+    }
 
-  /**
+    /**
    *
    */
-  public function close() {
-    $this->stream->close();
-  }
+    public function close() 
+    {
+        $this->stream->close();
+    }
 
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    return $this->stream->getMetadata($key);
-  }
+    public function getMetadata($key = null) 
+    {
+        return $this->stream->getMetadata($key);
+    }
 
-  /**
+    /**
    *
    */
-  public function detach() {
-    return $this->stream->detach();
-  }
+    public function detach() 
+    {
+        return $this->stream->detach();
+    }
 
-  /**
+    /**
    *
    */
-  public function getSize() {
-    return $this->stream->getSize();
-  }
+    public function getSize() 
+    {
+        return $this->stream->getSize();
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    return $this->stream->eof();
-  }
+    public function eof() 
+    {
+        return $this->stream->eof();
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    return $this->stream->tell();
-  }
+    public function tell() 
+    {
+        return $this->stream->tell();
+    }
 
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return $this->stream->isReadable();
-  }
+    public function isReadable() 
+    {
+        return $this->stream->isReadable();
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return $this->stream->isWritable();
-  }
+    public function isWritable() 
+    {
+        return $this->stream->isWritable();
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return $this->stream->isSeekable();
-  }
+    public function isSeekable() 
+    {
+        return $this->stream->isSeekable();
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    *
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    $this->stream->seek($offset, $whence);
-  }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        $this->stream->seek($offset, $whence);
+    }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    return $this->stream->read($length);
-  }
+    public function read($length) 
+    {
+        return $this->stream->read($length);
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    return $this->stream->write($string);
-  }
+    public function write($string) 
+    {
+        return $this->stream->write($string);
+    }
 
-  /**
+    /**
    * Implement in subclasses to dynamically create streams when requested.
    *
    * @return \Psr\Http\Message\StreamInterface
    *
    * @throws \BadMethodCallException
    */
-  protected function createStream() {
-    throw new \BadMethodCallException('Not implemented');
-  }
+    protected function createStream() 
+    {
+        throw new \BadMethodCallException('Not implemented');
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/UploadedFile.php
+++ PHP_CodeSniffer
@@ -10,11 +10,12 @@
 /**
  *
  */
-class UploadedFile implements UploadedFileInterface {
-  /**
+class UploadedFile implements UploadedFileInterface
+{
+    /**
    * @var int[]
    */
-  private static $errors = [
+    private static $errors = [
     UPLOAD_ERR_OK,
     UPLOAD_ERR_INI_SIZE,
     UPLOAD_ERR_FORM_SIZE,
@@ -23,218 +24,229 @@
     UPLOAD_ERR_NO_TMP_DIR,
     UPLOAD_ERR_CANT_WRITE,
     UPLOAD_ERR_EXTENSION,
-  ];
+    ];
 
-  /**
+    /**
    * @var string
    */
-  private $clientFilename;
+    private $clientFilename;
 
-  /**
+    /**
    * @var string
    */
-  private $clientMediaType;
+    private $clientMediaType;
 
-  /**
+    /**
    * @var int
    */
-  private $error;
+    private $error;
 
-  /**
+    /**
    * @var null|string
    */
-  private $file;
+    private $file;
 
-  /**
+    /**
    * @var bool
    */
-  private $moved = FALSE;
+    private $moved = false;
 
-  /**
+    /**
    * @var int
    */
-  private $size;
+    private $size;
 
-  /**
+    /**
    * @var \Psr\Http\Message\StreamInterface|null
    */
-  private $stream;
+    private $stream;
 
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface|string|resource $streamOrFile
-   * @param int $size
-   * @param int $errorStatus
-   * @param string|null $clientFilename
-   * @param string|null $clientMediaType
+   * @param int                                               $size
+   * @param int                                               $errorStatus
+   * @param string|null                                       $clientFilename
+   * @param string|null                                       $clientMediaType
    */
-  public function __construct(
+    public function __construct(
         $streamOrFile,
         $size,
         $errorStatus,
-        $clientFilename = NULL,
-        $clientMediaType = NULL
+        $clientFilename = null,
+        $clientMediaType = null
     ) {
-    $this->setError($errorStatus);
-    $this->setSize($size);
-    $this->setClientFilename($clientFilename);
-    $this->setClientMediaType($clientMediaType);
+        $this->setError($errorStatus);
+        $this->setSize($size);
+        $this->setClientFilename($clientFilename);
+        $this->setClientMediaType($clientMediaType);
 
-    if ($this->isOk()) {
-      $this->setStreamOrFile($streamOrFile);
+        if ($this->isOk()) {
+            $this->setStreamOrFile($streamOrFile);
+        }
     }
-  }
 
-  /**
+    /**
    * Depending on the value set file or stream variable.
    *
    * @param mixed $streamOrFile
    *
    * @throws InvalidArgumentException
    */
-  private function setStreamOrFile($streamOrFile) {
-    if (is_string($streamOrFile)) {
-      $this->file = $streamOrFile;
-    }
-    elseif (is_resource($streamOrFile)) {
-      $this->stream = new Stream($streamOrFile);
+    private function setStreamOrFile($streamOrFile) 
+    {
+        if (is_string($streamOrFile)) {
+            $this->file = $streamOrFile;
+        }
+        elseif (is_resource($streamOrFile)) {
+            $this->stream = new Stream($streamOrFile);
+        }
+        elseif ($streamOrFile instanceof StreamInterface) {
+            $this->stream = $streamOrFile;
+        }
+        else {
+            throw new InvalidArgumentException(
+                'Invalid stream or file provided for UploadedFile'
+            );
+        }
     }
-    elseif ($streamOrFile instanceof StreamInterface) {
-      $this->stream = $streamOrFile;
-    }
-    else {
-      throw new InvalidArgumentException(
-        'Invalid stream or file provided for UploadedFile'
-        );
-    }
-  }
 
-  /**
+    /**
    * @param int $error
    * @throws InvalidArgumentException
    */
-  private function setError($error) {
-    if (FALSE === is_int($error)) {
-      throw new InvalidArgumentException(
-        'Upload file error status must be an integer'
-      );
-    }
+    private function setError($error) 
+    {
+        if (false === is_int($error)) {
+            throw new InvalidArgumentException(
+                'Upload file error status must be an integer'
+            );
+        }
+
+        if (false === in_array($error, UploadedFile::$errors)) {
+            throw new InvalidArgumentException(
+                'Invalid error status for UploadedFile'
+            );
+        }
 
-    if (FALSE === in_array($error, UploadedFile::$errors)) {
-      throw new InvalidArgumentException(
-        'Invalid error status for UploadedFile'
-      );
+        $this->error = $error;
     }
 
-    $this->error = $error;
-  }
-
-  /**
+    /**
    * @param int $size
    * @throws InvalidArgumentException
    */
-  private function setSize($size) {
-    if (FALSE === is_int($size)) {
-      throw new InvalidArgumentException(
-        'Upload file size must be an integer'
-      );
-    }
+    private function setSize($size) 
+    {
+        if (false === is_int($size)) {
+            throw new InvalidArgumentException(
+                'Upload file size must be an integer'
+            );
+        }
 
-    $this->size = $size;
-  }
+        $this->size = $size;
+    }
 
-  /**
+    /**
    * @param mixed $param
    * @return bool
    */
-  private function isStringOrNull($param) {
-    return in_array(gettype($param), ['string', 'NULL']);
-  }
+    private function isStringOrNull($param) 
+    {
+        return in_array(gettype($param), ['string', 'NULL']);
+    }
 
-  /**
+    /**
    * @param mixed $param
    * @return bool
    */
-  private function isStringNotEmpty($param) {
-    return is_string($param) && FALSE === empty($param);
-  }
+    private function isStringNotEmpty($param) 
+    {
+        return is_string($param) && false === empty($param);
+    }
 
-  /**
+    /**
    * @param string|null $clientFilename
    * @throws InvalidArgumentException
    */
-  private function setClientFilename($clientFilename) {
-    if (FALSE === $this->isStringOrNull($clientFilename)) {
-      throw new InvalidArgumentException(
-        'Upload file client filename must be a string or null'
-      );
-    }
+    private function setClientFilename($clientFilename) 
+    {
+        if (false === $this->isStringOrNull($clientFilename)) {
+            throw new InvalidArgumentException(
+                'Upload file client filename must be a string or null'
+            );
+        }
 
-    $this->clientFilename = $clientFilename;
-  }
+        $this->clientFilename = $clientFilename;
+    }
 
-  /**
+    /**
    * @param string|null $clientMediaType
    * @throws InvalidArgumentException
    */
-  private function setClientMediaType($clientMediaType) {
-    if (FALSE === $this->isStringOrNull($clientMediaType)) {
-      throw new InvalidArgumentException(
-        'Upload file client media type must be a string or null'
-      );
-    }
+    private function setClientMediaType($clientMediaType) 
+    {
+        if (false === $this->isStringOrNull($clientMediaType)) {
+            throw new InvalidArgumentException(
+                'Upload file client media type must be a string or null'
+            );
+        }
 
-    $this->clientMediaType = $clientMediaType;
-  }
+        $this->clientMediaType = $clientMediaType;
+    }
 
-  /**
+    /**
    * Return true if there is no upload error.
    *
    * @return bool
    */
-  private function isOk() {
-    return $this->error === UPLOAD_ERR_OK;
-  }
+    private function isOk() 
+    {
+        return $this->error === UPLOAD_ERR_OK;
+    }
 
-  /**
+    /**
    * @return bool
    */
-  public function isMoved() {
-    return $this->moved;
-  }
+    public function isMoved() 
+    {
+        return $this->moved;
+    }
 
-  /**
+    /**
    * @throws RuntimeException if is moved or not ok
    */
-  private function validateActive() {
-    if (FALSE === $this->isOk()) {
-      throw new RuntimeException('Cannot retrieve stream due to upload error');
-    }
-
-    if ($this->isMoved()) {
-      throw new RuntimeException('Cannot retrieve stream after it has already been moved');
+    private function validateActive() 
+    {
+        if (false === $this->isOk()) {
+            throw new RuntimeException('Cannot retrieve stream due to upload error');
+        }
+
+        if ($this->isMoved()) {
+            throw new RuntimeException('Cannot retrieve stream after it has already been moved');
+        }
     }
-  }
 
-  /**
+    /**
    * {@inheritdoc}
    *
    * @throws RuntimeException if the upload was not successful.
    */
-  public function getStream() {
-    $this->validateActive();
+    public function getStream() 
+    {
+        $this->validateActive();
 
-    if ($this->stream instanceof StreamInterface) {
-      return $this->stream;
-    }
+        if ($this->stream instanceof StreamInterface) {
+            return $this->stream;
+        }
 
-    return new LazyOpenStream($this->file, 'r+');
-  }
+        return new LazyOpenStream($this->file, 'r+');
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    *
-   * @see http://php.net/is_uploaded_file
-   * @see http://php.net/move_uploaded_file
+   * @see   http://php.net/is_uploaded_file
+   * @see   http://php.net/move_uploaded_file
    * @param string $targetPath
    *   Path to which to move the uploaded file.
    *
@@ -243,71 +255,76 @@
    * @throws RuntimeException on any error during the move operation, or on
    *     the second or subsequent call to the method.
    */
-  public function moveTo($targetPath) {
-    $this->validateActive();
-
-    if (FALSE === $this->isStringNotEmpty($targetPath)) {
-      throw new InvalidArgumentException(
-        'Invalid path provided for move operation; must be a non-empty string'
-      );
-    }
+    public function moveTo($targetPath) 
+    {
+        $this->validateActive();
+
+        if (false === $this->isStringNotEmpty($targetPath)) {
+            throw new InvalidArgumentException(
+                'Invalid path provided for move operation; must be a non-empty string'
+            );
+        }
 
-    if ($this->file) {
-      $this->moved = php_sapi_name() == 'cli'
+        if ($this->file) {
+            $this->moved = php_sapi_name() == 'cli'
                 ? rename($this->file, $targetPath)
                 : move_uploaded_file($this->file, $targetPath);
+        }
+        else {
+            copy_to_stream(
+                $this->getStream(),
+                new LazyOpenStream($targetPath, 'w')
+            );
+
+            $this->moved = true;
+        }
+
+        if (false === $this->moved) {
+            throw new RuntimeException(
+                sprintf('Uploaded file could not be moved to %s', $targetPath)
+            );
+        }
     }
-    else {
-      copy_to_stream(
-        $this->getStream(),
-        new LazyOpenStream($targetPath, 'w')
-        );
 
-      $this->moved = TRUE;
-    }
-
-    if (FALSE === $this->moved) {
-      throw new RuntimeException(
-        sprintf('Uploaded file could not be moved to %s', $targetPath)
-      );
-    }
-  }
-
-  /**
+    /**
    * {@inheritdoc}
    *
    * @return int|null The file size in bytes or null if unknown.
    */
-  public function getSize() {
-    return $this->size;
-  }
+    public function getSize() 
+    {
+        return $this->size;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    *
    * @see http://php.net/manual/en/features.file-upload.errors.php
    *
    * @return int One of PHP's UPLOAD_ERR_XXX constants.
    */
-  public function getError() {
-    return $this->error;
-  }
+    public function getError() 
+    {
+        return $this->error;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    *
    * @return string|null The filename sent by the client or null if none
    *   was provided.
    */
-  public function getClientFilename() {
-    return $this->clientFilename;
-  }
+    public function getClientFilename() 
+    {
+        return $this->clientFilename;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getClientMediaType() {
-    return $this->clientMediaType;
-  }
+    public function getClientMediaType() 
+    {
+        return $this->clientMediaType;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/AppendStream.php
+++ PHP_CodeSniffer
@@ -9,41 +9,45 @@
  *
  * This is a read-only stream decorator.
  */
-class AppendStream implements StreamInterface {
-  /**
-   * @var \Psr\Http\Message\StreamInterface[]Streamsbeingdecorated*/
-  private $streams = [];
-
-  private $seekable = TRUE;
-  private $current = 0;
-  private $pos = 0;
-  private $detached = FALSE;
+class AppendStream implements StreamInterface
+{
+    /**
+   * @var \Psr\Http\Message\StreamInterface[]Streamsbeingdecorated
+*/
+    private $streams = [];
+
+    private $seekable = true;
+    private $current = 0;
+    private $pos = 0;
+    private $detached = false;
 
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface[] $streams
    *   Streams to decorate. Each stream must
    *   be readable.
    */
-  public function __construct(array $streams = []) {
-    foreach ($streams as $stream) {
-      $this->addStream($stream);
+    public function __construct(array $streams = []) 
+    {
+        foreach ($streams as $stream) {
+            $this->addStream($stream);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    try {
-      $this->rewind();
-      return $this->getContents();
-    }
-    catch (\Exception $e) {
-      return '';
+    public function __toString() 
+    {
+        try {
+            $this->rewind();
+            return $this->getContents();
+        }
+        catch (\Exception $e) {
+            return '';
+        }
     }
-  }
 
-  /**
+    /**
    * Add a stream to the AppendStream.
    *
    * @param \Psr\Http\Message\StreamInterface $stream
@@ -51,59 +55,64 @@
    *
    * @throws \InvalidArgumentException if the stream is not readable
    */
-  public function addStream(StreamInterface $stream) {
-    if (!$stream->isReadable()) {
-      throw new \InvalidArgumentException('Each stream must be readable');
-    }
+    public function addStream(StreamInterface $stream) 
+    {
+        if (!$stream->isReadable()) {
+            throw new \InvalidArgumentException('Each stream must be readable');
+        }
 
-    // The stream is only seekable if all streams are seekable.
-    if (!$stream->isSeekable()) {
-      $this->seekable = FALSE;
-    }
+        // The stream is only seekable if all streams are seekable.
+        if (!$stream->isSeekable()) {
+            $this->seekable = false;
+        }
 
-    $this->streams[] = $stream;
-  }
+        $this->streams[] = $stream;
+    }
 
-  /**
+    /**
    *
    */
-  public function getContents() {
-    return copy_to_string($this);
-  }
+    public function getContents() 
+    {
+        return copy_to_string($this);
+    }
 
-  /**
+    /**
    * Closes each attached stream.
    *
    * {@inheritdoc}
    */
-  public function close() {
-    $this->pos = $this->current = 0;
+    public function close() 
+    {
+        $this->pos = $this->current = 0;
 
-    foreach ($this->streams as $stream) {
-      $stream->close();
-    }
+        foreach ($this->streams as $stream) {
+            $stream->close();
+        }
 
-    $this->streams = [];
-  }
+        $this->streams = [];
+    }
 
-  /**
+    /**
    * Detaches each attached stream.
    *
    * {@inheritdoc}
    */
-  public function detach() {
-    $this->close();
-    $this->detached = TRUE;
-  }
+    public function detach() 
+    {
+        $this->close();
+        $this->detached = true;
+    }
 
-  /**
+    /**
    *
    */
-  public function tell() {
-    return $this->pos;
-  }
+    public function tell() 
+    {
+        return $this->pos;
+    }
 
-  /**
+    /**
    * Tries to calculate the size by adding the size of each stream.
    *
    * If any of the streams do not return a valid number, then the size of the
@@ -111,143 +120,155 @@
    *
    * {@inheritdoc}
    */
-  public function getSize() {
-    $size = 0;
+    public function getSize() 
+    {
+        $size = 0;
+
+        foreach ($this->streams as $stream) {
+            $s = $stream->getSize();
+            if ($s === null) {
+                return null;
+            }
+            $size += $s;
+        }
 
-    foreach ($this->streams as $stream) {
-      $s = $stream->getSize();
-      if ($s === NULL) {
-        return NULL;
-      }
-      $size += $s;
+        return $size;
     }
 
-    return $size;
-  }
-
-  /**
+    /**
    *
    */
-  public function eof() {
-    return !$this->streams ||
+    public function eof() 
+    {
+        return !$this->streams ||
             ($this->current >= count($this->streams) - 1 &&
          $this->streams[$this->current]->eof());
-  }
+    }
 
-  /**
+    /**
    *
    */
-  public function rewind() {
-    $this->seek(0);
-  }
+    public function rewind() 
+    {
+        $this->seek(0);
+    }
 
-  /**
+    /**
    * Attempts to seek to the given position. Only supports SEEK_SET.
    *
    * {@inheritdoc}
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    if (!$this->seekable) {
-      throw new \RuntimeException('This AppendStream is not seekable');
-    }
-    elseif ($whence !== SEEK_SET) {
-      throw new \RuntimeException('The AppendStream can only seek with SEEK_SET');
-    }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        if (!$this->seekable) {
+            throw new \RuntimeException('This AppendStream is not seekable');
+        }
+        elseif ($whence !== SEEK_SET) {
+            throw new \RuntimeException('The AppendStream can only seek with SEEK_SET');
+        }
 
-    $this->pos = $this->current = 0;
+        $this->pos = $this->current = 0;
 
-    // Rewind each stream.
-    foreach ($this->streams as $i => $stream) {
-      try {
-        $stream->rewind();
-      }
-      catch (\Exception $e) {
-        throw new \RuntimeException('Unable to seek stream '
-        . $i . ' of the AppendStream', 0, $e);
-      }
-    }
+        // Rewind each stream.
+        foreach ($this->streams as $i => $stream) {
+            try {
+                $stream->rewind();
+            }
+            catch (\Exception $e) {
+                throw new \RuntimeException(
+                    'Unable to seek stream '
+                    . $i . ' of the AppendStream', 0, $e
+                );
+            }
+        }
 
-    // Seek to the actual position by reading from each stream.
-    while ($this->pos < $offset && !$this->eof()) {
-      $result = $this->read(min(8096, $offset - $this->pos));
-      if ($result === '') {
-        break;
-      }
+        // Seek to the actual position by reading from each stream.
+        while ($this->pos < $offset && !$this->eof()) {
+            $result = $this->read(min(8096, $offset - $this->pos));
+            if ($result === '') {
+                break;
+            }
+        }
     }
-  }
 
-  /**
+    /**
    * Reads from all of the appended streams until the length is met or EOF.
    *
    * {@inheritdoc}
    */
-  public function read($length) {
-    $buffer = '';
-    $total = count($this->streams) - 1;
-    $remaining = $length;
-    $progressToNext = FALSE;
-
-    while ($remaining > 0) {
+    public function read($length) 
+    {
+        $buffer = '';
+        $total = count($this->streams) - 1;
+        $remaining = $length;
+        $progressToNext = false;
+
+        while ($remaining > 0) {
+
+            // Progress to the next stream if needed.
+            if ($progressToNext || $this->streams[$this->current]->eof()) {
+                $progressToNext = false;
+                if ($this->current === $total) {
+                    break;
+                }
+                $this->current++;
+            }
+
+            $result = $this->streams[$this->current]->read($remaining);
+
+            // Using a loose comparison here to match on '', false, and null.
+            if ($result == null) {
+                $progressToNext = true;
+                continue;
+            }
 
-      // Progress to the next stream if needed.
-      if ($progressToNext || $this->streams[$this->current]->eof()) {
-        $progressToNext = FALSE;
-        if ($this->current === $total) {
-          break;
+            $buffer .= $result;
+            $remaining = $length - strlen($buffer);
         }
-        $this->current++;
-      }
 
-      $result = $this->streams[$this->current]->read($remaining);
+        $this->pos += strlen($buffer);
 
-      // Using a loose comparison here to match on '', false, and null.
-      if ($result == NULL) {
-        $progressToNext = TRUE;
-        continue;
-      }
-
-      $buffer .= $result;
-      $remaining = $length - strlen($buffer);
+        return $buffer;
     }
 
-    $this->pos += strlen($buffer);
-
-    return $buffer;
-  }
-
-  /**
+    /**
    *
    */
-  public function isReadable() {
-    return TRUE;
-  }
+    public function isReadable() 
+    {
+        return true;
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return FALSE;
-  }
+    public function isWritable() 
+    {
+        return false;
+    }
 
-  /**
+    /**
    *
    */
-  public function isSeekable() {
-    return $this->seekable;
-  }
+    public function isSeekable() 
+    {
+        return $this->seekable;
+    }
 
-  /**
+    /**
    *
    */
-  public function write($string) {
-    throw new \RuntimeException('Cannot write to an AppendStream');
-  }
+    public function write($string) 
+    {
+        throw new \RuntimeException('Cannot write to an AppendStream');
+    }
 
-  /**
+    /**
    *
    */
-  public function getMetadata($key = NULL) {
-    return $key ? NULL : [];
-  }
+    public function getMetadata($key = null) 
+    {
+        return $key ? null : [];
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/UriResolver.php
+++ PHP_CodeSniffer
@@ -11,9 +11,10 @@
  *
  * @link https://tools.ietf.org/html/rfc3986#section-5
  */
-final class UriResolver {
+final class UriResolver
+{
 
-  /**
+    /**
    * Removes dot segments from a path and returns the new path.
    *
    * @param string $path
@@ -22,38 +23,39 @@
    *
    * @link http://tools.ietf.org/html/rfc3986#section-5.2.4
    */
-  public static function removeDotSegments($path) {
-    if ($path === '' || $path === '/') {
-      return $path;
-    }
+    public static function removeDotSegments($path) 
+    {
+        if ($path === '' || $path === '/') {
+            return $path;
+        }
 
-    $results = [];
-    $segments = explode('/', $path);
-    foreach ($segments as $segment) {
-      if ($segment === '..') {
-        array_pop($results);
-      }
-      elseif ($segment !== '.') {
-        $results[] = $segment;
-      }
-    }
+        $results = [];
+        $segments = explode('/', $path);
+        foreach ($segments as $segment) {
+            if ($segment === '..') {
+                array_pop($results);
+            }
+            elseif ($segment !== '.') {
+                $results[] = $segment;
+            }
+        }
 
-    $newPath = implode('/', $results);
+        $newPath = implode('/', $results);
 
-    if ($path[0] === '/' && (!isset($newPath[0]) || $newPath[0] !== '/')) {
-      // Re-add the leading slash if necessary for cases like "/..".
-      $newPath = '/' . $newPath;
-    }
-    elseif ($newPath !== '' && ($segment === '.' || $segment === '..')) {
-      // Add the trailing slash if necessary
-      // If newPath is not empty, then $segment must be set and is the last segment from the foreach.
-      $newPath .= '/';
-    }
+        if ($path[0] === '/' && (!isset($newPath[0]) || $newPath[0] !== '/')) {
+            // Re-add the leading slash if necessary for cases like "/..".
+            $newPath = '/' . $newPath;
+        }
+        elseif ($newPath !== '' && ($segment === '.' || $segment === '..')) {
+            // Add the trailing slash if necessary
+            // If newPath is not empty, then $segment must be set and is the last segment from the foreach.
+            $newPath .= '/';
+        }
 
-    return $newPath;
-  }
+        return $newPath;
+    }
 
-  /**
+    /**
    * Converts the relative URI into a new URI that is resolved against the base URI.
    *
    * @param \Psr\Http\Message\UriInterface $base
@@ -65,60 +67,63 @@
    *
    * @link http://tools.ietf.org/html/rfc3986#section-5.2
    */
-  public static function resolve(UriInterface $base, UriInterface $rel) {
-    if ((string) $rel === '') {
-      // We can simply return the same base URI instance for this same-document reference.
-      return $base;
-    }
+    public static function resolve(UriInterface $base, UriInterface $rel) 
+    {
+        if ((string) $rel === '') {
+            // We can simply return the same base URI instance for this same-document reference.
+            return $base;
+        }
 
-    if ($rel->getScheme() != '') {
-      return $rel->withPath(self::removeDotSegments($rel->getPath()));
-    }
+        if ($rel->getScheme() != '') {
+            return $rel->withPath(self::removeDotSegments($rel->getPath()));
+        }
 
-    if ($rel->getAuthority() != '') {
-      $targetAuthority = $rel->getAuthority();
-      $targetPath = self::removeDotSegments($rel->getPath());
-      $targetQuery = $rel->getQuery();
-    }
-    else {
-      $targetAuthority = $base->getAuthority();
-      if ($rel->getPath() === '') {
-        $targetPath = $base->getPath();
-        $targetQuery = $rel->getQuery() != '' ? $rel->getQuery() : $base->getQuery();
-      }
-      else {
-        if ($rel->getPath()[0] === '/') {
-          $targetPath = $rel->getPath();
+        if ($rel->getAuthority() != '') {
+            $targetAuthority = $rel->getAuthority();
+            $targetPath = self::removeDotSegments($rel->getPath());
+            $targetQuery = $rel->getQuery();
         }
         else {
-          if ($targetAuthority != '' && $base->getPath() === '') {
-            $targetPath = '/' . $rel->getPath();
-          }
-          else {
-            $lastSlashPos = strrpos($base->getPath(), '/');
-            if ($lastSlashPos === FALSE) {
-              $targetPath = $rel->getPath();
+            $targetAuthority = $base->getAuthority();
+            if ($rel->getPath() === '') {
+                $targetPath = $base->getPath();
+                $targetQuery = $rel->getQuery() != '' ? $rel->getQuery() : $base->getQuery();
             }
             else {
-              $targetPath = substr($base->getPath(), 0, $lastSlashPos + 1) . $rel->getPath();
+                if ($rel->getPath()[0] === '/') {
+                    $targetPath = $rel->getPath();
+                }
+                else {
+                    if ($targetAuthority != '' && $base->getPath() === '') {
+                        $targetPath = '/' . $rel->getPath();
+                    }
+                    else {
+                        $lastSlashPos = strrpos($base->getPath(), '/');
+                        if ($lastSlashPos === false) {
+                            $targetPath = $rel->getPath();
+                        }
+                        else {
+                            $targetPath = substr($base->getPath(), 0, $lastSlashPos + 1) . $rel->getPath();
+                        }
+                    }
+                }
+                $targetPath = self::removeDotSegments($targetPath);
+                $targetQuery = $rel->getQuery();
             }
-          }
         }
-        $targetPath = self::removeDotSegments($targetPath);
-        $targetQuery = $rel->getQuery();
-      }
-    }
 
-    return new Uri(Uri::composeComponents(
-        $base->getScheme(),
-        $targetAuthority,
-        $targetPath,
-        $targetQuery,
-        $rel->getFragment()
-    ));
-  }
+        return new Uri(
+            Uri::composeComponents(
+                $base->getScheme(),
+                $targetAuthority,
+                $targetPath,
+                $targetQuery,
+                $rel->getFragment()
+            )
+        );
+    }
 
-  /**
+    /**
    * Returns the target URI as a relative reference from the base URI.
    *
    * This method is the counterpart to resolve():
@@ -146,93 +151,96 @@
    *
    * @return \Psr\Http\Message\UriInterface The relative URI reference
    */
-  public static function relativize(UriInterface $base, UriInterface $target) {
-    if ($target->getScheme() !== '' &&
-        ($base->getScheme() !== $target->getScheme() || $target->getAuthority() === '' && $base->getAuthority() !== '')
-    ) {
-      return $target;
-    }
+    public static function relativize(UriInterface $base, UriInterface $target) 
+    {
+        if ($target->getScheme() !== '' 
+            && ($base->getScheme() !== $target->getScheme() || $target->getAuthority() === '' && $base->getAuthority() !== '')
+        ) {
+            return $target;
+        }
 
-    if (Uri::isRelativePathReference($target)) {
-      // As the target is already highly relative we return it as-is. It would be possible to resolve
-      // the target with `$target = self::resolve($base, $target);` and then try make it more relative
-      // by removing a duplicate query. But let's not do that automatically.
-      return $target;
-    }
+        if (Uri::isRelativePathReference($target)) {
+            // As the target is already highly relative we return it as-is. It would be possible to resolve
+            // the target with `$target = self::resolve($base, $target);` and then try make it more relative
+            // by removing a duplicate query. But let's not do that automatically.
+            return $target;
+        }
 
-    if ($target->getAuthority() !== '' && $base->getAuthority() !== $target->getAuthority()) {
-      return $target->withScheme('');
-    }
+        if ($target->getAuthority() !== '' && $base->getAuthority() !== $target->getAuthority()) {
+            return $target->withScheme('');
+        }
 
-    // We must remove the path before removing the authority because if the path starts with two slashes, the URI
-    // would turn invalid. And we also cannot set a relative path before removing the authority, as that is also
-    // invalid.
-    $emptyPathUri = $target->withScheme('')->withPath('')->withUserInfo('')->withPort(NULL)->withHost('');
+        // We must remove the path before removing the authority because if the path starts with two slashes, the URI
+        // would turn invalid. And we also cannot set a relative path before removing the authority, as that is also
+        // invalid.
+        $emptyPathUri = $target->withScheme('')->withPath('')->withUserInfo('')->withPort(null)->withHost('');
 
-    if ($base->getPath() !== $target->getPath()) {
-      return $emptyPathUri->withPath(self::getRelativePath($base, $target));
-    }
+        if ($base->getPath() !== $target->getPath()) {
+            return $emptyPathUri->withPath(self::getRelativePath($base, $target));
+        }
 
-    if ($base->getQuery() === $target->getQuery()) {
-      // Only the target fragment is left. And it must be returned even if base and target fragment are the same.
-      return $emptyPathUri->withQuery('');
-    }
+        if ($base->getQuery() === $target->getQuery()) {
+            // Only the target fragment is left. And it must be returned even if base and target fragment are the same.
+            return $emptyPathUri->withQuery('');
+        }
 
-    // If the base URI has a query but the target has none, we cannot return an empty path reference as it would
-    // inherit the base query component when resolving.
-    if ($target->getQuery() === '') {
-      $segments = explode('/', $target->getPath());
-      $lastSegment = end($segments);
+        // If the base URI has a query but the target has none, we cannot return an empty path reference as it would
+        // inherit the base query component when resolving.
+        if ($target->getQuery() === '') {
+            $segments = explode('/', $target->getPath());
+            $lastSegment = end($segments);
 
-      return $emptyPathUri->withPath($lastSegment === '' ? './' : $lastSegment);
-    }
+            return $emptyPathUri->withPath($lastSegment === '' ? './' : $lastSegment);
+        }
 
-    return $emptyPathUri;
-  }
+        return $emptyPathUri;
+    }
 
-  /**
+    /**
    *
    */
-  private static function getRelativePath(UriInterface $base, UriInterface $target) {
-    $sourceSegments = explode('/', $base->getPath());
-    $targetSegments = explode('/', $target->getPath());
-    array_pop($sourceSegments);
-    $targetLastSegment = array_pop($targetSegments);
-    foreach ($sourceSegments as $i => $segment) {
-      if (isset($targetSegments[$i]) && $segment === $targetSegments[$i]) {
-        unset($sourceSegments[$i], $targetSegments[$i]);
-      }
-      else {
-        break;
-      }
-    }
-    $targetSegments[] = $targetLastSegment;
-    $relativePath = str_repeat('../', count($sourceSegments)) . implode('/', $targetSegments);
+    private static function getRelativePath(UriInterface $base, UriInterface $target) 
+    {
+        $sourceSegments = explode('/', $base->getPath());
+        $targetSegments = explode('/', $target->getPath());
+        array_pop($sourceSegments);
+        $targetLastSegment = array_pop($targetSegments);
+        foreach ($sourceSegments as $i => $segment) {
+            if (isset($targetSegments[$i]) && $segment === $targetSegments[$i]) {
+                unset($sourceSegments[$i], $targetSegments[$i]);
+            }
+            else {
+                break;
+            }
+        }
+        $targetSegments[] = $targetLastSegment;
+        $relativePath = str_repeat('../', count($sourceSegments)) . implode('/', $targetSegments);
 
-    // A reference to am empty last segment or an empty first sub-segment must be prefixed with "./".
-    // This also applies to a segment with a colon character (e.g., "file:colon") that cannot be used
-    // as the first segment of a relative-path reference, as it would be mistaken for a scheme name.
-    if ('' === $relativePath || FALSE !== strpos(explode('/', $relativePath, 2)[0], ':')) {
-      $relativePath = "./$relativePath";
-    }
-    elseif ('/' === $relativePath[0]) {
-      if ($base->getAuthority() != '' && $base->getPath() === '') {
-        // In this case an extra slash is added by resolve() automatically. So we must not add one here.
-        $relativePath = ".$relativePath";
-      }
-      else {
-        $relativePath = "./$relativePath";
-      }
-    }
+        // A reference to am empty last segment or an empty first sub-segment must be prefixed with "./".
+        // This also applies to a segment with a colon character (e.g., "file:colon") that cannot be used
+        // as the first segment of a relative-path reference, as it would be mistaken for a scheme name.
+        if ('' === $relativePath || false !== strpos(explode('/', $relativePath, 2)[0], ':')) {
+            $relativePath = "./$relativePath";
+        }
+        elseif ('/' === $relativePath[0]) {
+            if ($base->getAuthority() != '' && $base->getPath() === '') {
+                // In this case an extra slash is added by resolve() automatically. So we must not add one here.
+                $relativePath = ".$relativePath";
+            }
+            else {
+                $relativePath = "./$relativePath";
+            }
+        }
 
-    return $relativePath;
-  }
+        return $relativePath;
+    }
 
-  /**
+    /**
    *
    */
-  private function __construct() {
-    // Cannot be instantiated.
-  }
+    private function __construct() 
+    {
+        // Cannot be instantiated.
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/LimitStream.php
+++ PHP_CodeSniffer
@@ -7,103 +7,112 @@
 /**
  * Decorator used to return only a subset of a stream.
  */
-class LimitStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class LimitStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
+
+    /**
+   * @var intOffsettostartreadingfrom
+*/
+    private $offset;
+
+    /**
+   * @var intLimitthenumberofbytesthatcanberead
+*/
+    private $limit;
 
-  /**
-   * @var intOffsettostartreadingfrom*/
-  private $offset;
-
-  /**
-   * @var intLimitthenumberofbytesthatcanberead*/
-  private $limit;
-
-  /**
+    /**
    * @param \Psr\Http\Message\StreamInterface $stream
    *   Stream to wrap.
-   * @param int $limit
+   * @param int                               $limit
    *   Total number of bytes to allow to be read
    *   from the stream. Pass -1 for no limit.
-   * @param int $offset
+   * @param int                               $offset
    *   Position to seek to before reading (only
    *   works on seekable streams).
    */
-  public function __construct(
+    public function __construct(
         StreamInterface $stream,
         $limit = -1,
         $offset = 0
     ) {
-    $this->stream = $stream;
-    $this->setLimit($limit);
-    $this->setOffset($offset);
-  }
+        $this->stream = $stream;
+        $this->setLimit($limit);
+        $this->setOffset($offset);
+    }
 
-  /**
+    /**
    *
    */
-  public function eof() {
-    // Always return true if the underlying stream is EOF.
-    if ($this->stream->eof()) {
-      return TRUE;
-    }
+    public function eof() 
+    {
+        // Always return true if the underlying stream is EOF.
+        if ($this->stream->eof()) {
+            return true;
+        }
+
+        // No limit and the underlying stream is not at EOF.
+        if ($this->limit == -1) {
+            return false;
+        }
 
-    // No limit and the underlying stream is not at EOF.
-    if ($this->limit == -1) {
-      return FALSE;
+        return $this->stream->tell() >= $this->offset + $this->limit;
     }
 
-    return $this->stream->tell() >= $this->offset + $this->limit;
-  }
-
-  /**
+    /**
    * Returns the size of the limited subset of data
    * {@inheritdoc}.
    */
-  public function getSize() {
-    if (NULL === ($length = $this->stream->getSize())) {
-      return NULL;
-    }
-    elseif ($this->limit == -1) {
-      return $length - $this->offset;
+    public function getSize() 
+    {
+        if (null === ($length = $this->stream->getSize())) {
+            return null;
+        }
+        elseif ($this->limit == -1) {
+            return $length - $this->offset;
+        }
+        else {
+            return min($this->limit, $length - $this->offset);
+        }
     }
-    else {
-      return min($this->limit, $length - $this->offset);
-    }
-  }
 
-  /**
+    /**
    * Allow for a bounded seek on the read limited stream
    * {@inheritdoc}.
    */
-  public function seek($offset, $whence = SEEK_SET) {
-    if ($whence !== SEEK_SET || $offset < 0) {
-      throw new \RuntimeException(sprintf(
-        'Cannot seek to offset % with whence %s',
-        $offset,
-        $whence
-      ));
-    }
+    public function seek($offset, $whence = SEEK_SET) 
+    {
+        if ($whence !== SEEK_SET || $offset < 0) {
+            throw new \RuntimeException(
+                sprintf(
+                    'Cannot seek to offset % with whence %s',
+                    $offset,
+                    $whence
+                )
+            );
+        }
+
+        $offset += $this->offset;
+
+        if ($this->limit !== -1) {
+            if ($offset > $this->offset + $this->limit) {
+                $offset = $this->offset + $this->limit;
+            }
+        }
 
-    $offset += $this->offset;
-
-    if ($this->limit !== -1) {
-      if ($offset > $this->offset + $this->limit) {
-        $offset = $this->offset + $this->limit;
-      }
+        $this->stream->seek($offset);
     }
 
-    $this->stream->seek($offset);
-  }
-
-  /**
+    /**
    * Give a relative tell()
    * {@inheritdoc}.
    */
-  public function tell() {
-    return $this->stream->tell() - $this->offset;
-  }
+    public function tell() 
+    {
+        return $this->stream->tell() - $this->offset;
+    }
 
-  /**
+    /**
    * Set the offset to start limiting from.
    *
    * @param int $offset
@@ -111,26 +120,27 @@
    *
    * @throws \RuntimeException if the stream cannot be seeked.
    */
-  public function setOffset($offset) {
-    $current = $this->stream->tell();
+    public function setOffset($offset) 
+    {
+        $current = $this->stream->tell();
+
+        if ($current !== $offset) {
+            // If the stream cannot seek to the offset position, then read to it.
+            if ($this->stream->isSeekable()) {
+                $this->stream->seek($offset);
+            }
+            elseif ($current > $offset) {
+                throw new \RuntimeException("Could not seek to stream offset $offset");
+            }
+            else {
+                $this->stream->read($offset - $current);
+            }
+        }
 
-    if ($current !== $offset) {
-      // If the stream cannot seek to the offset position, then read to it.
-      if ($this->stream->isSeekable()) {
-        $this->stream->seek($offset);
-      }
-      elseif ($current > $offset) {
-        throw new \RuntimeException("Could not seek to stream offset $offset");
-      }
-      else {
-        $this->stream->read($offset - $current);
-      }
+        $this->offset = $offset;
     }
 
-    $this->offset = $offset;
-  }
-
-  /**
+    /**
    * Set the limit of bytes that the decorator allows to be read from the
    * stream.
    *
@@ -138,28 +148,30 @@
    *   Number of bytes to allow to be read from the stream.
    *   Use -1 for no limit.
    */
-  public function setLimit($limit) {
-    $this->limit = $limit;
-  }
+    public function setLimit($limit) 
+    {
+        $this->limit = $limit;
+    }
 
-  /**
+    /**
    *
    */
-  public function read($length) {
-    if ($this->limit == -1) {
-      return $this->stream->read($length);
-    }
-
-    // Check if the current position is less than the total allowed
-    // bytes + original offset.
-    $remaining = ($this->offset + $this->limit) - $this->stream->tell();
-    if ($remaining > 0) {
-      // Only return the amount of requested data, ensuring that the byte
-      // limit is not exceeded.
-      return $this->stream->read(min($remaining, $length));
-    }
+    public function read($length) 
+    {
+        if ($this->limit == -1) {
+            return $this->stream->read($length);
+        }
+
+        // Check if the current position is less than the total allowed
+        // bytes + original offset.
+        $remaining = ($this->offset + $this->limit) - $this->stream->tell();
+        if ($remaining > 0) {
+            // Only return the amount of requested data, ensuring that the byte
+            // limit is not exceeded.
+            return $this->stream->read(min($remaining, $length));
+        }
 
-    return '';
-  }
+        return '';
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/ServerRequest.php
+++ PHP_CodeSniffer
@@ -20,65 +20,66 @@
  * implemented such that they retain the internal state of the current
  * message and return a new instance that contains the changed state.
  */
-class ServerRequest extends Request implements ServerRequestInterface {
-  /**
+class ServerRequest extends Request implements ServerRequestInterface
+{
+    /**
    * @var array
    */
-  private $attributes = [];
+    private $attributes = [];
 
-  /**
+    /**
    * @var array
    */
-  private $cookieParams = [];
+    private $cookieParams = [];
 
-  /**
+    /**
    * @var null|array|object
    */
-  private $parsedBody;
+    private $parsedBody;
 
-  /**
+    /**
    * @var array
    */
-  private $queryParams = [];
+    private $queryParams = [];
 
-  /**
+    /**
    * @var array
    */
-  private $serverParams;
+    private $serverParams;
 
-  /**
+    /**
    * @var array
    */
-  private $uploadedFiles = [];
+    private $uploadedFiles = [];
 
-  /**
-   * @param string $method
+    /**
+   * @param string                               $method
    *   HTTP method.
-   * @param string|UriInterface $uri
+   * @param string|UriInterface                  $uri
    *   URI.
-   * @param array $headers
+   * @param array                                $headers
    *   Request headers.
    * @param string|null|resource|StreamInterface $body
    *   Request body.
-   * @param string $version
+   * @param string                               $version
    *   Protocol version.
-   * @param array $serverParams
+   * @param array                                $serverParams
    *   Typically the $_SERVER superglobal.
    */
-  public function __construct(
+    public function __construct(
         $method,
         $uri,
         array $headers = [],
-        $body = NULL,
+        $body = null,
         $version = '1.1',
         array $serverParams = []
     ) {
-    $this->serverParams = $serverParams;
+        $this->serverParams = $serverParams;
 
-    parent::__construct($method, $uri, $headers, $body, $version);
-  }
+        parent::__construct($method, $uri, $headers, $body, $version);
+    }
 
-  /**
+    /**
    * Return an UploadedFile instance array.
    *
    * @param array $files
@@ -88,29 +89,30 @@
    *
    * @return array
    */
-  public static function normalizeFiles(array $files) {
-    $normalized = [];
+    public static function normalizeFiles(array $files) 
+    {
+        $normalized = [];
+
+        foreach ($files as $key => $value) {
+            if ($value instanceof UploadedFileInterface) {
+                $normalized[$key] = $value;
+            }
+            elseif (is_array($value) && isset($value['tmp_name'])) {
+                $normalized[$key] = self::createUploadedFileFromSpec($value);
+            }
+            elseif (is_array($value)) {
+                $normalized[$key] = self::normalizeFiles($value);
+                continue;
+            }
+            else {
+                throw new InvalidArgumentException('Invalid value in files specification');
+            }
+        }
 
-    foreach ($files as $key => $value) {
-      if ($value instanceof UploadedFileInterface) {
-        $normalized[$key] = $value;
-      }
-      elseif (is_array($value) && isset($value['tmp_name'])) {
-        $normalized[$key] = self::createUploadedFileFromSpec($value);
-      }
-      elseif (is_array($value)) {
-        $normalized[$key] = self::normalizeFiles($value);
-        continue;
-      }
-      else {
-        throw new InvalidArgumentException('Invalid value in files specification');
-      }
+        return $normalized;
     }
 
-    return $normalized;
-  }
-
-  /**
+    /**
    * Create and return an UploadedFile instance from a $_FILES specification.
    *
    * If the specification represents an array of values, this method will
@@ -121,21 +123,22 @@
    *
    * @return array|UploadedFileInterface
    */
-  private static function createUploadedFileFromSpec(array $value) {
-    if (is_array($value['tmp_name'])) {
-      return self::normalizeNestedFileSpec($value);
+    private static function createUploadedFileFromSpec(array $value) 
+    {
+        if (is_array($value['tmp_name'])) {
+            return self::normalizeNestedFileSpec($value);
+        }
+
+        return new UploadedFile(
+            $value['tmp_name'],
+            (int) $value['size'],
+            (int) $value['error'],
+            $value['name'],
+            $value['type']
+        );
     }
 
-    return new UploadedFile(
-        $value['tmp_name'],
-        (int) $value['size'],
-        (int) $value['error'],
-        $value['name'],
-        $value['type']
-    );
-  }
-
-  /**
+    /**
    * Normalize an array of file specifications.
    *
    * Loops through all nested files and returns a normalized array of
@@ -145,24 +148,25 @@
    *
    * @return \Psr\Http\Message\UploadedFileInterface[]
    */
-  private static function normalizeNestedFileSpec(array $files = []) {
-    $normalizedFiles = [];
+    private static function normalizeNestedFileSpec(array $files = []) 
+    {
+        $normalizedFiles = [];
+
+        foreach (array_keys($files['tmp_name']) as $key) {
+            $spec = [
+            'tmp_name' => $files['tmp_name'][$key],
+            'size'     => $files['size'][$key],
+            'error'    => $files['error'][$key],
+            'name'     => $files['name'][$key],
+            'type'     => $files['type'][$key],
+            ];
+            $normalizedFiles[$key] = self::createUploadedFileFromSpec($spec);
+        }
 
-    foreach (array_keys($files['tmp_name']) as $key) {
-      $spec = [
-        'tmp_name' => $files['tmp_name'][$key],
-        'size'     => $files['size'][$key],
-        'error'    => $files['error'][$key],
-        'name'     => $files['name'][$key],
-        'type'     => $files['type'][$key],
-      ];
-      $normalizedFiles[$key] = self::createUploadedFileFromSpec($spec);
+        return $normalizedFiles;
     }
 
-    return $normalizedFiles;
-  }
-
-  /**
+    /**
    * Return a ServerRequest populated with superglobals:
    * $_GET
    * $_POST
@@ -172,184 +176,199 @@
    *
    * @return \Psr\Http\Message\ServerRequestInterface
    */
-  public static function fromGlobals() {
-    $method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET';
-    $headers = function_exists('getallheaders') ? getallheaders() : [];
-    $uri = self::getUriFromGlobals();
-    $body = new LazyOpenStream('php://input', 'r+');
-    $protocol = isset($_SERVER['SERVER_PROTOCOL']) ? str_replace('HTTP/', '', $_SERVER['SERVER_PROTOCOL']) : '1.1';
-
-    $serverRequest = new ServerRequest($method, $uri, $headers, $body, $protocol, $_SERVER);
-
-    return $serverRequest
-      ->withCookieParams($_COOKIE)
-      ->withQueryParams($_GET)
-      ->withParsedBody($_POST)
-      ->withUploadedFiles(self::normalizeFiles($_FILES));
-  }
+    public static function fromGlobals() 
+    {
+        $method = isset($_SERVER['REQUEST_METHOD']) ? $_SERVER['REQUEST_METHOD'] : 'GET';
+        $headers = function_exists('getallheaders') ? getallheaders() : [];
+        $uri = self::getUriFromGlobals();
+        $body = new LazyOpenStream('php://input', 'r+');
+        $protocol = isset($_SERVER['SERVER_PROTOCOL']) ? str_replace('HTTP/', '', $_SERVER['SERVER_PROTOCOL']) : '1.1';
+
+        $serverRequest = new ServerRequest($method, $uri, $headers, $body, $protocol, $_SERVER);
+
+        return $serverRequest
+            ->withCookieParams($_COOKIE)
+            ->withQueryParams($_GET)
+            ->withParsedBody($_POST)
+            ->withUploadedFiles(self::normalizeFiles($_FILES));
+    }
 
-  /**
+    /**
    * Get a Uri populated with values from $_SERVER.
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  public static function getUriFromGlobals() {
-    $uri = new Uri('');
+    public static function getUriFromGlobals() 
+    {
+        $uri = new Uri('');
 
-    $uri = $uri->withScheme(!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' ? 'https' : 'http');
+        $uri = $uri->withScheme(!empty($_SERVER['HTTPS']) && $_SERVER['HTTPS'] !== 'off' ? 'https' : 'http');
 
-    $hasPort = FALSE;
-    if (isset($_SERVER['HTTP_HOST'])) {
-      $hostHeaderParts = explode(':', $_SERVER['HTTP_HOST']);
-      $uri = $uri->withHost($hostHeaderParts[0]);
-      if (isset($hostHeaderParts[1])) {
-        $hasPort = TRUE;
-        $uri = $uri->withPort($hostHeaderParts[1]);
-      }
-    }
-    elseif (isset($_SERVER['SERVER_NAME'])) {
-      $uri = $uri->withHost($_SERVER['SERVER_NAME']);
-    }
-    elseif (isset($_SERVER['SERVER_ADDR'])) {
-      $uri = $uri->withHost($_SERVER['SERVER_ADDR']);
-    }
+        $hasPort = false;
+        if (isset($_SERVER['HTTP_HOST'])) {
+            $hostHeaderParts = explode(':', $_SERVER['HTTP_HOST']);
+            $uri = $uri->withHost($hostHeaderParts[0]);
+            if (isset($hostHeaderParts[1])) {
+                $hasPort = true;
+                $uri = $uri->withPort($hostHeaderParts[1]);
+            }
+        }
+        elseif (isset($_SERVER['SERVER_NAME'])) {
+            $uri = $uri->withHost($_SERVER['SERVER_NAME']);
+        }
+        elseif (isset($_SERVER['SERVER_ADDR'])) {
+            $uri = $uri->withHost($_SERVER['SERVER_ADDR']);
+        }
 
-    if (!$hasPort && isset($_SERVER['SERVER_PORT'])) {
-      $uri = $uri->withPort($_SERVER['SERVER_PORT']);
-    }
+        if (!$hasPort && isset($_SERVER['SERVER_PORT'])) {
+            $uri = $uri->withPort($_SERVER['SERVER_PORT']);
+        }
 
-    $hasQuery = FALSE;
-    if (isset($_SERVER['REQUEST_URI'])) {
-      $requestUriParts = explode('?', $_SERVER['REQUEST_URI']);
-      $uri = $uri->withPath($requestUriParts[0]);
-      if (isset($requestUriParts[1])) {
-        $hasQuery = TRUE;
-        $uri = $uri->withQuery($requestUriParts[1]);
-      }
-    }
+        $hasQuery = false;
+        if (isset($_SERVER['REQUEST_URI'])) {
+            $requestUriParts = explode('?', $_SERVER['REQUEST_URI']);
+            $uri = $uri->withPath($requestUriParts[0]);
+            if (isset($requestUriParts[1])) {
+                $hasQuery = true;
+                $uri = $uri->withQuery($requestUriParts[1]);
+            }
+        }
 
-    if (!$hasQuery && isset($_SERVER['QUERY_STRING'])) {
-      $uri = $uri->withQuery($_SERVER['QUERY_STRING']);
-    }
+        if (!$hasQuery && isset($_SERVER['QUERY_STRING'])) {
+            $uri = $uri->withQuery($_SERVER['QUERY_STRING']);
+        }
 
-    return $uri;
-  }
+        return $uri;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getServerParams() {
-    return $this->serverParams;
-  }
+    public function getServerParams() 
+    {
+        return $this->serverParams;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getUploadedFiles() {
-    return $this->uploadedFiles;
-  }
+    public function getUploadedFiles() 
+    {
+        return $this->uploadedFiles;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withUploadedFiles(array $uploadedFiles) {
-    $new = clone $this;
-    $new->uploadedFiles = $uploadedFiles;
+    public function withUploadedFiles(array $uploadedFiles) 
+    {
+        $new = clone $this;
+        $new->uploadedFiles = $uploadedFiles;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getCookieParams() {
-    return $this->cookieParams;
-  }
+    public function getCookieParams() 
+    {
+        return $this->cookieParams;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withCookieParams(array $cookies) {
-    $new = clone $this;
-    $new->cookieParams = $cookies;
+    public function withCookieParams(array $cookies) 
+    {
+        $new = clone $this;
+        $new->cookieParams = $cookies;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getQueryParams() {
-    return $this->queryParams;
-  }
+    public function getQueryParams() 
+    {
+        return $this->queryParams;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withQueryParams(array $query) {
-    $new = clone $this;
-    $new->queryParams = $query;
+    public function withQueryParams(array $query) 
+    {
+        $new = clone $this;
+        $new->queryParams = $query;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getParsedBody() {
-    return $this->parsedBody;
-  }
+    public function getParsedBody() 
+    {
+        return $this->parsedBody;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withParsedBody($data) {
-    $new = clone $this;
-    $new->parsedBody = $data;
+    public function withParsedBody($data) 
+    {
+        $new = clone $this;
+        $new->parsedBody = $data;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getAttributes() {
-    return $this->attributes;
-  }
+    public function getAttributes() 
+    {
+        return $this->attributes;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function getAttribute($attribute, $default = NULL) {
-    if (FALSE === array_key_exists($attribute, $this->attributes)) {
-      return $default;
-    }
+    public function getAttribute($attribute, $default = null) 
+    {
+        if (false === array_key_exists($attribute, $this->attributes)) {
+            return $default;
+        }
 
-    return $this->attributes[$attribute];
-  }
+        return $this->attributes[$attribute];
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withAttribute($attribute, $value) {
-    $new = clone $this;
-    $new->attributes[$attribute] = $value;
+    public function withAttribute($attribute, $value) 
+    {
+        $new = clone $this;
+        $new->attributes[$attribute] = $value;
 
-    return $new;
-  }
+        return $new;
+    }
 
-  /**
+    /**
    * {@inheritdoc}
    */
-  public function withoutAttribute($attribute) {
-    if (FALSE === array_key_exists($attribute, $this->attributes)) {
-      return $this;
-    }
+    public function withoutAttribute($attribute) 
+    {
+        if (false === array_key_exists($attribute, $this->attributes)) {
+            return $this;
+        }
 
-    $new = clone $this;
-    unset($new->attributes[$attribute]);
+        $new = clone $this;
+        unset($new->attributes[$attribute]);
 
-    return $new;
-  }
+        return $new;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/psr7/src/MultipartStream.php
+++ PHP_CodeSniffer
@@ -8,13 +8,14 @@
  * Stream that when read returns bytes for a streaming multipart or
  * multipart/form-data stream.
  */
-class MultipartStream implements StreamInterface {
-  use StreamDecoratorTrait;
+class MultipartStream implements StreamInterface
+{
+    use StreamDecoratorTrait;
 
-  private $boundary;
+    private $boundary;
 
-  /**
-   * @param array $elements
+    /**
+   * @param array  $elements
    *   Array of associative arrays, each containing a
    *   required "name" key mapping to the form field,
    *                        name, a required "contents" key mapping to a
@@ -27,131 +28,141 @@
    *
    * @throws \InvalidArgumentException
    */
-  public function __construct(array $elements = [], $boundary = NULL) {
-    $this->boundary = $boundary ?: sha1(uniqid('', TRUE));
-    $this->stream = $this->createStream($elements);
-  }
+    public function __construct(array $elements = [], $boundary = null) 
+    {
+        $this->boundary = $boundary ?: sha1(uniqid('', true));
+        $this->stream = $this->createStream($elements);
+    }
 
-  /**
+    /**
    * Get the boundary.
    *
    * @return string
    */
-  public function getBoundary() {
-    return $this->boundary;
-  }
+    public function getBoundary() 
+    {
+        return $this->boundary;
+    }
 
-  /**
+    /**
    *
    */
-  public function isWritable() {
-    return FALSE;
-  }
+    public function isWritable() 
+    {
+        return false;
+    }
 
-  /**
+    /**
    * Get the headers needed before transferring the content of a POST file.
    */
-  private function getHeaders(array $headers) {
-    $str = '';
-    foreach ($headers as $key => $value) {
-      $str .= "{$key}: {$value}\r\n";
-    }
+    private function getHeaders(array $headers) 
+    {
+        $str = '';
+        foreach ($headers as $key => $value) {
+            $str .= "{$key}: {$value}\r\n";
+        }
 
-    return "--{$this->boundary}\r\n" . trim($str) . "\r\n\r\n";
-  }
+        return "--{$this->boundary}\r\n" . trim($str) . "\r\n\r\n";
+    }
 
-  /**
+    /**
    * Create the aggregate stream that will be used to upload the POST data.
    */
-  protected function createStream(array $elements) {
-    $stream = new AppendStream();
+    protected function createStream(array $elements) 
+    {
+        $stream = new AppendStream();
 
-    foreach ($elements as $element) {
-      $this->addElement($stream, $element);
-    }
+        foreach ($elements as $element) {
+            $this->addElement($stream, $element);
+        }
 
-    // Add the trailing boundary with CRLF.
-    $stream->addStream(stream_for("--{$this->boundary}--\r\n"));
+        // Add the trailing boundary with CRLF.
+        $stream->addStream(stream_for("--{$this->boundary}--\r\n"));
 
-    return $stream;
-  }
+        return $stream;
+    }
 
-  /**
+    /**
    *
    */
-  private function addElement(AppendStream $stream, array $element) {
-    foreach (['contents', 'name'] as $key) {
-      if (!array_key_exists($key, $element)) {
-        throw new \InvalidArgumentException("A '{$key}' key is required");
-      }
-    }
-
-    $element['contents'] = stream_for($element['contents']);
-
-    if (empty($element['filename'])) {
-      $uri = $element['contents']->getMetadata('uri');
-      if (substr($uri, 0, 6) !== 'php://') {
-        $element['filename'] = $uri;
-      }
-    }
-
-    list($body, $headers) = $this->createElement(
-        $element['name'],
-        $element['contents'],
-        isset($element['filename']) ? $element['filename'] : NULL,
-        isset($element['headers']) ? $element['headers'] : []
-    );
-
-    $stream->addStream(stream_for($this->getHeaders($headers)));
-    $stream->addStream($body);
-    $stream->addStream(stream_for("\r\n"));
-  }
+    private function addElement(AppendStream $stream, array $element) 
+    {
+        foreach (['contents', 'name'] as $key) {
+            if (!array_key_exists($key, $element)) {
+                throw new \InvalidArgumentException("A '{$key}' key is required");
+            }
+        }
+
+        $element['contents'] = stream_for($element['contents']);
+
+        if (empty($element['filename'])) {
+            $uri = $element['contents']->getMetadata('uri');
+            if (substr($uri, 0, 6) !== 'php://') {
+                $element['filename'] = $uri;
+            }
+        }
+
+        list($body, $headers) = $this->createElement(
+            $element['name'],
+            $element['contents'],
+            isset($element['filename']) ? $element['filename'] : null,
+            isset($element['headers']) ? $element['headers'] : []
+        );
+
+        $stream->addStream(stream_for($this->getHeaders($headers)));
+        $stream->addStream($body);
+        $stream->addStream(stream_for("\r\n"));
+    }
 
-  /**
+    /**
    * @return array
    */
-  private function createElement($name, StreamInterface $stream, $filename, array $headers) {
-    // Set a default content-disposition header if one was no provided.
-    $disposition = $this->getHeader($headers, 'content-disposition');
-    if (!$disposition) {
-      $headers['Content-Disposition'] = ($filename === '0' || $filename)
-                ? sprintf('form-data; name="%s"; filename="%s"',
-            $name,
-            basename($filename))
+    private function createElement($name, StreamInterface $stream, $filename, array $headers) 
+    {
+        // Set a default content-disposition header if one was no provided.
+        $disposition = $this->getHeader($headers, 'content-disposition');
+        if (!$disposition) {
+            $headers['Content-Disposition'] = ($filename === '0' || $filename)
+                ? sprintf(
+                    'form-data; name="%s"; filename="%s"',
+                    $name,
+                    basename($filename)
+                )
                 : "form-data; name=\"{$name}\"";
-    }
+        }
 
-    // Set a default content-length header if one was no provided.
-    $length = $this->getHeader($headers, 'content-length');
-    if (!$length) {
-      if ($length = $stream->getSize()) {
-        $headers['Content-Length'] = (string) $length;
-      }
-    }
-
-    // Set a default Content-Type if one was not supplied.
-    $type = $this->getHeader($headers, 'content-type');
-    if (!$type && ($filename === '0' || $filename)) {
-      if ($type = mimetype_from_filename($filename)) {
-        $headers['Content-Type'] = $type;
-      }
-    }
+        // Set a default content-length header if one was no provided.
+        $length = $this->getHeader($headers, 'content-length');
+        if (!$length) {
+            if ($length = $stream->getSize()) {
+                $headers['Content-Length'] = (string) $length;
+            }
+        }
+
+        // Set a default Content-Type if one was not supplied.
+        $type = $this->getHeader($headers, 'content-type');
+        if (!$type && ($filename === '0' || $filename)) {
+            if ($type = mimetype_from_filename($filename)) {
+                $headers['Content-Type'] = $type;
+            }
+        }
 
-    return [$stream, $headers];
-  }
+        return [$stream, $headers];
+    }
 
-  /**
+    /**
    *
    */
-  private function getHeader(array $headers, $key) {
-    $lowercaseHeader = strtolower($key);
-    foreach ($headers as $k => $v) {
-      if (strtolower($k) === $lowercaseHeader) {
-        return $v;
-      }
-    }
+    private function getHeader(array $headers, $key) 
+    {
+        $lowercaseHeader = strtolower($key);
+        foreach ($headers as $k => $v) {
+            if (strtolower($k) === $lowercaseHeader) {
+                return $v;
+            }
+        }
 
-    return NULL;
-  }
+        return null;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/functions.php
+++ PHP_CodeSniffer
@@ -16,24 +16,25 @@
  *
  * @param string $template
  *   URI template.
- * @param array $variables
+ * @param array  $variables
  *   Template variables.
  *
  * @return string
  */
-function uri_template($template, array $variables) {
-  if (extension_loaded('uri_template')) {
-    // @codeCoverageIgnoreStart
-    return \uri_template($template, $variables);
-    // @codeCoverageIgnoreEnd
-  }
-
-  static $uriTemplate;
-  if (!$uriTemplate) {
-    $uriTemplate = new UriTemplate();
-  }
+function uri_template($template, array $variables) 
+{
+    if (extension_loaded('uri_template')) {
+        // @codeCoverageIgnoreStart
+        return \uri_template($template, $variables);
+        // @codeCoverageIgnoreEnd
+    }
+
+    static $uriTemplate;
+    if (!$uriTemplate) {
+        $uriTemplate = new UriTemplate();
+    }
 
-  return $uriTemplate->expand($template, $variables);
+    return $uriTemplate->expand($template, $variables);
 }
 
 /**
@@ -44,20 +45,21 @@
  * @return string Returns a string containing the type of the variable and
  *   if a class is provided, the class name.
  */
-function describe_type($input) {
-  switch (gettype($input)) {
+function describe_type($input) 
+{
+    switch (gettype($input)) {
     case 'object':
-      return 'object(' . get_class($input) . ')';
+        return 'object(' . get_class($input) . ')';
 
     case 'array':
-      return 'array(' . count($input) . ')';
+        return 'array(' . count($input) . ')';
 
     default:
-      ob_start();
-      var_dump($input);
-      // Normalize float vs double.
-      return str_replace('double(', 'float(', rtrim(ob_get_clean()));
-  }
+        ob_start();
+        var_dump($input);
+        // Normalize float vs double.
+        return str_replace('double(', 'float(', rtrim(ob_get_clean()));
+    }
 }
 
 /**
@@ -69,17 +71,18 @@
  *
  * @return array
  */
-function headers_from_lines($lines) {
-  $headers = [];
-
-  foreach ($lines as $line) {
-    $parts = explode(':', $line, 2);
-    $headers[trim($parts[0])][] = isset($parts[1])
+function headers_from_lines($lines) 
+{
+    $headers = [];
+
+    foreach ($lines as $line) {
+        $parts = explode(':', $line, 2);
+        $headers[trim($parts[0])][] = isset($parts[1])
             ? trim($parts[1])
-            : NULL;
-  }
+            : null;
+    }
 
-  return $headers;
+    return $headers;
 }
 
 /**
@@ -90,15 +93,16 @@
  *
  * @return resource
  */
-function debug_resource($value = NULL) {
-  if (is_resource($value)) {
-    return $value;
-  }
-  elseif (defined('STDOUT')) {
-    return STDOUT;
-  }
+function debug_resource($value = null) 
+{
+    if (is_resource($value)) {
+        return $value;
+    }
+    elseif (defined('STDOUT')) {
+        return STDOUT;
+    }
 
-  return fopen('php://output', 'w');
+    return fopen('php://output', 'w');
 }
 
 /**
@@ -110,29 +114,32 @@
  *
  * @return callable Returns the best handler for the given system.
  */
-function choose_handler() {
-  $handler = NULL;
-  if (function_exists('curl_multi_exec') && function_exists('curl_exec')) {
-    $handler = Proxy::wrapSync(new CurlMultiHandler(), new CurlHandler());
-  }
-  elseif (function_exists('curl_exec')) {
-    $handler = new CurlHandler();
-  }
-  elseif (function_exists('curl_multi_exec')) {
-    $handler = new CurlMultiHandler();
-  }
+function choose_handler() 
+{
+    $handler = null;
+    if (function_exists('curl_multi_exec') && function_exists('curl_exec')) {
+        $handler = Proxy::wrapSync(new CurlMultiHandler(), new CurlHandler());
+    }
+    elseif (function_exists('curl_exec')) {
+        $handler = new CurlHandler();
+    }
+    elseif (function_exists('curl_multi_exec')) {
+        $handler = new CurlMultiHandler();
+    }
 
-  if (ini_get('allow_url_fopen')) {
-    $handler = $handler
+    if (ini_get('allow_url_fopen')) {
+        $handler = $handler
             ? Proxy::wrapStreaming($handler, new StreamHandler())
             : new StreamHandler();
-  }
-  elseif (!$handler) {
-    throw new \RuntimeException('GuzzleHttp requires cURL, the '
-        . 'allow_url_fopen ini setting, or a custom HTTP handler.');
-  }
+    }
+    elseif (!$handler) {
+        throw new \RuntimeException(
+            'GuzzleHttp requires cURL, the '
+            . 'allow_url_fopen ini setting, or a custom HTTP handler.'
+        );
+    }
 
-  return $handler;
+    return $handler;
 }
 
 /**
@@ -140,18 +147,19 @@
  *
  * @return string
  */
-function default_user_agent() {
-  static $defaultAgent = '';
-
-  if (!$defaultAgent) {
-    $defaultAgent = 'GuzzleHttp/' . Client::VERSION;
-    if (extension_loaded('curl') && function_exists('curl_version')) {
-      $defaultAgent .= ' curl/' . \curl_version()['version'];
+function default_user_agent() 
+{
+    static $defaultAgent = '';
+
+    if (!$defaultAgent) {
+        $defaultAgent = 'GuzzleHttp/' . Client::VERSION;
+        if (extension_loaded('curl') && function_exists('curl_version')) {
+            $defaultAgent .= ' curl/' . \curl_version()['version'];
+        }
+        $defaultAgent .= ' PHP/' . PHP_VERSION;
     }
-    $defaultAgent .= ' PHP/' . PHP_VERSION;
-  }
 
-  return $defaultAgent;
+    return $defaultAgent;
 }
 
 /**
@@ -169,9 +177,10 @@
  *
  * @throws \RuntimeException if no bundle can be found.
  */
-function default_ca_bundle() {
-  static $cached = NULL;
-  static $cafiles = [
+function default_ca_bundle() 
+{
+    static $cached = null;
+    static $cafiles = [
         // Red Hat, CentOS, Fedora (provided by the ca-certificates package)
     '/etc/pki/tls/certs/ca-bundle.crt',
         // Ubuntu, Debian (provided by the ca-certificates package)
@@ -187,27 +196,28 @@
         // Windows?
     'C:\\windows\\system32\\curl-ca-bundle.crt',
     'C:\\windows\\curl-ca-bundle.crt',
-  ];
+    ];
 
-  if ($cached) {
-    return $cached;
-  }
+    if ($cached) {
+        return $cached;
+    }
 
-  if ($ca = ini_get('openssl.cafile')) {
-    return $cached = $ca;
-  }
+    if ($ca = ini_get('openssl.cafile')) {
+        return $cached = $ca;
+    }
 
-  if ($ca = ini_get('curl.cainfo')) {
-    return $cached = $ca;
-  }
+    if ($ca = ini_get('curl.cainfo')) {
+        return $cached = $ca;
+    }
 
-  foreach ($cafiles as $filename) {
-    if (file_exists($filename)) {
-      return $cached = $filename;
+    foreach ($cafiles as $filename) {
+        if (file_exists($filename)) {
+            return $cached = $filename;
+        }
     }
-  }
 
-  throw new \RuntimeException(<<< EOT
+    throw new \RuntimeException(
+        <<< EOT
 No system CA bundle could be found in any of the the common system locations.
 PHP versions earlier than 5.6 are not properly configured to use the system's
 CA bundle by default. In order to verify peer certificates, you will need to
@@ -232,13 +242,14 @@
  *
  * @return array
  */
-function normalize_header_keys(array $headers) {
-  $result = [];
-  foreach (array_keys($headers) as $key) {
-    $result[strtolower($key)] = $key;
-  }
+function normalize_header_keys(array $headers) 
+{
+    $result = [];
+    foreach (array_keys($headers) as $key) {
+        $result[strtolower($key)] = $key;
+    }
 
-  return $result;
+    return $result;
 }
 
 /**
@@ -257,45 +268,46 @@
  *
  * @param string $host
  *   Host to check against the patterns.
- * @param array $noProxyArray
+ * @param array  $noProxyArray
  *   An array of host patterns.
  *
  * @return bool
  */
-function is_host_in_noproxy($host, array $noProxyArray) {
-  if (strlen($host) === 0) {
-    throw new \InvalidArgumentException('Empty host provided');
-  }
-
-  // Strip port if present.
-  if (strpos($host, ':')) {
-    $host = explode($host, ':', 2)[0];
-  }
-
-  foreach ($noProxyArray as $area) {
-    // Always match on wildcards.
-    if ($area === '*') {
-      return TRUE;
-    }
-    elseif (empty($area)) {
-      // Don't match on empty values.
-      continue;
-    }
-    elseif ($area === $host) {
-      // Exact matches.
-      return TRUE;
-    }
-    else {
-      // Special match if the area when prefixed with ".". Remove any
-      // existing leading "." and add a new leading ".".
-      $area = '.' . ltrim($area, '.');
-      if (substr($host, -(strlen($area))) === $area) {
-        return TRUE;
-      }
+function is_host_in_noproxy($host, array $noProxyArray) 
+{
+    if (strlen($host) === 0) {
+        throw new \InvalidArgumentException('Empty host provided');
     }
-  }
 
-  return FALSE;
+    // Strip port if present.
+    if (strpos($host, ':')) {
+        $host = explode($host, ':', 2)[0];
+    }
+
+    foreach ($noProxyArray as $area) {
+        // Always match on wildcards.
+        if ($area === '*') {
+            return true;
+        }
+        elseif (empty($area)) {
+            // Don't match on empty values.
+            continue;
+        }
+        elseif ($area === $host) {
+            // Exact matches.
+            return true;
+        }
+        else {
+            // Special match if the area when prefixed with ".". Remove any
+            // existing leading "." and add a new leading ".".
+            $area = '.' . ltrim($area, '.');
+            if (substr($host, -(strlen($area))) === $area) {
+                return true;
+            }
+        }
+    }
+
+    return false;
 }
 
 /**
@@ -303,12 +315,12 @@
  *
  * @param string $json
  *   JSON data to parse.
- * @param bool $assoc
+ * @param bool   $assoc
  *   When true, returned objects will be converted
  *   into associative arrays.
- * @param int $depth
+ * @param int    $depth
  *   User specified recursion depth.
- * @param int $options
+ * @param int    $options
  *   Bitmask of JSON decode options.
  *
  * @return mixed
@@ -317,14 +329,16 @@
  *
  * @link http://www.php.net/manual/en/function.json-decode.php
  */
-function json_decode($json, $assoc = FALSE, $depth = 512, $options = 0) {
-  $data = \json_decode($json, $assoc, $depth, $options);
-  if (JSON_ERROR_NONE !== json_last_error()) {
-    throw new \InvalidArgumentException(
-        'json_decode error: ' . json_last_error_msg());
-  }
+function json_decode($json, $assoc = false, $depth = 512, $options = 0) 
+{
+    $data = \json_decode($json, $assoc, $depth, $options);
+    if (JSON_ERROR_NONE !== json_last_error()) {
+        throw new \InvalidArgumentException(
+            'json_decode error: ' . json_last_error_msg()
+        );
+    }
 
-  return $data;
+    return $data;
 }
 
 /**
@@ -332,9 +346,9 @@
  *
  * @param mixed $value
  *   The value being encoded.
- * @param int $options
+ * @param int   $options
  *   JSON encode option bitmask.
- * @param int $depth
+ * @param int   $depth
  *   Set the maximum depth. Must be greater than zero.
  *
  * @return string
@@ -343,12 +357,14 @@
  *
  * @link http://www.php.net/manual/en/function.json-encode.php
  */
-function json_encode($value, $options = 0, $depth = 512) {
-  $json = \json_encode($value, $options, $depth);
-  if (JSON_ERROR_NONE !== json_last_error()) {
-    throw new \InvalidArgumentException(
-        'json_encode error: ' . json_last_error_msg());
-  }
+function json_encode($value, $options = 0, $depth = 512) 
+{
+    $json = \json_encode($value, $options, $depth);
+    if (JSON_ERROR_NONE !== json_last_error()) {
+        throw new \InvalidArgumentException(
+            'json_encode error: ' . json_last_error_msg()
+        );
+    }
 
-  return $json;
+    return $json;
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/EasyHandle.php
+++ PHP_CodeSniffer
@@ -9,92 +9,103 @@
  *
  * @internal
  */
-final class EasyHandle {
-  /**
-   * @var resourcecURLresource*/
-  public $handle;
-
-  /**
-   * @var \Psr\Http\Message\StreamInterfaceWheredataisbeingwritten*/
-  public $sink;
-
-  /**
-   * @var arrayReceivedHTTPheaderssofar*/
-  public $headers = [];
-
-  /**
-   * @var \GuzzleHttp\Psr7\ResponseInterfaceReceivedresponseifany*/
-  public $response;
-
-  /**
-   * @var \Psr\Http\Message\RequestInterfaceRequestbeingsent*/
-  public $request;
-
-  /**
-   * @var arrayRequestoptions*/
-  public $options = [];
-
-  /**
-   * @var intcURLerrornumberifany*/
-  public $errno = 0;
-
-  /**
-   * @var \ExceptionExceptionduringon_headersifany*/
-  public $onHeadersException;
+final class EasyHandle
+{
+    /**
+   * @var resourcecURLresource
+*/
+    public $handle;
+
+    /**
+   * @var \Psr\Http\Message\StreamInterfaceWheredataisbeingwritten
+*/
+    public $sink;
+
+    /**
+   * @var arrayReceivedHTTPheaderssofar
+*/
+    public $headers = [];
+
+    /**
+   * @var \GuzzleHttp\Psr7\ResponseInterfaceReceivedresponseifany
+*/
+    public $response;
+
+    /**
+   * @var \Psr\Http\Message\RequestInterfaceRequestbeingsent
+*/
+    public $request;
+
+    /**
+   * @var arrayRequestoptions
+*/
+    public $options = [];
+
+    /**
+   * @var intcURLerrornumberifany
+*/
+    public $errno = 0;
+
+    /**
+   * @var \ExceptionExceptionduringon_headersifany
+*/
+    public $onHeadersException;
 
-  /**
+    /**
    * Attach a response to the easy handle based on the received headers.
    *
    * @throws \RuntimeException if no headers have been received.
    */
-  public function createResponse() {
-    if (empty($this->headers)) {
-      throw new \RuntimeException('No headers have been received');
-    }
+    public function createResponse() 
+    {
+        if (empty($this->headers)) {
+            throw new \RuntimeException('No headers have been received');
+        }
 
-    // HTTP-version SP status-code SP reason-phrase.
-    $startLine = explode(' ', array_shift($this->headers), 3);
-    $headers = \GuzzleHttp\headers_from_lines($this->headers);
-    $normalizedKeys = \GuzzleHttp\normalize_header_keys($headers);
-
-    if (!empty($this->options['decode_content'])
-        && isset($normalizedKeys['content-encoding'])
-    ) {
-      $headers['x-encoded-content-encoding']
+        // HTTP-version SP status-code SP reason-phrase.
+        $startLine = explode(' ', array_shift($this->headers), 3);
+        $headers = \GuzzleHttp\headers_from_lines($this->headers);
+        $normalizedKeys = \GuzzleHttp\normalize_header_keys($headers);
+
+        if (!empty($this->options['decode_content'])
+            && isset($normalizedKeys['content-encoding'])
+        ) {
+            $headers['x-encoded-content-encoding']
                 = $headers[$normalizedKeys['content-encoding']];
-      unset($headers[$normalizedKeys['content-encoding']]);
-      if (isset($normalizedKeys['content-length'])) {
-        $headers['x-encoded-content-length']
+            unset($headers[$normalizedKeys['content-encoding']]);
+            if (isset($normalizedKeys['content-length'])) {
+                $headers['x-encoded-content-length']
                     = $headers[$normalizedKeys['content-length']];
 
-        $bodyLength = (int) $this->sink->getSize();
-        if ($bodyLength) {
-          $headers[$normalizedKeys['content-length']] = $bodyLength;
-        }
-        else {
-          unset($headers[$normalizedKeys['content-length']]);
+                $bodyLength = (int) $this->sink->getSize();
+                if ($bodyLength) {
+                    $headers[$normalizedKeys['content-length']] = $bodyLength;
+                }
+                else {
+                    unset($headers[$normalizedKeys['content-length']]);
+                }
+            }
         }
-      }
-    }
 
-    // Attach a response to the easy handle with the parsed headers.
-    $this->response = new Response(
-        $startLine[1],
-        $headers,
-        $this->sink,
-        substr($startLine[0], 5),
-        isset($startLine[2]) ? (string) $startLine[2] : NULL
-    );
-  }
+        // Attach a response to the easy handle with the parsed headers.
+        $this->response = new Response(
+            $startLine[1],
+            $headers,
+            $this->sink,
+            substr($startLine[0], 5),
+            isset($startLine[2]) ? (string) $startLine[2] : null
+        );
+    }
 
-  /**
+    /**
    *
    */
-  public function __get($name) {
-    $msg = $name === 'handle'
+    public function __get($name) 
+    {
+        $msg = $name === 'handle'
             ? 'The EasyHandle has been released'
             : 'Invalid property: ' . $name;
-    throw new \BadMethodCallException($msg);
-  }
+        throw new \BadMethodCallException($msg);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/CurlFactory.php
+++ PHP_CodeSniffer
@@ -13,501 +13,518 @@
 /**
  * Creates curl resources from a request.
  */
-class CurlFactory implements CurlFactoryInterface {
-  /**
-   * @var array*/
-  private $handles = [];
-
-  /**
-   * @var intTotalnumberofidlehandlestokeepincache*/
-  private $maxHandles;
+class CurlFactory implements CurlFactoryInterface
+{
+    /**
+   * @var array
+*/
+    private $handles = [];
+
+    /**
+   * @var intTotalnumberofidlehandlestokeepincache
+*/
+    private $maxHandles;
 
-  /**
+    /**
    * @param int $maxHandles
    *   Maximum number of idle handles.
    */
-  public function __construct($maxHandles) {
-    $this->maxHandles = $maxHandles;
-  }
+    public function __construct($maxHandles) 
+    {
+        $this->maxHandles = $maxHandles;
+    }
 
-  /**
+    /**
    *
    */
-  public function create(RequestInterface $request, array $options) {
-    if (isset($options['curl']['body_as_string'])) {
-      $options['_body_as_string'] = $options['curl']['body_as_string'];
-      unset($options['curl']['body_as_string']);
-    }
-
-    $easy = new EasyHandle();
-    $easy->request = $request;
-    $easy->options = $options;
-    $conf = $this->getDefaultConf($easy);
-    $this->applyMethod($easy, $conf);
-    $this->applyHandlerOptions($easy, $conf);
-    $this->applyHeaders($easy, $conf);
-    unset($conf['_headers']);
+    public function create(RequestInterface $request, array $options) 
+    {
+        if (isset($options['curl']['body_as_string'])) {
+            $options['_body_as_string'] = $options['curl']['body_as_string'];
+            unset($options['curl']['body_as_string']);
+        }
 
-    // Add handler options from the request configuration options.
-    if (isset($options['curl'])) {
-      $conf = array_replace($conf, $options['curl']);
-    }
+        $easy = new EasyHandle();
+        $easy->request = $request;
+        $easy->options = $options;
+        $conf = $this->getDefaultConf($easy);
+        $this->applyMethod($easy, $conf);
+        $this->applyHandlerOptions($easy, $conf);
+        $this->applyHeaders($easy, $conf);
+        unset($conf['_headers']);
+
+        // Add handler options from the request configuration options.
+        if (isset($options['curl'])) {
+            $conf = array_replace($conf, $options['curl']);
+        }
 
-    $conf[CURLOPT_HEADERFUNCTION] = $this->createHeaderFn($easy);
-    $easy->handle = $this->handles
+        $conf[CURLOPT_HEADERFUNCTION] = $this->createHeaderFn($easy);
+        $easy->handle = $this->handles
             ? array_pop($this->handles)
             : curl_init();
-    curl_setopt_array($easy->handle, $conf);
+        curl_setopt_array($easy->handle, $conf);
 
-    return $easy;
-  }
+        return $easy;
+    }
 
-  /**
+    /**
    *
    */
-  public function release(EasyHandle $easy) {
-    $resource = $easy->handle;
-    unset($easy->handle);
+    public function release(EasyHandle $easy) 
+    {
+        $resource = $easy->handle;
+        unset($easy->handle);
 
-    if (count($this->handles) >= $this->maxHandles) {
-      curl_close($resource);
-    }
-    else {
-      // Remove all callback functions as they can hold onto references
-      // and are not cleaned up by curl_reset. Using curl_setopt_array
-      // does not work for some reason, so removing each one
-      // individually.
-      curl_setopt($resource, CURLOPT_HEADERFUNCTION, NULL);
-      curl_setopt($resource, CURLOPT_READFUNCTION, NULL);
-      curl_setopt($resource, CURLOPT_WRITEFUNCTION, NULL);
-      curl_setopt($resource, CURLOPT_PROGRESSFUNCTION, NULL);
-      curl_reset($resource);
-      $this->handles[] = $resource;
+        if (count($this->handles) >= $this->maxHandles) {
+            curl_close($resource);
+        }
+        else {
+            // Remove all callback functions as they can hold onto references
+            // and are not cleaned up by curl_reset. Using curl_setopt_array
+            // does not work for some reason, so removing each one
+            // individually.
+            curl_setopt($resource, CURLOPT_HEADERFUNCTION, null);
+            curl_setopt($resource, CURLOPT_READFUNCTION, null);
+            curl_setopt($resource, CURLOPT_WRITEFUNCTION, null);
+            curl_setopt($resource, CURLOPT_PROGRESSFUNCTION, null);
+            curl_reset($resource);
+            $this->handles[] = $resource;
+        }
     }
-  }
 
-  /**
+    /**
    * Completes a cURL transaction, either returning a response promise or a
    * rejected promise.
    *
-   * @param callable $handler
-   * @param EasyHandle $easy
+   * @param callable             $handler
+   * @param EasyHandle           $easy
    * @param CurlFactoryInterface $factory
    *   Dictates how the handle is released.
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public static function finish(
+    public static function finish(
         callable $handler,
         EasyHandle $easy,
         CurlFactoryInterface $factory
     ) {
-    if (isset($easy->options['on_stats'])) {
-      self::invokeStats($easy);
-    }
+        if (isset($easy->options['on_stats'])) {
+            self::invokeStats($easy);
+        }
 
-    if (!$easy->response || $easy->errno) {
-      return self::finishError($handler, $easy, $factory);
-    }
+        if (!$easy->response || $easy->errno) {
+            return self::finishError($handler, $easy, $factory);
+        }
 
-    // Return the response if it is present and there is no error.
-    $factory->release($easy);
+        // Return the response if it is present and there is no error.
+        $factory->release($easy);
 
-    // Rewind the body of the response if possible.
-    $body = $easy->response->getBody();
-    if ($body->isSeekable()) {
-      $body->rewind();
-    }
+        // Rewind the body of the response if possible.
+        $body = $easy->response->getBody();
+        if ($body->isSeekable()) {
+            $body->rewind();
+        }
 
-    return new FulfilledPromise($easy->response);
-  }
+        return new FulfilledPromise($easy->response);
+    }
 
-  /**
+    /**
    *
    */
-  private static function invokeStats(EasyHandle $easy) {
-    $curlStats = curl_getinfo($easy->handle);
-    $stats = new TransferStats(
-        $easy->request,
-        $easy->response,
-        $curlStats['total_time'],
-        $easy->errno,
-        $curlStats
-    );
-    call_user_func($easy->options['on_stats'], $stats);
-  }
+    private static function invokeStats(EasyHandle $easy) 
+    {
+        $curlStats = curl_getinfo($easy->handle);
+        $stats = new TransferStats(
+            $easy->request,
+            $easy->response,
+            $curlStats['total_time'],
+            $easy->errno,
+            $curlStats
+        );
+        call_user_func($easy->options['on_stats'], $stats);
+    }
 
-  /**
+    /**
    *
    */
-  private static function finishError(
+    private static function finishError(
         callable $handler,
         EasyHandle $easy,
         CurlFactoryInterface $factory
     ) {
-    // Get error information and release the handle to the factory.
-    $ctx = [
-      'errno' => $easy->errno,
-      'error' => curl_error($easy->handle),
-    ] + curl_getinfo($easy->handle);
-    $factory->release($easy);
-
-    // Retry when nothing is present or when curl failed to rewind.
-    if (empty($easy->options['_err_message'])
-        && (!$easy->errno || $easy->errno == 65)
-    ) {
-      return self::retryFailedRewind($handler, $easy, $ctx);
-    }
+        // Get error information and release the handle to the factory.
+        $ctx = [
+        'errno' => $easy->errno,
+        'error' => curl_error($easy->handle),
+        ] + curl_getinfo($easy->handle);
+        $factory->release($easy);
+
+        // Retry when nothing is present or when curl failed to rewind.
+        if (empty($easy->options['_err_message'])
+            && (!$easy->errno || $easy->errno == 65)
+        ) {
+            return self::retryFailedRewind($handler, $easy, $ctx);
+        }
 
-    return self::createRejection($easy, $ctx);
-  }
+        return self::createRejection($easy, $ctx);
+    }
 
-  /**
+    /**
    *
    */
-  private static function createRejection(EasyHandle $easy, array $ctx) {
-    static $connectionErrors = [
-      CURLE_OPERATION_TIMEOUTED  => TRUE,
-      CURLE_COULDNT_RESOLVE_HOST => TRUE,
-      CURLE_COULDNT_CONNECT      => TRUE,
-      CURLE_SSL_CONNECT_ERROR    => TRUE,
-      CURLE_GOT_NOTHING          => TRUE,
-    ];
-
-    // If an exception was encountered during the onHeaders event, then
-    // return a rejected promise that wraps that exception.
-    if ($easy->onHeadersException) {
-      return \GuzzleHttp\Promise\rejection_for(
-        new RequestException(
-            'An error was encountered during the on_headers event',
-            $easy->request,
-            $easy->response,
-            $easy->onHeadersException,
-            $ctx
-        )
-      );
-    }
+    private static function createRejection(EasyHandle $easy, array $ctx) 
+    {
+        static $connectionErrors = [
+        CURLE_OPERATION_TIMEOUTED  => true,
+        CURLE_COULDNT_RESOLVE_HOST => true,
+        CURLE_COULDNT_CONNECT      => true,
+        CURLE_SSL_CONNECT_ERROR    => true,
+        CURLE_GOT_NOTHING          => true,
+        ];
+
+        // If an exception was encountered during the onHeaders event, then
+        // return a rejected promise that wraps that exception.
+        if ($easy->onHeadersException) {
+            return \GuzzleHttp\Promise\rejection_for(
+                new RequestException(
+                    'An error was encountered during the on_headers event',
+                    $easy->request,
+                    $easy->response,
+                    $easy->onHeadersException,
+                    $ctx
+                )
+            );
+        }
 
-    $message = sprintf(
-        'cURL error %s: %s (%s)',
-        $ctx['errno'],
-        $ctx['error'],
-        'see http://curl.haxx.se/libcurl/c/libcurl-errors.html'
-    );
+        $message = sprintf(
+            'cURL error %s: %s (%s)',
+            $ctx['errno'],
+            $ctx['error'],
+            'see http://curl.haxx.se/libcurl/c/libcurl-errors.html'
+        );
 
-    // Create a connection exception if it was a specific error code.
-    $error = isset($connectionErrors[$easy->errno])
-            ? new ConnectException($message, $easy->request, NULL, $ctx)
-            : new RequestException($message, $easy->request, $easy->response, NULL, $ctx);
+        // Create a connection exception if it was a specific error code.
+        $error = isset($connectionErrors[$easy->errno])
+            ? new ConnectException($message, $easy->request, null, $ctx)
+            : new RequestException($message, $easy->request, $easy->response, null, $ctx);
+
+        return \GuzzleHttp\Promise\rejection_for($error);
+    }
+
+    /**
+   *
+   */
+    private function getDefaultConf(EasyHandle $easy) 
+    {
+        $conf = [
+        '_headers'             => $easy->request->getHeaders(),
+        CURLOPT_CUSTOMREQUEST  => $easy->request->getMethod(),
+        CURLOPT_URL            => (string) $easy->request->getUri()->withFragment(''),
+        CURLOPT_RETURNTRANSFER => false,
+        CURLOPT_HEADER         => false,
+        CURLOPT_CONNECTTIMEOUT => 150,
+        ];
 
-    return \GuzzleHttp\Promise\rejection_for($error);
-  }
+        if (defined('CURLOPT_PROTOCOLS')) {
+            $conf[CURLOPT_PROTOCOLS] = CURLPROTO_HTTP | CURLPROTO_HTTPS;
+        }
 
-  /**
-   *
-   */
-  private function getDefaultConf(EasyHandle $easy) {
-    $conf = [
-      '_headers'             => $easy->request->getHeaders(),
-      CURLOPT_CUSTOMREQUEST  => $easy->request->getMethod(),
-      CURLOPT_URL            => (string) $easy->request->getUri()->withFragment(''),
-      CURLOPT_RETURNTRANSFER => FALSE,
-      CURLOPT_HEADER         => FALSE,
-      CURLOPT_CONNECTTIMEOUT => 150,
-    ];
+        $version = $easy->request->getProtocolVersion();
+        if ($version == 1.1) {
+            $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_1_1;
+        }
+        elseif ($version == 2.0) {
+            $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_2_0;
+        }
+        else {
+            $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_1_0;
+        }
 
-    if (defined('CURLOPT_PROTOCOLS')) {
-      $conf[CURLOPT_PROTOCOLS] = CURLPROTO_HTTP | CURLPROTO_HTTPS;
+        return $conf;
     }
 
-    $version = $easy->request->getProtocolVersion();
-    if ($version == 1.1) {
-      $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_1_1;
-    }
-    elseif ($version == 2.0) {
-      $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_2_0;
-    }
-    else {
-      $conf[CURLOPT_HTTP_VERSION] = CURL_HTTP_VERSION_1_0;
-    }
-
-    return $conf;
-  }
-
-  /**
+    /**
    *
    */
-  private function applyMethod(EasyHandle $easy, array &$conf) {
-    $body = $easy->request->getBody();
-    $size = $body->getSize();
+    private function applyMethod(EasyHandle $easy, array &$conf) 
+    {
+        $body = $easy->request->getBody();
+        $size = $body->getSize();
 
-    if ($size === NULL || $size > 0) {
-      $this->applyBody($easy->request, $easy->options, $conf);
-      return;
-    }
+        if ($size === null || $size > 0) {
+            $this->applyBody($easy->request, $easy->options, $conf);
+            return;
+        }
 
-    $method = $easy->request->getMethod();
-    if ($method === 'PUT' || $method === 'POST') {
-      // See http://tools.ietf.org/html/rfc7230#section-3.3.2
-      if (!$easy->request->hasHeader('Content-Length')) {
-        $conf[CURLOPT_HTTPHEADER][] = 'Content-Length: 0';
-      }
-    }
-    elseif ($method === 'HEAD') {
-      $conf[CURLOPT_NOBODY] = TRUE;
-      unset(
-        $conf[CURLOPT_WRITEFUNCTION],
-        $conf[CURLOPT_READFUNCTION],
-        $conf[CURLOPT_FILE],
-        $conf[CURLOPT_INFILE]
-        );
+        $method = $easy->request->getMethod();
+        if ($method === 'PUT' || $method === 'POST') {
+            // See http://tools.ietf.org/html/rfc7230#section-3.3.2
+            if (!$easy->request->hasHeader('Content-Length')) {
+                $conf[CURLOPT_HTTPHEADER][] = 'Content-Length: 0';
+            }
+        }
+        elseif ($method === 'HEAD') {
+            $conf[CURLOPT_NOBODY] = true;
+            unset(
+                $conf[CURLOPT_WRITEFUNCTION],
+                $conf[CURLOPT_READFUNCTION],
+                $conf[CURLOPT_FILE],
+                $conf[CURLOPT_INFILE]
+            );
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function applyBody(RequestInterface $request, array $options, array &$conf) {
-    $size = $request->hasHeader('Content-Length')
+    private function applyBody(RequestInterface $request, array $options, array &$conf) 
+    {
+        $size = $request->hasHeader('Content-Length')
             ? (int) $request->getHeaderLine('Content-Length')
-            : NULL;
+            : null;
 
-    // Send the body as a string if the size is less than 1MB OR if the
-    // [curl][body_as_string] request value is set.
-    if (($size !== NULL && $size < 1000000) ||
-        !empty($options['_body_as_string'])
-    ) {
-      $conf[CURLOPT_POSTFIELDS] = (string) $request->getBody();
-      // Don't duplicate the Content-Length header.
-      $this->removeHeader('Content-Length', $conf);
-      $this->removeHeader('Transfer-Encoding', $conf);
-    }
-    else {
-      $conf[CURLOPT_UPLOAD] = TRUE;
-      if ($size !== NULL) {
-        $conf[CURLOPT_INFILESIZE] = $size;
-        $this->removeHeader('Content-Length', $conf);
-      }
-      $body = $request->getBody();
-      if ($body->isSeekable()) {
-        $body->rewind();
-      }
-      $conf[CURLOPT_READFUNCTION] = function ($ch, $fd, $length) use ($body) {
-        return $body->read($length);
-      };
-    }
+        // Send the body as a string if the size is less than 1MB OR if the
+        // [curl][body_as_string] request value is set.
+        if (($size !== null && $size < 1000000) 
+            || !empty($options['_body_as_string'])
+        ) {
+            $conf[CURLOPT_POSTFIELDS] = (string) $request->getBody();
+            // Don't duplicate the Content-Length header.
+            $this->removeHeader('Content-Length', $conf);
+            $this->removeHeader('Transfer-Encoding', $conf);
+        }
+        else {
+            $conf[CURLOPT_UPLOAD] = true;
+            if ($size !== null) {
+                $conf[CURLOPT_INFILESIZE] = $size;
+                $this->removeHeader('Content-Length', $conf);
+            }
+            $body = $request->getBody();
+            if ($body->isSeekable()) {
+                $body->rewind();
+            }
+            $conf[CURLOPT_READFUNCTION] = function ($ch, $fd, $length) use ($body) {
+                return $body->read($length);
+            };
+        }
 
-    // If the Expect header is not present, prevent curl from adding it.
-    if (!$request->hasHeader('Expect')) {
-      $conf[CURLOPT_HTTPHEADER][] = 'Expect:';
-    }
+        // If the Expect header is not present, prevent curl from adding it.
+        if (!$request->hasHeader('Expect')) {
+            $conf[CURLOPT_HTTPHEADER][] = 'Expect:';
+        }
 
-    // cURL sometimes adds a content-type by default. Prevent this.
-    if (!$request->hasHeader('Content-Type')) {
-      $conf[CURLOPT_HTTPHEADER][] = 'Content-Type:';
+        // cURL sometimes adds a content-type by default. Prevent this.
+        if (!$request->hasHeader('Content-Type')) {
+            $conf[CURLOPT_HTTPHEADER][] = 'Content-Type:';
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function applyHeaders(EasyHandle $easy, array &$conf) {
-    foreach ($conf['_headers'] as $name => $values) {
-      foreach ($values as $value) {
-        $conf[CURLOPT_HTTPHEADER][] = "$name: $value";
-      }
-    }
+    private function applyHeaders(EasyHandle $easy, array &$conf) 
+    {
+        foreach ($conf['_headers'] as $name => $values) {
+            foreach ($values as $value) {
+                $conf[CURLOPT_HTTPHEADER][] = "$name: $value";
+            }
+        }
 
-    // Remove the Accept header if one was not set.
-    if (!$easy->request->hasHeader('Accept')) {
-      $conf[CURLOPT_HTTPHEADER][] = 'Accept:';
+        // Remove the Accept header if one was not set.
+        if (!$easy->request->hasHeader('Accept')) {
+            $conf[CURLOPT_HTTPHEADER][] = 'Accept:';
+        }
     }
-  }
 
-  /**
+    /**
    * Remove a header from the options array.
    *
    * @param string $name
    *   Case-insensitive header to remove.
-   * @param array $options
+   * @param array  $options
    *   Array of options to modify.
    */
-  private function removeHeader($name, array &$options) {
-    foreach (array_keys($options['_headers']) as $key) {
-      if (!strcasecmp($key, $name)) {
-        unset($options['_headers'][$key]);
-        return;
-      }
-    }
-  }
-
-  /**
-   *
-   */
-  private function applyHandlerOptions(EasyHandle $easy, array &$conf) {
-    $options = $easy->options;
-    if (isset($options['verify'])) {
-      if ($options['verify'] === FALSE) {
-        unset($conf[CURLOPT_CAINFO]);
-        $conf[CURLOPT_SSL_VERIFYHOST] = 0;
-        $conf[CURLOPT_SSL_VERIFYPEER] = FALSE;
-      }
-      else {
-        $conf[CURLOPT_SSL_VERIFYHOST] = 2;
-        $conf[CURLOPT_SSL_VERIFYPEER] = TRUE;
-        if (is_string($options['verify'])) {
-          // Throw an error if the file/folder/link path is not valid or doesn't exist.
-          if (!file_exists($options['verify'])) {
-            throw new \InvalidArgumentException(
-            "SSL CA bundle not found: {$options['verify']}"
-            );
-          }
-          // If it's a directory or a link to a directory use CURLOPT_CAPATH.
-          // If not, it's probably a file, or a link to a file, so use CURLOPT_CAINFO.
-          if (is_dir($options['verify']) ||
-          (is_link($options['verify']) && is_dir(readlink($options['verify'])))) {
-            $conf[CURLOPT_CAPATH] = $options['verify'];
-          }
-          else {
-            $conf[CURLOPT_CAINFO] = $options['verify'];
-          }
-        }
-      }
-    }
-
-    if (!empty($options['decode_content'])) {
-      $accept = $easy->request->getHeaderLine('Accept-Encoding');
-      if ($accept) {
-        $conf[CURLOPT_ENCODING] = $accept;
-      }
-      else {
-        $conf[CURLOPT_ENCODING] = '';
-        // Don't let curl send the header over the wire.
-        $conf[CURLOPT_HTTPHEADER][] = 'Accept-Encoding:';
-      }
-    }
-
-    if (isset($options['sink'])) {
-      $sink = $options['sink'];
-      if (!is_string($sink)) {
-        $sink = \GuzzleHttp\Psr7\stream_for($sink);
-      }
-      elseif (!is_dir(dirname($sink))) {
-        // Ensure that the directory exists before failing in curl.
-        throw new \RuntimeException(sprintf(
-        'Directory %s does not exist for sink value of %s',
-        dirname($sink),
-        $sink
-          ));
-      }
-      else {
-        $sink = new LazyOpenStream($sink, 'w+');
-      }
-      $easy->sink = $sink;
-      $conf[CURLOPT_WRITEFUNCTION] = function ($ch, $write) use ($sink) {
-        return $sink->write($write);
-      };
-    }
-    else {
-      // Use a default temp stream if no sink was set.
-      $conf[CURLOPT_FILE] = fopen('php://temp', 'w+');
-      $easy->sink = Psr7\stream_for($conf[CURLOPT_FILE]);
-    }
-    $timeoutRequiresNoSignal = FALSE;
-    if (isset($options['timeout'])) {
-      $timeoutRequiresNoSignal |= $options['timeout'] < 1;
-      $conf[CURLOPT_TIMEOUT_MS] = $options['timeout'] * 1000;
-    }
-
-    // CURL default value is CURL_IPRESOLVE_WHATEVER.
-    if (isset($options['force_ip_resolve'])) {
-      if ('v4' === $options['force_ip_resolve']) {
-        $conf[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V4;
-      }
-      elseif ('v6' === $options['force_ip_resolve']) {
-        $conf[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V6;
-      }
-    }
-
-    if (isset($options['connect_timeout'])) {
-      $timeoutRequiresNoSignal |= $options['connect_timeout'] < 1;
-      $conf[CURLOPT_CONNECTTIMEOUT_MS] = $options['connect_timeout'] * 1000;
-    }
-
-    if ($timeoutRequiresNoSignal && strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN') {
-      $conf[CURLOPT_NOSIGNAL] = TRUE;
-    }
-
-    if (isset($options['proxy'])) {
-      if (!is_array($options['proxy'])) {
-        $conf[CURLOPT_PROXY] = $options['proxy'];
-      }
-      else {
-        $scheme = $easy->request->getUri()->getScheme();
-        if (isset($options['proxy'][$scheme])) {
-          $host = $easy->request->getUri()->getHost();
-          if (!isset($options['proxy']['no']) ||
-          !\GuzzleHttp\is_host_in_noproxy($host, $options['proxy']['no'])
-          ) {
-            $conf[CURLOPT_PROXY] = $options['proxy'][$scheme];
-          }
-        }
-      }
-    }
-
-    if (isset($options['cert'])) {
-      $cert = $options['cert'];
-      if (is_array($cert)) {
-        $conf[CURLOPT_SSLCERTPASSWD] = $cert[1];
-        $cert = $cert[0];
-      }
-      if (!file_exists($cert)) {
-        throw new \InvalidArgumentException(
-        "SSL certificate not found: {$cert}"
-        );
-      }
-      $conf[CURLOPT_SSLCERT] = $cert;
+    private function removeHeader($name, array &$options) 
+    {
+        foreach (array_keys($options['_headers']) as $key) {
+            if (!strcasecmp($key, $name)) {
+                unset($options['_headers'][$key]);
+                return;
+            }
+        }
     }
 
-    if (isset($options['ssl_key'])) {
-      $sslKey = $options['ssl_key'];
-      if (is_array($sslKey)) {
-        $conf[CURLOPT_SSLKEYPASSWD] = $sslKey[1];
-        $sslKey = $sslKey[0];
-      }
-      if (!file_exists($sslKey)) {
-        throw new \InvalidArgumentException(
-        "SSL private key not found: {$sslKey}"
-        );
-      }
-      $conf[CURLOPT_SSLKEY] = $sslKey;
-    }
+    /**
+   *
+   */
+    private function applyHandlerOptions(EasyHandle $easy, array &$conf) 
+    {
+        $options = $easy->options;
+        if (isset($options['verify'])) {
+            if ($options['verify'] === false) {
+                unset($conf[CURLOPT_CAINFO]);
+                $conf[CURLOPT_SSL_VERIFYHOST] = 0;
+                $conf[CURLOPT_SSL_VERIFYPEER] = false;
+            }
+            else {
+                $conf[CURLOPT_SSL_VERIFYHOST] = 2;
+                $conf[CURLOPT_SSL_VERIFYPEER] = true;
+                if (is_string($options['verify'])) {
+                    // Throw an error if the file/folder/link path is not valid or doesn't exist.
+                    if (!file_exists($options['verify'])) {
+                        throw new \InvalidArgumentException(
+                            "SSL CA bundle not found: {$options['verify']}"
+                        );
+                    }
+                    // If it's a directory or a link to a directory use CURLOPT_CAPATH.
+                    // If not, it's probably a file, or a link to a file, so use CURLOPT_CAINFO.
+                    if (is_dir($options['verify']) 
+                        || (is_link($options['verify']) && is_dir(readlink($options['verify'])))
+                    ) {
+                        $conf[CURLOPT_CAPATH] = $options['verify'];
+                    }
+                    else {
+                        $conf[CURLOPT_CAINFO] = $options['verify'];
+                    }
+                }
+            }
+        }
 
-    if (isset($options['progress'])) {
-      $progress = $options['progress'];
-      if (!is_callable($progress)) {
-        throw new \InvalidArgumentException(
-        'progress client option must be callable'
-        );
-      }
-      $conf[CURLOPT_NOPROGRESS] = FALSE;
-      $conf[CURLOPT_PROGRESSFUNCTION] = function () use ($progress) {
-        $args = func_get_args();
-        // PHP 5.5 pushed the handle onto the start of the args.
-        if (is_resource($args[0])) {
-          array_shift($args);
+        if (!empty($options['decode_content'])) {
+            $accept = $easy->request->getHeaderLine('Accept-Encoding');
+            if ($accept) {
+                $conf[CURLOPT_ENCODING] = $accept;
+            }
+            else {
+                $conf[CURLOPT_ENCODING] = '';
+                // Don't let curl send the header over the wire.
+                $conf[CURLOPT_HTTPHEADER][] = 'Accept-Encoding:';
+            }
         }
-        call_user_func_array($progress, $args);
-      };
-    }
 
-    if (!empty($options['debug'])) {
-      $conf[CURLOPT_STDERR] = \GuzzleHttp\debug_resource($options['debug']);
-      $conf[CURLOPT_VERBOSE] = TRUE;
+        if (isset($options['sink'])) {
+            $sink = $options['sink'];
+            if (!is_string($sink)) {
+                $sink = \GuzzleHttp\Psr7\stream_for($sink);
+            }
+            elseif (!is_dir(dirname($sink))) {
+                // Ensure that the directory exists before failing in curl.
+                throw new \RuntimeException(
+                    sprintf(
+                        'Directory %s does not exist for sink value of %s',
+                        dirname($sink),
+                        $sink
+                    )
+                );
+            }
+            else {
+                $sink = new LazyOpenStream($sink, 'w+');
+            }
+            $easy->sink = $sink;
+            $conf[CURLOPT_WRITEFUNCTION] = function ($ch, $write) use ($sink) {
+                return $sink->write($write);
+            };
+        }
+        else {
+            // Use a default temp stream if no sink was set.
+            $conf[CURLOPT_FILE] = fopen('php://temp', 'w+');
+            $easy->sink = Psr7\stream_for($conf[CURLOPT_FILE]);
+        }
+        $timeoutRequiresNoSignal = false;
+        if (isset($options['timeout'])) {
+            $timeoutRequiresNoSignal |= $options['timeout'] < 1;
+            $conf[CURLOPT_TIMEOUT_MS] = $options['timeout'] * 1000;
+        }
+
+        // CURL default value is CURL_IPRESOLVE_WHATEVER.
+        if (isset($options['force_ip_resolve'])) {
+            if ('v4' === $options['force_ip_resolve']) {
+                $conf[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V4;
+            }
+            elseif ('v6' === $options['force_ip_resolve']) {
+                $conf[CURLOPT_IPRESOLVE] = CURL_IPRESOLVE_V6;
+            }
+        }
+
+        if (isset($options['connect_timeout'])) {
+            $timeoutRequiresNoSignal |= $options['connect_timeout'] < 1;
+            $conf[CURLOPT_CONNECTTIMEOUT_MS] = $options['connect_timeout'] * 1000;
+        }
+
+        if ($timeoutRequiresNoSignal && strtoupper(substr(PHP_OS, 0, 3)) !== 'WIN') {
+            $conf[CURLOPT_NOSIGNAL] = true;
+        }
+
+        if (isset($options['proxy'])) {
+            if (!is_array($options['proxy'])) {
+                $conf[CURLOPT_PROXY] = $options['proxy'];
+            }
+            else {
+                $scheme = $easy->request->getUri()->getScheme();
+                if (isset($options['proxy'][$scheme])) {
+                    $host = $easy->request->getUri()->getHost();
+                    if (!isset($options['proxy']['no']) 
+                        || !\GuzzleHttp\is_host_in_noproxy($host, $options['proxy']['no'])
+                    ) {
+                        $conf[CURLOPT_PROXY] = $options['proxy'][$scheme];
+                    }
+                }
+            }
+        }
+
+        if (isset($options['cert'])) {
+            $cert = $options['cert'];
+            if (is_array($cert)) {
+                $conf[CURLOPT_SSLCERTPASSWD] = $cert[1];
+                $cert = $cert[0];
+            }
+            if (!file_exists($cert)) {
+                throw new \InvalidArgumentException(
+                    "SSL certificate not found: {$cert}"
+                );
+            }
+            $conf[CURLOPT_SSLCERT] = $cert;
+        }
+
+        if (isset($options['ssl_key'])) {
+            $sslKey = $options['ssl_key'];
+            if (is_array($sslKey)) {
+                $conf[CURLOPT_SSLKEYPASSWD] = $sslKey[1];
+                $sslKey = $sslKey[0];
+            }
+            if (!file_exists($sslKey)) {
+                throw new \InvalidArgumentException(
+                    "SSL private key not found: {$sslKey}"
+                );
+            }
+            $conf[CURLOPT_SSLKEY] = $sslKey;
+        }
+
+        if (isset($options['progress'])) {
+            $progress = $options['progress'];
+            if (!is_callable($progress)) {
+                throw new \InvalidArgumentException(
+                    'progress client option must be callable'
+                );
+            }
+            $conf[CURLOPT_NOPROGRESS] = false;
+            $conf[CURLOPT_PROGRESSFUNCTION] = function () use ($progress) {
+                $args = func_get_args();
+                // PHP 5.5 pushed the handle onto the start of the args.
+                if (is_resource($args[0])) {
+                    array_shift($args);
+                }
+                call_user_func_array($progress, $args);
+            };
+        }
+
+        if (!empty($options['debug'])) {
+            $conf[CURLOPT_STDERR] = \GuzzleHttp\debug_resource($options['debug']);
+            $conf[CURLOPT_VERBOSE] = true;
+        }
     }
-  }
 
-  /**
+    /**
    * This function ensures that a response was set on a transaction. If one
    * was not set, then the request is retried if possible. This error
    * typically means you are sending a payload, curl encountered a
@@ -516,92 +533,94 @@
    * error, causing the request to be sent through curl_multi_info_read()
    * without an error status.
    */
-  private static function retryFailedRewind(
+    private static function retryFailedRewind(
         callable $handler,
         EasyHandle $easy,
         array $ctx
     ) {
-    try {
-      // Only rewind if the body has been read from.
-      $body = $easy->request->getBody();
-      if ($body->tell() > 0) {
-        $body->rewind();
-      }
-    }
-    catch (\RuntimeException $e) {
-      $ctx['error'] = 'The connection unexpectedly failed without '
+        try {
+            // Only rewind if the body has been read from.
+            $body = $easy->request->getBody();
+            if ($body->tell() > 0) {
+                $body->rewind();
+            }
+        }
+        catch (\RuntimeException $e) {
+            $ctx['error'] = 'The connection unexpectedly failed without '
                 . 'providing an error. The request would have been retried, '
                 . 'but attempting to rewind the request body failed. '
                 . 'Exception: ' . $e;
-      return self::createRejection($easy, $ctx);
-    }
+            return self::createRejection($easy, $ctx);
+        }
 
-    // Retry no more than 3 times before giving up.
-    if (!isset($easy->options['_curl_retries'])) {
-      $easy->options['_curl_retries'] = 1;
-    }
-    elseif ($easy->options['_curl_retries'] == 2) {
-      $ctx['error'] = 'The cURL request was retried 3 times '
+        // Retry no more than 3 times before giving up.
+        if (!isset($easy->options['_curl_retries'])) {
+            $easy->options['_curl_retries'] = 1;
+        }
+        elseif ($easy->options['_curl_retries'] == 2) {
+            $ctx['error'] = 'The cURL request was retried 3 times '
                 . 'and did not succeed. The most likely reason for the failure '
                 . 'is that cURL was unable to rewind the body of the request '
                 . 'and subsequent retries resulted in the same error. Turn on '
                 . 'the debug option to see what went wrong. See '
                 . 'https://bugs.php.net/bug.php?id=47204 for more information.';
-      return self::createRejection($easy, $ctx);
-    }
-    else {
-      $easy->options['_curl_retries']++;
-    }
+            return self::createRejection($easy, $ctx);
+        }
+        else {
+            $easy->options['_curl_retries']++;
+        }
 
-    return $handler($easy->request, $easy->options);
-  }
+        return $handler($easy->request, $easy->options);
+    }
 
-  /**
+    /**
    *
    */
-  private function createHeaderFn(EasyHandle $easy) {
-    if (isset($easy->options['on_headers'])) {
-      $onHeaders = $easy->options['on_headers'];
+    private function createHeaderFn(EasyHandle $easy) 
+    {
+        if (isset($easy->options['on_headers'])) {
+            $onHeaders = $easy->options['on_headers'];
 
-      if (!is_callable($onHeaders)) {
-        throw new \InvalidArgumentException('on_headers must be callable');
-      }
-    }
-    else {
-      $onHeaders = NULL;
-    }
+            if (!is_callable($onHeaders)) {
+                throw new \InvalidArgumentException('on_headers must be callable');
+            }
+        }
+        else {
+            $onHeaders = null;
+        }
 
-    return function ($ch,
- $h) use (
+        return function ($ch,
+            $h
+        ) use (
             $onHeaders,
             $easy,
             &$startingResponse
         ) {
-      $value = trim($h);
-      if ($value === '') {
-        $startingResponse = TRUE;
-        $easy->createResponse();
-        if ($onHeaders !== NULL) {
-          try {
-            $onHeaders($easy->response);
-          }
-          catch (\Exception $e) {
-            // Associate the exception with the handle and trigger
-            // a curl header write error by returning 0.
-            $easy->onHeadersException = $e;
-            return -1;
-          }
-        }
-      }
-      elseif ($startingResponse) {
-        $startingResponse = FALSE;
-        $easy->headers = [$value];
-      }
-      else {
-        $easy->headers[] = $value;
-      }
-      return strlen($h);
-    };
-  }
+            $value = trim($h);
+            if ($value === '') {
+                $startingResponse = true;
+                $easy->createResponse();
+                if ($onHeaders !== null) {
+                    try {
+                        $onHeaders($easy->response);
+                    }
+                    catch (\Exception $e) {
+                        // Associate the exception with the handle and trigger
+                        // a curl header write error by returning 0.
+                        $easy->onHeadersException = $e;
+                        return -1;
+                    }
+                }
+            }
+            elseif ($startingResponse) {
+                $startingResponse = false;
+                $easy->headers = [$value];
+            }
+            else {
+                $easy->headers[] = $value;
+            }
+            return strlen($h);
+        };
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/CurlMultiHandler.php
+++ PHP_CodeSniffer
@@ -15,16 +15,18 @@
  *
  * @property resource $_mh Internal use only. Lazy loaded multi-handle.
  */
-class CurlMultiHandler {
-  /**
-   * @var CurlFactoryInterface*/
-  private $factory;
-  private $selectTimeout;
-  private $active;
-  private $handles = [];
-  private $delays = [];
+class CurlMultiHandler
+{
+    /**
+   * @var CurlFactoryInterface
+*/
+    private $factory;
+    private $selectTimeout;
+    private $active;
+    private $handles = [];
+    private $delays = [];
 
-  /**
+    /**
    * This handler accepts the following options:.
    *
    * - handle_factory: An optional factory  used to create curl handles
@@ -33,119 +35,126 @@
    *
    * @param array $options
    */
-  public function __construct(array $options = []) {
-    $this->factory = isset($options['handle_factory'])
+    public function __construct(array $options = []) 
+    {
+        $this->factory = isset($options['handle_factory'])
             ? $options['handle_factory'] : new CurlFactory(50);
-    $this->selectTimeout = isset($options['select_timeout'])
+        $this->selectTimeout = isset($options['select_timeout'])
             ? $options['select_timeout'] : 1;
-  }
+    }
 
-  /**
+    /**
    *
    */
-  public function __get($name) {
-    if ($name === '_mh') {
-      return $this->_mh = curl_multi_init();
-    }
+    public function __get($name) 
+    {
+        if ($name === '_mh') {
+            return $this->_mh = curl_multi_init();
+        }
 
-    throw new \BadMethodCallException();
-  }
+        throw new \BadMethodCallException();
+    }
 
-  /**
+    /**
    *
    */
-  public function __destruct() {
-    if (isset($this->_mh)) {
-      curl_multi_close($this->_mh);
-      unset($this->_mh);
+    public function __destruct() 
+    {
+        if (isset($this->_mh)) {
+            curl_multi_close($this->_mh);
+            unset($this->_mh);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    $easy = $this->factory->create($request, $options);
-    $id = (int) $easy->handle;
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        $easy = $this->factory->create($request, $options);
+        $id = (int) $easy->handle;
 
-    $promise = new Promise(
-        [$this, 'execute'],
-        function () use ($id) {
-          return $this->cancel($id);
-        }
-    );
+        $promise = new Promise(
+            [$this, 'execute'],
+            function () use ($id) {
+                return $this->cancel($id);
+            }
+        );
 
-    $this->addRequest(['easy' => $easy, 'deferred' => $promise]);
+        $this->addRequest(['easy' => $easy, 'deferred' => $promise]);
 
-    return $promise;
-  }
+        return $promise;
+    }
 
-  /**
+    /**
    * Ticks the curl event loop.
    */
-  public function tick() {
-    // Add any delayed handles if needed.
-    if ($this->delays) {
-      $currentTime = microtime(TRUE);
-      foreach ($this->delays as $id => $delay) {
-        if ($currentTime >= $delay) {
-          unset($this->delays[$id]);
-          curl_multi_add_handle(
-          $this->_mh,
-          $this->handles[$id]['easy']->handle
-          );
+    public function tick() 
+    {
+        // Add any delayed handles if needed.
+        if ($this->delays) {
+            $currentTime = microtime(true);
+            foreach ($this->delays as $id => $delay) {
+                if ($currentTime >= $delay) {
+                    unset($this->delays[$id]);
+                    curl_multi_add_handle(
+                        $this->_mh,
+                        $this->handles[$id]['easy']->handle
+                    );
+                }
+            }
         }
-      }
-    }
 
-    // Step through the task queue which may add additional requests.
-    P\queue()->run();
+        // Step through the task queue which may add additional requests.
+        P\queue()->run();
 
-    if ($this->active &&
-        curl_multi_select($this->_mh, $this->selectTimeout) === -1
-    ) {
-      // Perform a usleep if a select returns -1.
-      // See: https://bugs.php.net/bug.php?id=61141
-      usleep(250);
-    }
+        if ($this->active 
+            && curl_multi_select($this->_mh, $this->selectTimeout) === -1
+        ) {
+            // Perform a usleep if a select returns -1.
+            // See: https://bugs.php.net/bug.php?id=61141
+            usleep(250);
+        }
 
-    while (curl_multi_exec($this->_mh, $this->active) === CURLM_CALL_MULTI_PERFORM) {
-    }
+        while (curl_multi_exec($this->_mh, $this->active) === CURLM_CALL_MULTI_PERFORM) {
+        }
 
-    $this->processMessages();
-  }
+        $this->processMessages();
+    }
 
-  /**
+    /**
    * Runs until all outstanding connections have completed.
    */
-  public function execute() {
-    $queue = P\queue();
-
-    while ($this->handles || !$queue->isEmpty()) {
-      // If there are no transfers, then sleep for the next delay.
-      if (!$this->active && $this->delays) {
-        usleep($this->timeToNext());
-      }
-      $this->tick();
+    public function execute() 
+    {
+        $queue = P\queue();
+
+        while ($this->handles || !$queue->isEmpty()) {
+            // If there are no transfers, then sleep for the next delay.
+            if (!$this->active && $this->delays) {
+                usleep($this->timeToNext());
+            }
+            $this->tick();
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function addRequest(array $entry) {
-    $easy = $entry['easy'];
-    $id = (int) $easy->handle;
-    $this->handles[$id] = $entry;
-    if (empty($easy->options['delay'])) {
-      curl_multi_add_handle($this->_mh, $easy->handle);
-    }
-    else {
-      $this->delays[$id] = microtime(TRUE) + ($easy->options['delay'] / 1000);
+    private function addRequest(array $entry) 
+    {
+        $easy = $entry['easy'];
+        $id = (int) $easy->handle;
+        $this->handles[$id] = $entry;
+        if (empty($easy->options['delay'])) {
+            curl_multi_add_handle($this->_mh, $easy->handle);
+        }
+        else {
+            $this->delays[$id] = microtime(true) + ($easy->options['delay'] / 1000);
+        }
     }
-  }
 
-  /**
+    /**
    * Cancels a handle from sending and removes references to it.
    *
    * @param int $id
@@ -153,59 +162,62 @@
    *
    * @return bool True on success, false on failure.
    */
-  private function cancel($id) {
-    // Cannot cancel if it has been processed.
-    if (!isset($this->handles[$id])) {
-      return FALSE;
-    }
-
-    $handle = $this->handles[$id]['easy']->handle;
-    unset($this->delays[$id], $this->handles[$id]);
-    curl_multi_remove_handle($this->_mh, $handle);
-    curl_close($handle);
-
-    return TRUE;
-  }
-
-  /**
-   *
-   */
-  private function processMessages() {
-    while ($done = curl_multi_info_read($this->_mh)) {
-      $id = (int) $done['handle'];
-      curl_multi_remove_handle($this->_mh, $done['handle']);
-
-      if (!isset($this->handles[$id])) {
-        // Probably was cancelled.
-        continue;
-      }
+    private function cancel($id) 
+    {
+        // Cannot cancel if it has been processed.
+        if (!isset($this->handles[$id])) {
+            return false;
+        }
 
-      $entry = $this->handles[$id];
-      unset($this->handles[$id], $this->delays[$id]);
-      $entry['easy']->errno = $done['result'];
-      $entry['deferred']->resolve(
-        CurlFactory::finish(
-            $this,
-            $entry['easy'],
-            $this->factory
-        )
-      );
+        $handle = $this->handles[$id]['easy']->handle;
+        unset($this->delays[$id], $this->handles[$id]);
+        curl_multi_remove_handle($this->_mh, $handle);
+        curl_close($handle);
+
+        return true;
+    }
+
+    /**
+   *
+   */
+    private function processMessages() 
+    {
+        while ($done = curl_multi_info_read($this->_mh)) {
+            $id = (int) $done['handle'];
+            curl_multi_remove_handle($this->_mh, $done['handle']);
+
+            if (!isset($this->handles[$id])) {
+                // Probably was cancelled.
+                continue;
+            }
+
+            $entry = $this->handles[$id];
+            unset($this->handles[$id], $this->delays[$id]);
+            $entry['easy']->errno = $done['result'];
+            $entry['deferred']->resolve(
+                CurlFactory::finish(
+                    $this,
+                    $entry['easy'],
+                    $this->factory
+                )
+            );
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function timeToNext() {
-    $currentTime = microtime(TRUE);
-    $nextTime = PHP_INT_MAX;
-    foreach ($this->delays as $time) {
-      if ($time < $nextTime) {
-        $nextTime = $time;
-      }
-    }
+    private function timeToNext() 
+    {
+        $currentTime = microtime(true);
+        $nextTime = PHP_INT_MAX;
+        foreach ($this->delays as $time) {
+            if ($time < $nextTime) {
+                $nextTime = $time;
+            }
+        }
 
-    return max(0, $nextTime - $currentTime) * 1000000;
-  }
+        return max(0, $nextTime - $currentTime) * 1000000;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/CurlHandler.php
+++ PHP_CodeSniffer
@@ -11,12 +11,14 @@
  * associative array of curl option constants mapping to values in the
  * **curl** key of the "client" key of the request.
  */
-class CurlHandler {
-  /**
-   * @var CurlFactoryInterface*/
-  private $factory;
+class CurlHandler
+{
+    /**
+   * @var CurlFactoryInterface
+*/
+    private $factory;
 
-  /**
+    /**
    * Accepts an associative array of options:.
    *
    * - factory: Optional curl factory used to create cURL handles.
@@ -24,25 +26,27 @@
    * @param array $options
    *   Array of options to use with the handler.
    */
-  public function __construct(array $options = []) {
-    $this->factory = isset($options['handle_factory'])
+    public function __construct(array $options = []) 
+    {
+        $this->factory = isset($options['handle_factory'])
             ? $options['handle_factory']
             : new CurlFactory(3);
-  }
+    }
 
-  /**
+    /**
    *
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    if (isset($options['delay'])) {
-      usleep($options['delay'] * 1000);
-    }
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        if (isset($options['delay'])) {
+            usleep($options['delay'] * 1000);
+        }
 
-    $easy = $this->factory->create($request, $options);
-    curl_exec($easy->handle);
-    $easy->errno = curl_errno($easy->handle);
+        $easy = $this->factory->create($request, $options);
+        curl_exec($easy->handle);
+        $easy->errno = curl_errno($easy->handle);
 
-    return CurlFactory::finish($this, $easy, $this->factory);
-  }
+        return CurlFactory::finish($this, $easy, $this->factory);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/MockHandler.php
+++ PHP_CodeSniffer
@@ -13,18 +13,19 @@
 /**
  * Handler that returns responses or throw exceptions from a queue.
  */
-class MockHandler implements \Countable {
-  private $queue = [];
-  private $lastRequest;
-  private $lastOptions;
-  private $onFulfilled;
-  private $onRejected;
+class MockHandler implements \Countable
+{
+    private $queue = [];
+    private $lastRequest;
+    private $lastOptions;
+    private $onFulfilled;
+    private $onRejected;
 
-  /**
+    /**
    * Creates a new MockHandler that uses the default handler stack list of
    * middlewares.
    *
-   * @param array $queue
+   * @param array    $queue
    *   Array of responses, callables, or exceptions.
    * @param callable $onFulfilled
    *   Callback to invoke when the return value is fulfilled.
@@ -33,168 +34,175 @@
    *
    * @return \GuzzleHttp\HandlerStack
    */
-  public static function createWithMiddleware(
-        array $queue = NULL,
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public static function createWithMiddleware(
+        array $queue = null,
+        callable $onFulfilled = null,
+        callable $onRejected = null
     ) {
-    return HandlerStack::create(new self($queue, $onFulfilled, $onRejected));
-  }
+        return HandlerStack::create(new self($queue, $onFulfilled, $onRejected));
+    }
 
-  /**
+    /**
    * The passed in value must be an array of
    * {@see Psr7\Http\Message\ResponseInterface} objects, Exceptions,
    * callables, or Promises.
    *
-   * @param array $queue
+   * @param array    $queue
    * @param callable $onFulfilled
    *   Callback to invoke when the return value is fulfilled.
    * @param callable $onRejected
    *   Callback to invoke when the return value is rejected.
    */
-  public function __construct(
-        array $queue = NULL,
-        callable $onFulfilled = NULL,
-        callable $onRejected = NULL
+    public function __construct(
+        array $queue = null,
+        callable $onFulfilled = null,
+        callable $onRejected = null
     ) {
-    $this->onFulfilled = $onFulfilled;
-    $this->onRejected = $onRejected;
+        $this->onFulfilled = $onFulfilled;
+        $this->onRejected = $onRejected;
 
-    if ($queue) {
-      call_user_func_array([$this, 'append'], $queue);
+        if ($queue) {
+            call_user_func_array([$this, 'append'], $queue);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    if (!$this->queue) {
-      throw new \OutOfBoundsException('Mock queue is empty');
-    }
-
-    if (isset($options['delay'])) {
-      usleep($options['delay'] * 1000);
-    }
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        if (!$this->queue) {
+            throw new \OutOfBoundsException('Mock queue is empty');
+        }
 
-    $this->lastRequest = $request;
-    $this->lastOptions = $options;
-    $response = array_shift($this->queue);
+        if (isset($options['delay'])) {
+            usleep($options['delay'] * 1000);
+        }
 
-    if (isset($options['on_headers'])) {
-      if (!is_callable($options['on_headers'])) {
-        throw new \InvalidArgumentException('on_headers must be callable');
-      }
-      try {
-        $options['on_headers']($response);
-      }
-      catch (\Exception $e) {
-        $msg = 'An error was encountered during the on_headers event';
-        $response = new RequestException($msg, $request, $response, $e);
-      }
-    }
+        $this->lastRequest = $request;
+        $this->lastOptions = $options;
+        $response = array_shift($this->queue);
+
+        if (isset($options['on_headers'])) {
+            if (!is_callable($options['on_headers'])) {
+                throw new \InvalidArgumentException('on_headers must be callable');
+            }
+            try {
+                $options['on_headers']($response);
+            }
+            catch (\Exception $e) {
+                $msg = 'An error was encountered during the on_headers event';
+                $response = new RequestException($msg, $request, $response, $e);
+            }
+        }
 
-    if (is_callable($response)) {
-      $response = call_user_func($response, $request, $options);
-    }
+        if (is_callable($response)) {
+            $response = call_user_func($response, $request, $options);
+        }
 
-    $response = $response instanceof \Exception
+        $response = $response instanceof \Exception
             ? \GuzzleHttp\Promise\rejection_for($response)
             : \GuzzleHttp\Promise\promise_for($response);
 
-    return $response->then(
-        function ($value) use ($request, $options) {
-            $this->invokeStats($request, $options, $value);
-          if ($this->onFulfilled) {
-            call_user_func($this->onFulfilled, $value);
-          }
-          if (isset($options['sink'])) {
-            $contents = (string) $value->getBody();
-            $sink = $options['sink'];
-
-            if (is_resource($sink)) {
-              fwrite($sink, $contents);
-            }
-            elseif (is_string($sink)) {
-                file_put_contents($sink, $contents);
-            }
-            elseif ($sink instanceof StreamInterface) {
-                $sink->write($contents);
-            }
-          }
-
-            return $value;
-        },
-        function ($reason) use ($request, $options) {
-            $this->invokeStats($request, $options, NULL, $reason);
-          if ($this->onRejected) {
-            call_user_func($this->onRejected, $reason);
-          }
-            return \GuzzleHttp\Promise\rejection_for($reason);
-        }
-    );
-  }
+        return $response->then(
+            function ($value) use ($request, $options) {
+                $this->invokeStats($request, $options, $value);
+                if ($this->onFulfilled) {
+                    call_user_func($this->onFulfilled, $value);
+                }
+                if (isset($options['sink'])) {
+                    $contents = (string) $value->getBody();
+                    $sink = $options['sink'];
+
+                    if (is_resource($sink)) {
+                        fwrite($sink, $contents);
+                    }
+                    elseif (is_string($sink)) {
+                        file_put_contents($sink, $contents);
+                    }
+                    elseif ($sink instanceof StreamInterface) {
+                        $sink->write($contents);
+                    }
+                }
+
+                return $value;
+            },
+            function ($reason) use ($request, $options) {
+                $this->invokeStats($request, $options, null, $reason);
+                if ($this->onRejected) {
+                    call_user_func($this->onRejected, $reason);
+                }
+                return \GuzzleHttp\Promise\rejection_for($reason);
+            }
+        );
+    }
 
-  /**
+    /**
    * Adds one or more variadic requests, exceptions, callables, or promises
    * to the queue.
    */
-  public function append() {
-    foreach (func_get_args() as $value) {
-      if ($value instanceof ResponseInterface
-        || $value instanceof \Exception
-        || $value instanceof PromiseInterface
-        || is_callable($value)
-      ) {
-        $this->queue[] = $value;
-      }
-      else {
-        throw new \InvalidArgumentException('Expected a response or '
-        . 'exception. Found ' . \GuzzleHttp\describe_type($value));
-      }
+    public function append() 
+    {
+        foreach (func_get_args() as $value) {
+            if ($value instanceof ResponseInterface
+                || $value instanceof \Exception
+                || $value instanceof PromiseInterface
+                || is_callable($value)
+            ) {
+                $this->queue[] = $value;
+            }
+            else {
+                throw new \InvalidArgumentException(
+                    'Expected a response or '
+                    . 'exception. Found ' . \GuzzleHttp\describe_type($value)
+                );
+            }
+        }
     }
-  }
 
-  /**
+    /**
    * Get the last received request.
    *
    * @return \Psr\Http\Message\RequestInterface
    */
-  public function getLastRequest() {
-    return $this->lastRequest;
-  }
+    public function getLastRequest() 
+    {
+        return $this->lastRequest;
+    }
 
-  /**
+    /**
    * Get the last received request options.
    *
    * @return array
    */
-  public function getLastOptions() {
-    return $this->lastOptions;
-  }
+    public function getLastOptions() 
+    {
+        return $this->lastOptions;
+    }
 
-  /**
+    /**
    * Returns the number of remaining items in the queue.
    *
    * @return int
    */
-  public function count() {
-    return count($this->queue);
-  }
+    public function count() 
+    {
+        return count($this->queue);
+    }
 
-  /**
+    /**
    *
    */
-  private function invokeStats(
+    private function invokeStats(
         RequestInterface $request,
         array $options,
-        ResponseInterface $response = NULL,
-        $reason = NULL
+        ResponseInterface $response = null,
+        $reason = null
     ) {
-    if (isset($options['on_stats'])) {
-      $stats = new TransferStats($request, $response, 0, $reason);
-      call_user_func($options['on_stats'], $stats);
+        if (isset($options['on_stats'])) {
+            $stats = new TransferStats($request, $response, 0, $reason);
+            call_user_func($options['on_stats'], $stats);
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/Proxy.php
+++ PHP_CodeSniffer
@@ -8,9 +8,10 @@
 /**
  * Provides basic proxies for handlers.
  */
-class Proxy {
+class Proxy
+{
 
-  /**
+    /**
    * Sends synchronous requests to a specific handler while sending all other
    * requests to another handler.
    *
@@ -21,18 +22,18 @@
    *
    * @return callable Returns the composed handler.
    */
-  public static function wrapSync(
+    public static function wrapSync(
         callable $default,
         callable $sync
     ) {
-    return function (RequestInterface $request, array $options) use ($default, $sync) {
-      return empty($options[RequestOptions::SYNCHRONOUS])
+        return function (RequestInterface $request, array $options) use ($default, $sync) {
+            return empty($options[RequestOptions::SYNCHRONOUS])
                 ? $default($request, $options)
                 : $sync($request, $options);
-    };
-  }
+        };
+    }
 
-  /**
+    /**
    * Sends streaming requests to a streaming compatible handler while sending
    * all other requests to a default handler.
    *
@@ -47,15 +48,15 @@
    *
    * @return callable Returns the composed handler.
    */
-  public static function wrapStreaming(
+    public static function wrapStreaming(
         callable $default,
         callable $streaming
     ) {
-    return function (RequestInterface $request, array $options) use ($default, $streaming) {
-      return empty($options['stream'])
+        return function (RequestInterface $request, array $options) use ($default, $streaming) {
+            return empty($options['stream'])
                 ? $default($request, $options)
                 : $streaming($request, $options);
-    };
-  }
+        };
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/StreamHandler.php
+++ PHP_CodeSniffer
@@ -17,200 +17,204 @@
 /**
  * HTTP handler that uses PHP's HTTP stream wrapper.
  */
-class StreamHandler {
-  private $lastHeaders = [];
+class StreamHandler
+{
+    private $lastHeaders = [];
 
-  /**
+    /**
    * Sends an HTTP request.
    *
    * @param \Psr\Http\Message\RequestInterface $request
    *   Request to send.
-   * @param array $options
+   * @param array                              $options
    *   Request transfer options.
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    // Sleep if there is a delay specified.
-    if (isset($options['delay'])) {
-      usleep($options['delay'] * 1000);
-    }
-
-    $startTime = isset($options['on_stats']) ? microtime(TRUE) : NULL;
-
-    try {
-      // Does not support the expect header.
-      $request = $request->withoutHeader('Expect');
-
-      // Append a content-length header if body size is zero to match
-      // cURL's behavior.
-      if (0 === $request->getBody()->getSize()) {
-        $request = $request->withHeader('Content-Length', 0);
-      }
-
-      return $this->createResponse(
-        $request,
-        $options,
-        $this->createStream($request, $options),
-        $startTime
-      );
-    }
-    catch (\InvalidArgumentException $e) {
-      throw $e;
-    }
-    catch (\Exception $e) {
-      // Determine if the error was a networking error.
-      $message = $e->getMessage();
-      // This list can probably get more comprehensive.
-      // DNS lookup failed.
-      if (strpos($message, 'getaddrinfo')
-        || strpos($message, 'Connection refused')
-      // Error on HHVM.
-        || strpos($message, "couldn't connect to host")
-        ) {
-        $e = new ConnectException($e->getMessage(), $request, $e);
-      }
-      $e = RequestException::wrapException($request, $e);
-      $this->invokeStats($options, $request, $startTime, NULL, $e);
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        // Sleep if there is a delay specified.
+        if (isset($options['delay'])) {
+            usleep($options['delay'] * 1000);
+        }
+
+        $startTime = isset($options['on_stats']) ? microtime(true) : null;
+
+        try {
+            // Does not support the expect header.
+            $request = $request->withoutHeader('Expect');
+
+            // Append a content-length header if body size is zero to match
+            // cURL's behavior.
+            if (0 === $request->getBody()->getSize()) {
+                $request = $request->withHeader('Content-Length', 0);
+            }
 
-      return \GuzzleHttp\Promise\rejection_for($e);
+            return $this->createResponse(
+                $request,
+                $options,
+                $this->createStream($request, $options),
+                $startTime
+            );
+        }
+        catch (\InvalidArgumentException $e) {
+            throw $e;
+        }
+        catch (\Exception $e) {
+            // Determine if the error was a networking error.
+            $message = $e->getMessage();
+            // This list can probably get more comprehensive.
+            // DNS lookup failed.
+            if (strpos($message, 'getaddrinfo')
+                || strpos($message, 'Connection refused')
+                // Error on HHVM.
+                || strpos($message, "couldn't connect to host")
+            ) {
+                $e = new ConnectException($e->getMessage(), $request, $e);
+            }
+            $e = RequestException::wrapException($request, $e);
+            $this->invokeStats($options, $request, $startTime, null, $e);
+
+            return \GuzzleHttp\Promise\rejection_for($e);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function invokeStats(
+    private function invokeStats(
         array $options,
         RequestInterface $request,
         $startTime,
-        ResponseInterface $response = NULL,
-        $error = NULL
+        ResponseInterface $response = null,
+        $error = null
     ) {
-    if (isset($options['on_stats'])) {
-      $stats = new TransferStats(
-        $request,
-        $response,
-        microtime(TRUE) - $startTime,
-        $error,
-        []
-      );
-      call_user_func($options['on_stats'], $stats);
+        if (isset($options['on_stats'])) {
+            $stats = new TransferStats(
+                $request,
+                $response,
+                microtime(true) - $startTime,
+                $error,
+                []
+            );
+            call_user_func($options['on_stats'], $stats);
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function createResponse(
+    private function createResponse(
         RequestInterface $request,
         array $options,
         $stream,
         $startTime
     ) {
-    $hdrs = $this->lastHeaders;
-    $this->lastHeaders = [];
-    $parts = explode(' ', array_shift($hdrs), 3);
-    $ver = explode('/', $parts[0])[1];
-    $status = $parts[1];
-    $reason = isset($parts[2]) ? $parts[2] : NULL;
-    $headers = \GuzzleHttp\headers_from_lines($hdrs);
-    list ($stream, $headers) = $this->checkDecode($options, $headers, $stream);
-    $stream = Psr7\stream_for($stream);
-    $sink = $stream;
-
-    if (strcasecmp('HEAD', $request->getMethod())) {
-      $sink = $this->createSink($stream, $options);
-    }
-
-    $response = new Response($status, $headers, $sink, $ver, $reason);
-
-    if (isset($options['on_headers'])) {
-      try {
-        $options['on_headers']($response);
-      }
-      catch (\Exception $e) {
-        $msg = 'An error was encountered during the on_headers event';
-        $ex = new RequestException($msg, $request, $response, $e);
-        return \GuzzleHttp\Promise\rejection_for($ex);
-      }
-    }
-
-    // Do not drain when the request is a HEAD request because they have
-    // no body.
-    if ($sink !== $stream) {
-      $this->drain(
-        $stream,
-        $sink,
-        $response->getHeaderLine('Content-Length')
-      );
-    }
+        $hdrs = $this->lastHeaders;
+        $this->lastHeaders = [];
+        $parts = explode(' ', array_shift($hdrs), 3);
+        $ver = explode('/', $parts[0])[1];
+        $status = $parts[1];
+        $reason = isset($parts[2]) ? $parts[2] : null;
+        $headers = \GuzzleHttp\headers_from_lines($hdrs);
+        list ($stream, $headers) = $this->checkDecode($options, $headers, $stream);
+        $stream = Psr7\stream_for($stream);
+        $sink = $stream;
+
+        if (strcasecmp('HEAD', $request->getMethod())) {
+            $sink = $this->createSink($stream, $options);
+        }
 
-    $this->invokeStats($options, $request, $startTime, $response, NULL);
+        $response = new Response($status, $headers, $sink, $ver, $reason);
 
-    return new FulfilledPromise($response);
-  }
+        if (isset($options['on_headers'])) {
+            try {
+                $options['on_headers']($response);
+            }
+            catch (\Exception $e) {
+                $msg = 'An error was encountered during the on_headers event';
+                $ex = new RequestException($msg, $request, $response, $e);
+                return \GuzzleHttp\Promise\rejection_for($ex);
+            }
+        }
 
-  /**
+        // Do not drain when the request is a HEAD request because they have
+        // no body.
+        if ($sink !== $stream) {
+            $this->drain(
+                $stream,
+                $sink,
+                $response->getHeaderLine('Content-Length')
+            );
+        }
+
+        $this->invokeStats($options, $request, $startTime, $response, null);
+
+        return new FulfilledPromise($response);
+    }
+
+    /**
    *
    */
-  private function createSink(StreamInterface $stream, array $options) {
-    if (!empty($options['stream'])) {
-      return $stream;
-    }
+    private function createSink(StreamInterface $stream, array $options) 
+    {
+        if (!empty($options['stream'])) {
+            return $stream;
+        }
 
-    $sink = isset($options['sink'])
+        $sink = isset($options['sink'])
             ? $options['sink']
             : fopen('php://temp', 'r+');
 
-    return is_string($sink)
+        return is_string($sink)
             ? new LazyOpenStream($sink, 'w+')
             : Psr7\stream_for($sink);
-  }
+    }
 
-  /**
+    /**
    *
    */
-  private function checkDecode(array $options, array $headers, $stream) {
-    // Automatically decode responses when instructed.
-    if (!empty($options['decode_content'])) {
-      $normalizedKeys = \GuzzleHttp\normalize_header_keys($headers);
-      if (isset($normalizedKeys['content-encoding'])) {
-        $encoding = $headers[$normalizedKeys['content-encoding']];
-        if ($encoding[0] === 'gzip' || $encoding[0] === 'deflate') {
-          $stream = new InflateStream(
-          Psr7\stream_for($stream)
-          );
-          $headers['x-encoded-content-encoding']
-                        = $headers[$normalizedKeys['content-encoding']];
-          // Remove content-encoding header.
-          unset($headers[$normalizedKeys['content-encoding']]);
-          // Fix content-length header.
-          if (isset($normalizedKeys['content-length'])) {
-            $headers['x-encoded-content-length']
-                            = $headers[$normalizedKeys['content-length']];
-
-            $length = (int) $stream->getSize();
-            if ($length === 0) {
-              unset($headers[$normalizedKeys['content-length']]);
-            }
-            else {
-              $headers[$normalizedKeys['content-length']] = [$length];
-            }
-          }
+    private function checkDecode(array $options, array $headers, $stream) 
+    {
+        // Automatically decode responses when instructed.
+        if (!empty($options['decode_content'])) {
+            $normalizedKeys = \GuzzleHttp\normalize_header_keys($headers);
+            if (isset($normalizedKeys['content-encoding'])) {
+                $encoding = $headers[$normalizedKeys['content-encoding']];
+                if ($encoding[0] === 'gzip' || $encoding[0] === 'deflate') {
+                    $stream = new InflateStream(
+                        Psr7\stream_for($stream)
+                    );
+                    $headers['x-encoded-content-encoding']
+                                = $headers[$normalizedKeys['content-encoding']];
+                    // Remove content-encoding header.
+                    unset($headers[$normalizedKeys['content-encoding']]);
+                    // Fix content-length header.
+                    if (isset($normalizedKeys['content-length'])) {
+                              $headers['x-encoded-content-length']
+                                              = $headers[$normalizedKeys['content-length']];
+
+                              $length = (int) $stream->getSize();
+                        if ($length === 0) {
+                            unset($headers[$normalizedKeys['content-length']]);
+                        }
+                        else {
+                            $headers[$normalizedKeys['content-length']] = [$length];
+                        }
+                    }
+                }
+            }
         }
-      }
-    }
 
-    return [$stream, $headers];
-  }
+        return [$stream, $headers];
+    }
 
-  /**
+    /**
    * Drains the source stream into the "sink" client option.
    *
    * @param \Psr\Http\Message\StreamInterface $source
    * @param \Psr\Http\Message\StreamInterface $sink
-   * @param string $contentLength
+   * @param string                            $contentLength
    *   Header specifying the amount of
    *   data to read.
    *
@@ -218,28 +222,28 @@
    *
    * @throws \RuntimeException when the sink option is invalid.
    */
-  private function drain(
+    private function drain(
         StreamInterface $source,
         StreamInterface $sink,
         $contentLength
     ) {
-    // If a content-length header is provided, then stop reading once
-    // that number of bytes has been read. This can prevent infinitely
-    // reading from a stream when dealing with servers that do not honor
-    // Connection: Close headers.
-    Psr7\copy_to_stream(
-        $source,
-        $sink,
-        (strlen($contentLength) > 0 && (int) $contentLength > 0) ? (int) $contentLength : -1
-    );
+        // If a content-length header is provided, then stop reading once
+        // that number of bytes has been read. This can prevent infinitely
+        // reading from a stream when dealing with servers that do not honor
+        // Connection: Close headers.
+        Psr7\copy_to_stream(
+            $source,
+            $sink,
+            (strlen($contentLength) > 0 && (int) $contentLength > 0) ? (int) $contentLength : -1
+        );
 
-    $sink->seek(0);
-    $source->close();
+        $sink->seek(0);
+        $source->close();
 
-    return $sink;
-  }
+        return $sink;
+    }
 
-  /**
+    /**
    * Create a resource and check to ensure it was created successfully.
    *
    * @param callable $callback
@@ -249,336 +253,352 @@
    *
    * @throws \RuntimeException on error
    */
-  private function createResource(callable $callback) {
-    $errors = NULL;
-    set_error_handler(function ($_, $msg, $file, $line) use (&$errors) {
-      $errors[] = [
-        'message' => $msg,
-        'file'    => $file,
-        'line'    => $line,
-      ];
-      return TRUE;
-    });
-
-    $resource = $callback();
-    restore_error_handler();
-
-    if (!$resource) {
-      $message = 'Error creating resource: ';
-      foreach ($errors as $err) {
-        foreach ($err as $key => $value) {
-          $message .= "[$key] $value" . PHP_EOL;
-        }
-      }
-      throw new \RuntimeException(trim($message));
-    }
-
-    return $resource;
-  }
-
-  /**
-   *
-   */
-  private function createStream(RequestInterface $request, array $options) {
-    static $methods;
-    if (!$methods) {
-      $methods = array_flip(get_class_methods(__CLASS__));
-    }
-
-    // HTTP/1.1 streams using the PHP stream wrapper require a
-    // Connection: close header.
-    if ($request->getProtocolVersion() == '1.1'
-        && !$request->hasHeader('Connection')
-    ) {
-      $request = $request->withHeader('Connection', 'close');
-    }
+    private function createResource(callable $callback) 
+    {
+        $errors = null;
+        set_error_handler(
+            function ($_, $msg, $file, $line) use (&$errors) {
+                $errors[] = [
+                'message' => $msg,
+                'file'    => $file,
+                'line'    => $line,
+                ];
+                return true;
+            }
+        );
 
-    // Ensure SSL is verified by default.
-    if (!isset($options['verify'])) {
-      $options['verify'] = TRUE;
-    }
+        $resource = $callback();
+        restore_error_handler();
 
-    $params = [];
-    $context = $this->getDefaultContext($request, $options);
+        if (!$resource) {
+            $message = 'Error creating resource: ';
+            foreach ($errors as $err) {
+                foreach ($err as $key => $value) {
+                    $message .= "[$key] $value" . PHP_EOL;
+                }
+            }
+            throw new \RuntimeException(trim($message));
+        }
 
-    if (isset($options['on_headers']) && !is_callable($options['on_headers'])) {
-      throw new \InvalidArgumentException('on_headers must be callable');
+        return $resource;
     }
 
-    if (!empty($options)) {
-      foreach ($options as $key => $value) {
-        $method = "add_{$key}";
-        if (isset($methods[$method])) {
-          $this->{$method}($request, $context, $value, $params);
+    /**
+   *
+   */
+    private function createStream(RequestInterface $request, array $options) 
+    {
+        static $methods;
+        if (!$methods) {
+            $methods = array_flip(get_class_methods(__CLASS__));
         }
-      }
-    }
 
-    if (isset($options['stream_context'])) {
-      if (!is_array($options['stream_context'])) {
-        throw new \InvalidArgumentException('stream_context must be an array');
-      }
-      $context = array_replace_recursive(
-        $context,
-        $options['stream_context']
-      );
-    }
+        // HTTP/1.1 streams using the PHP stream wrapper require a
+        // Connection: close header.
+        if ($request->getProtocolVersion() == '1.1'
+            && !$request->hasHeader('Connection')
+        ) {
+            $request = $request->withHeader('Connection', 'close');
+        }
 
-    // Microsoft NTLM authentication only supported with curl handler.
-    if (isset($options['auth'])
-        && is_array($options['auth'])
-        && isset($options['auth'][2])
-        && 'ntlm' == $options['auth'][2]
-    ) {
+        // Ensure SSL is verified by default.
+        if (!isset($options['verify'])) {
+            $options['verify'] = true;
+        }
 
-      throw new \InvalidArgumentException('Microsoft NTLM authentication only supported with curl handler');
-    }
+        $params = [];
+        $context = $this->getDefaultContext($request, $options);
 
-    $uri = $this->resolveHost($request, $options);
+        if (isset($options['on_headers']) && !is_callable($options['on_headers'])) {
+            throw new \InvalidArgumentException('on_headers must be callable');
+        }
 
-    $context = $this->createResource(
-        function () use ($context, $params) {
-            return stream_context_create($context, $params);
+        if (!empty($options)) {
+            foreach ($options as $key => $value) {
+                $method = "add_{$key}";
+                if (isset($methods[$method])) {
+                    $this->{$method}($request, $context, $value, $params);
+                }
+            }
         }
-    );
 
-    return $this->createResource(
-        function () use ($uri, &$http_response_header, $context, $options) {
-            $resource = fopen((string) $uri, 'r', NULL, $context);
-            $this->lastHeaders = $http_response_header;
+        if (isset($options['stream_context'])) {
+            if (!is_array($options['stream_context'])) {
+                throw new \InvalidArgumentException('stream_context must be an array');
+            }
+            $context = array_replace_recursive(
+                $context,
+                $options['stream_context']
+            );
+        }
 
-          if (isset($options['read_timeout'])) {
-            $readTimeout = $options['read_timeout'];
-            $sec = (int) $readTimeout;
-            $usec = ($readTimeout - $sec) * 100000;
-            stream_set_timeout($resource, $sec, $usec);
-          }
+        // Microsoft NTLM authentication only supported with curl handler.
+        if (isset($options['auth'])
+            && is_array($options['auth'])
+            && isset($options['auth'][2])
+            && 'ntlm' == $options['auth'][2]
+        ) {
 
-            return $resource;
+            throw new \InvalidArgumentException('Microsoft NTLM authentication only supported with curl handler');
         }
-    );
-  }
 
-  /**
+        $uri = $this->resolveHost($request, $options);
+
+        $context = $this->createResource(
+            function () use ($context, $params) {
+                return stream_context_create($context, $params);
+            }
+        );
+
+        return $this->createResource(
+            function () use ($uri, &$http_response_header, $context, $options) {
+                $resource = fopen((string) $uri, 'r', null, $context);
+                $this->lastHeaders = $http_response_header;
+
+                if (isset($options['read_timeout'])) {
+                    $readTimeout = $options['read_timeout'];
+                    $sec = (int) $readTimeout;
+                    $usec = ($readTimeout - $sec) * 100000;
+                    stream_set_timeout($resource, $sec, $usec);
+                }
+
+                return $resource;
+            }
+        );
+    }
+
+    /**
    *
    */
-  private function resolveHost(RequestInterface $request, array $options) {
-    $uri = $request->getUri();
+    private function resolveHost(RequestInterface $request, array $options) 
+    {
+        $uri = $request->getUri();
 
-    if (isset($options['force_ip_resolve']) && !filter_var($uri->getHost(), FILTER_VALIDATE_IP)) {
-      if ('v4' === $options['force_ip_resolve']) {
-        $records = dns_get_record($uri->getHost(), DNS_A);
-        if (!isset($records[0]['ip'])) {
-          throw new ConnectException(sprintf("Could not resolve IPv4 address for host '%s'", $uri->getHost()), $request);
-        }
-        $uri = $uri->withHost($records[0]['ip']);
-      }
-      elseif ('v6' === $options['force_ip_resolve']) {
-        $records = dns_get_record($uri->getHost(), DNS_AAAA);
-        if (!isset($records[0]['ipv6'])) {
-          throw new ConnectException(sprintf("Could not resolve IPv6 address for host '%s'", $uri->getHost()), $request);
+        if (isset($options['force_ip_resolve']) && !filter_var($uri->getHost(), FILTER_VALIDATE_IP)) {
+            if ('v4' === $options['force_ip_resolve']) {
+                $records = dns_get_record($uri->getHost(), DNS_A);
+                if (!isset($records[0]['ip'])) {
+                    throw new ConnectException(sprintf("Could not resolve IPv4 address for host '%s'", $uri->getHost()), $request);
+                }
+                $uri = $uri->withHost($records[0]['ip']);
+            }
+            elseif ('v6' === $options['force_ip_resolve']) {
+                $records = dns_get_record($uri->getHost(), DNS_AAAA);
+                if (!isset($records[0]['ipv6'])) {
+                    throw new ConnectException(sprintf("Could not resolve IPv6 address for host '%s'", $uri->getHost()), $request);
+                }
+                $uri = $uri->withHost('[' . $records[0]['ipv6'] . ']');
+            }
         }
-        $uri = $uri->withHost('[' . $records[0]['ipv6'] . ']');
-      }
-    }
 
-    return $uri;
-  }
+        return $uri;
+    }
 
-  /**
+    /**
    *
    */
-  private function getDefaultContext(RequestInterface $request) {
-    $headers = '';
-    foreach ($request->getHeaders() as $name => $value) {
-      foreach ($value as $val) {
-        $headers .= "$name: $val\r\n";
-      }
-    }
+    private function getDefaultContext(RequestInterface $request) 
+    {
+        $headers = '';
+        foreach ($request->getHeaders() as $name => $value) {
+            foreach ($value as $val) {
+                $headers .= "$name: $val\r\n";
+            }
+        }
 
-    $context = [
-      'http' => [
+        $context = [
+        'http' => [
         'method'           => $request->getMethod(),
         'header'           => $headers,
         'protocol_version' => $request->getProtocolVersion(),
-        'ignore_errors'    => TRUE,
+        'ignore_errors'    => true,
         'follow_location'  => 0,
-      ],
-    ];
+        ],
+        ];
 
-    $body = (string) $request->getBody();
+        $body = (string) $request->getBody();
 
-    if (!empty($body)) {
-      $context['http']['content'] = $body;
-      // Prevent the HTTP handler from adding a Content-Type header.
-      if (!$request->hasHeader('Content-Type')) {
-        $context['http']['header'] .= "Content-Type:\r\n";
-      }
-    }
+        if (!empty($body)) {
+            $context['http']['content'] = $body;
+            // Prevent the HTTP handler from adding a Content-Type header.
+            if (!$request->hasHeader('Content-Type')) {
+                $context['http']['header'] .= "Content-Type:\r\n";
+            }
+        }
 
-    $context['http']['header'] = rtrim($context['http']['header']);
+        $context['http']['header'] = rtrim($context['http']['header']);
 
-    return $context;
-  }
+        return $context;
+    }
 
-  /**
+    /**
    *
    */
-  private function add_proxy(RequestInterface $request, &$options, $value, &$params) {
-    if (!is_array($value)) {
-      $options['http']['proxy'] = $value;
-    }
-    else {
-      $scheme = $request->getUri()->getScheme();
-      if (isset($value[$scheme])) {
-        if (!isset($value['no'])
-        || !\GuzzleHttp\is_host_in_noproxy(
-            $request->getUri()->getHost(),
-            $value['no']
-        )
-        ) {
-          $options['http']['proxy'] = $value[$scheme];
+    private function add_proxy(RequestInterface $request, &$options, $value, &$params) 
+    {
+        if (!is_array($value)) {
+            $options['http']['proxy'] = $value;
+        }
+        else {
+            $scheme = $request->getUri()->getScheme();
+            if (isset($value[$scheme])) {
+                if (!isset($value['no'])
+                    || !\GuzzleHttp\is_host_in_noproxy(
+                        $request->getUri()->getHost(),
+                        $value['no']
+                    )
+                ) {
+                    $options['http']['proxy'] = $value[$scheme];
+                }
+            }
         }
-      }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function add_timeout(RequestInterface $request, &$options, $value, &$params) {
-    if ($value > 0) {
-      $options['http']['timeout'] = $value;
+    private function add_timeout(RequestInterface $request, &$options, $value, &$params) 
+    {
+        if ($value > 0) {
+            $options['http']['timeout'] = $value;
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function add_verify(RequestInterface $request, &$options, $value, &$params) {
-    if ($value === TRUE) {
-      // PHP 5.6 or greater will find the system cert by default. When
-      // < 5.6, use the Guzzle bundled cacert.
-      if (PHP_VERSION_ID < 50600) {
-        $options['ssl']['cafile'] = \GuzzleHttp\default_ca_bundle();
-      }
-    }
-    elseif (is_string($value)) {
-      $options['ssl']['cafile'] = $value;
-      if (!file_exists($value)) {
-        throw new \RuntimeException("SSL CA bundle not found: $value");
-      }
-    }
-    elseif ($value === FALSE) {
-      $options['ssl']['verify_peer'] = FALSE;
-      $options['ssl']['verify_peer_name'] = FALSE;
-      return;
-    }
-    else {
-      throw new \InvalidArgumentException('Invalid verify request option');
-    }
+    private function add_verify(RequestInterface $request, &$options, $value, &$params) 
+    {
+        if ($value === true) {
+            // PHP 5.6 or greater will find the system cert by default. When
+            // < 5.6, use the Guzzle bundled cacert.
+            if (PHP_VERSION_ID < 50600) {
+                $options['ssl']['cafile'] = \GuzzleHttp\default_ca_bundle();
+            }
+        }
+        elseif (is_string($value)) {
+            $options['ssl']['cafile'] = $value;
+            if (!file_exists($value)) {
+                throw new \RuntimeException("SSL CA bundle not found: $value");
+            }
+        }
+        elseif ($value === false) {
+            $options['ssl']['verify_peer'] = false;
+            $options['ssl']['verify_peer_name'] = false;
+            return;
+        }
+        else {
+            throw new \InvalidArgumentException('Invalid verify request option');
+        }
 
-    $options['ssl']['verify_peer'] = TRUE;
-    $options['ssl']['verify_peer_name'] = TRUE;
-    $options['ssl']['allow_self_signed'] = FALSE;
-  }
+        $options['ssl']['verify_peer'] = true;
+        $options['ssl']['verify_peer_name'] = true;
+        $options['ssl']['allow_self_signed'] = false;
+    }
 
-  /**
+    /**
    *
    */
-  private function add_cert(RequestInterface $request, &$options, $value, &$params) {
-    if (is_array($value)) {
-      $options['ssl']['passphrase'] = $value[1];
-      $value = $value[0];
-    }
+    private function add_cert(RequestInterface $request, &$options, $value, &$params) 
+    {
+        if (is_array($value)) {
+            $options['ssl']['passphrase'] = $value[1];
+            $value = $value[0];
+        }
 
-    if (!file_exists($value)) {
-      throw new \RuntimeException("SSL certificate not found: {$value}");
-    }
+        if (!file_exists($value)) {
+            throw new \RuntimeException("SSL certificate not found: {$value}");
+        }
 
-    $options['ssl']['local_cert'] = $value;
-  }
+        $options['ssl']['local_cert'] = $value;
+    }
 
-  /**
+    /**
    *
    */
-  private function add_progress(RequestInterface $request, &$options, $value, &$params) {
-    $this->addNotification(
-        $params,
-        function ($code, $a, $b, $c, $transferred, $total) use ($value) {
-          if ($code == STREAM_NOTIFY_PROGRESS) {
-              $value($total, $transferred, NULL, NULL);
-          }
-        }
-    );
-  }
+    private function add_progress(RequestInterface $request, &$options, $value, &$params) 
+    {
+        $this->addNotification(
+            $params,
+            function ($code, $a, $b, $c, $transferred, $total) use ($value) {
+                if ($code == STREAM_NOTIFY_PROGRESS) {
+                    $value($total, $transferred, null, null);
+                }
+            }
+        );
+    }
 
-  /**
+    /**
    *
    */
-  private function add_debug(RequestInterface $request, &$options, $value, &$params) {
-    if ($value === FALSE) {
-      return;
-    }
-
-    static $map = [
-      STREAM_NOTIFY_CONNECT       => 'CONNECT',
-      STREAM_NOTIFY_AUTH_REQUIRED => 'AUTH_REQUIRED',
-      STREAM_NOTIFY_AUTH_RESULT   => 'AUTH_RESULT',
-      STREAM_NOTIFY_MIME_TYPE_IS  => 'MIME_TYPE_IS',
-      STREAM_NOTIFY_FILE_SIZE_IS  => 'FILE_SIZE_IS',
-      STREAM_NOTIFY_REDIRECTED    => 'REDIRECTED',
-      STREAM_NOTIFY_PROGRESS      => 'PROGRESS',
-      STREAM_NOTIFY_FAILURE       => 'FAILURE',
-      STREAM_NOTIFY_COMPLETED     => 'COMPLETED',
-      STREAM_NOTIFY_RESOLVE       => 'RESOLVE',
-    ];
-    static $args = ['severity', 'message', 'message_code',
-      'bytes_transferred', 'bytes_max',
-    ];
-
-    $value = \GuzzleHttp\debug_resource($value);
-    $ident = $request->getMethod() . ' ' . $request->getUri()->withFragment('');
-    $this->addNotification(
-        $params,
-        function () use ($ident, $value, $map, $args) {
-            $passed = func_get_args();
-            $code = array_shift($passed);
-            fprintf($value, '<%s> [%s] ', $ident, $map[$code]);
-          foreach (array_filter($passed) as $i => $v) {
-            fwrite($value, $args[$i] . ': "' . $v . '" ');
-          }
-            fwrite($value, "\n");
+    private function add_debug(RequestInterface $request, &$options, $value, &$params) 
+    {
+        if ($value === false) {
+            return;
         }
-    );
-  }
 
-  /**
+        static $map = [
+        STREAM_NOTIFY_CONNECT       => 'CONNECT',
+        STREAM_NOTIFY_AUTH_REQUIRED => 'AUTH_REQUIRED',
+        STREAM_NOTIFY_AUTH_RESULT   => 'AUTH_RESULT',
+        STREAM_NOTIFY_MIME_TYPE_IS  => 'MIME_TYPE_IS',
+        STREAM_NOTIFY_FILE_SIZE_IS  => 'FILE_SIZE_IS',
+        STREAM_NOTIFY_REDIRECTED    => 'REDIRECTED',
+        STREAM_NOTIFY_PROGRESS      => 'PROGRESS',
+        STREAM_NOTIFY_FAILURE       => 'FAILURE',
+        STREAM_NOTIFY_COMPLETED     => 'COMPLETED',
+        STREAM_NOTIFY_RESOLVE       => 'RESOLVE',
+        ];
+        static $args = ['severity', 'message', 'message_code',
+        'bytes_transferred', 'bytes_max',
+        ];
+
+        $value = \GuzzleHttp\debug_resource($value);
+        $ident = $request->getMethod() . ' ' . $request->getUri()->withFragment('');
+        $this->addNotification(
+            $params,
+            function () use ($ident, $value, $map, $args) {
+                $passed = func_get_args();
+                $code = array_shift($passed);
+                fprintf($value, '<%s> [%s] ', $ident, $map[$code]);
+                foreach (array_filter($passed) as $i => $v) {
+                    fwrite($value, $args[$i] . ': "' . $v . '" ');
+                }
+                fwrite($value, "\n");
+            }
+        );
+    }
+
+    /**
    *
    */
-  private function addNotification(array &$params, callable $notify) {
-    // Wrap the existing function if needed.
-    if (!isset($params['notification'])) {
-      $params['notification'] = $notify;
-    }
-    else {
-      $params['notification'] = $this->callArray([
-        $params['notification'],
-        $notify,
-      ]);
+    private function addNotification(array &$params, callable $notify) 
+    {
+        // Wrap the existing function if needed.
+        if (!isset($params['notification'])) {
+            $params['notification'] = $notify;
+        }
+        else {
+            $params['notification'] = $this->callArray(
+                [
+                $params['notification'],
+                $notify,
+                ]
+            );
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  private function callArray(array $functions) {
-    return function () use ($functions) {
-      $args = func_get_args();
-      foreach ($functions as $fn) {
-        call_user_func_array($fn, $args);
-      }
-    };
-  }
+    private function callArray(array $functions) 
+    {
+        return function () use ($functions) {
+            $args = func_get_args();
+            foreach ($functions as $fn) {
+                call_user_func_array($fn, $args);
+            }
+        };
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Handler/CurlFactoryInterface.php
+++ PHP_CodeSniffer
@@ -7,29 +7,30 @@
 /**
  *
  */
-interface CurlFactoryInterface {
+interface CurlFactoryInterface
+{
 
-  /**
+    /**
    * Creates a cURL handle resource.
    *
    * @param \Psr\Http\Message\RequestInterface $request
    *   Request.
-   * @param array $options
+   * @param array                              $options
    *   Transfer options.
    *
    * @return EasyHandle
    *
    * @throws \RuntimeException when an option cannot be applied
    */
-  public function create(RequestInterface $request, array $options);
+    public function create(RequestInterface $request, array $options);
 
-  /**
+    /**
    * Release an easy handle, allowing it to be reused or closed.
    *
    * This function must call unset on the easy handle's "handle" property.
    *
    * @param EasyHandle $easy
    */
-  public function release(EasyHandle $easy);
+    public function release(EasyHandle $easy);
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/functions_include.php
+++ PHP_CodeSniffer
@@ -6,5 +6,5 @@
  */
 
 if (!function_exists('GuzzleHttp\uri_template')) {
-  require __DIR__ . '/functions.php';
+    include __DIR__ . '/functions.php';
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/UriTemplate.php
+++ PHP_CodeSniffer
@@ -7,60 +7,67 @@
  *
  * @link http://tools.ietf.org/html/rfc6570
  */
-class UriTemplate {
-  /**
-   * @var stringURItemplate*/
-  private $template;
-
-  /**
-   * @var arrayVariablestouseinthetemplateexpansion*/
-  private $variables;
-
-  /**
-   * @var arrayHashforquickoperatorlookups*/
-  private static $operatorHash = [
-    ''  => ['prefix' => '', 'joiner' => ',', 'query' => FALSE],
-    '+' => ['prefix' => '', 'joiner' => ',', 'query' => FALSE],
-    '#' => ['prefix' => '#', 'joiner' => ',', 'query' => FALSE],
-    '.' => ['prefix' => '.', 'joiner' => '.', 'query' => FALSE],
-    '/' => ['prefix' => '/', 'joiner' => '/', 'query' => FALSE],
-    ';' => ['prefix' => ';', 'joiner' => ';', 'query' => TRUE],
-    '?' => ['prefix' => '?', 'joiner' => '&', 'query' => TRUE],
-    '&' => ['prefix' => '&', 'joiner' => '&', 'query' => TRUE],
-  ];
-
-  /**
-   * @var arrayDelimiters*/
-  private static $delims = [':', '/', '?', '#', '[', ']', '@', '!', '$',
+class UriTemplate
+{
+    /**
+   * @var stringURItemplate
+*/
+    private $template;
+
+    /**
+   * @var arrayVariablestouseinthetemplateexpansion
+*/
+    private $variables;
+
+    /**
+   * @var arrayHashforquickoperatorlookups
+*/
+    private static $operatorHash = [
+    ''  => ['prefix' => '', 'joiner' => ',', 'query' => false],
+    '+' => ['prefix' => '', 'joiner' => ',', 'query' => false],
+    '#' => ['prefix' => '#', 'joiner' => ',', 'query' => false],
+    '.' => ['prefix' => '.', 'joiner' => '.', 'query' => false],
+    '/' => ['prefix' => '/', 'joiner' => '/', 'query' => false],
+    ';' => ['prefix' => ';', 'joiner' => ';', 'query' => true],
+    '?' => ['prefix' => '?', 'joiner' => '&', 'query' => true],
+    '&' => ['prefix' => '&', 'joiner' => '&', 'query' => true],
+    ];
+
+    /**
+   * @var arrayDelimiters
+*/
+    private static $delims = [':', '/', '?', '#', '[', ']', '@', '!', '$',
     '&', '\'', '(', ')', '*', '+', ',', ';', '=',
-  ];
+    ];
 
-  /**
-   * @var arrayPercentencodeddelimiters*/
-  private static $delimsPct = ['%3A', '%2F', '%3F', '%23', '%5B', '%5D',
+    /**
+   * @var arrayPercentencodeddelimiters
+*/
+    private static $delimsPct = ['%3A', '%2F', '%3F', '%23', '%5B', '%5D',
     '%40', '%21', '%24', '%26', '%27', '%28', '%29', '%2A', '%2B', '%2C',
     '%3B', '%3D',
-  ];
+    ];
 
-  /**
+    /**
    *
    */
-  public function expand($template, array $variables) {
-    if (FALSE === strpos($template, '{')) {
-      return $template;
-    }
+    public function expand($template, array $variables) 
+    {
+        if (false === strpos($template, '{')) {
+            return $template;
+        }
 
-    $this->template = $template;
-    $this->variables = $variables;
+        $this->template = $template;
+        $this->variables = $variables;
 
-    return preg_replace_callback(
-        '/\{([^\}]+)\}/',
-        [$this, 'expandMatch'],
-        $this->template
-    );
-  }
+        return preg_replace_callback(
+            '/\{([^\}]+)\}/',
+            [$this, 'expandMatch'],
+            $this->template
+        );
+    }
 
-  /**
+    /**
    * Parse an expression into parts.
    *
    * @param string $expression
@@ -68,40 +75,41 @@
    *
    * @return array Returns an associative array of parts
    */
-  private function parseExpression($expression) {
-    $result = [];
+    private function parseExpression($expression) 
+    {
+        $result = [];
+
+        if (isset(self::$operatorHash[$expression[0]])) {
+            $result['operator'] = $expression[0];
+            $expression = substr($expression, 1);
+        }
+        else {
+            $result['operator'] = '';
+        }
 
-    if (isset(self::$operatorHash[$expression[0]])) {
-      $result['operator'] = $expression[0];
-      $expression = substr($expression, 1);
-    }
-    else {
-      $result['operator'] = '';
-    }
+        foreach (explode(',', $expression) as $value) {
+            $value = trim($value);
+            $varspec = [];
+            if ($colonPos = strpos($value, ':')) {
+                $varspec['value'] = substr($value, 0, $colonPos);
+                $varspec['modifier'] = ':';
+                $varspec['position'] = (int) substr($value, $colonPos + 1);
+            }
+            elseif (substr($value, -1) === '*') {
+                $varspec['modifier'] = '*';
+                $varspec['value'] = substr($value, 0, -1);
+            }
+            else {
+                $varspec['value'] = (string) $value;
+                $varspec['modifier'] = '';
+            }
+            $result['values'][] = $varspec;
+        }
 
-    foreach (explode(',', $expression) as $value) {
-      $value = trim($value);
-      $varspec = [];
-      if ($colonPos = strpos($value, ':')) {
-        $varspec['value'] = substr($value, 0, $colonPos);
-        $varspec['modifier'] = ':';
-        $varspec['position'] = (int) substr($value, $colonPos + 1);
-      }
-      elseif (substr($value, -1) === '*') {
-        $varspec['modifier'] = '*';
-        $varspec['value'] = substr($value, 0, -1);
-      }
-      else {
-        $varspec['value'] = (string) $value;
-        $varspec['modifier'] = '';
-      }
-      $result['values'][] = $varspec;
+        return $result;
     }
 
-    return $result;
-  }
-
-  /**
+    /**
    * Process an expansion.
    *
    * @param array $matches
@@ -109,126 +117,127 @@
    *
    * @return string Returns the replacement string
    */
-  private function expandMatch(array $matches) {
-    static $rfc1738to3986 = ['+' => '%20', '%7e' => '~'];
+    private function expandMatch(array $matches) 
+    {
+        static $rfc1738to3986 = ['+' => '%20', '%7e' => '~'];
+
+        $replacements = [];
+        $parsed = self::parseExpression($matches[1]);
+        $prefix = self::$operatorHash[$parsed['operator']]['prefix'];
+        $joiner = self::$operatorHash[$parsed['operator']]['joiner'];
+        $useQuery = self::$operatorHash[$parsed['operator']]['query'];
 
-    $replacements = [];
-    $parsed = self::parseExpression($matches[1]);
-    $prefix = self::$operatorHash[$parsed['operator']]['prefix'];
-    $joiner = self::$operatorHash[$parsed['operator']]['joiner'];
-    $useQuery = self::$operatorHash[$parsed['operator']]['query'];
-
-    foreach ($parsed['values'] as $value) {
-
-      if (!isset($this->variables[$value['value']])) {
-        continue;
-      }
-
-      $variable = $this->variables[$value['value']];
-      $actuallyUseQuery = $useQuery;
-      $expanded = '';
-
-      if (is_array($variable)) {
-
-        $isAssoc = $this->isAssoc($variable);
-        $kvp = [];
-        foreach ($variable as $key => $var) {
-
-          if ($isAssoc) {
-            $key = rawurlencode($key);
-            $isNestedArray = is_array($var);
-          }
-          else {
-            $isNestedArray = FALSE;
-          }
-
-          if (!$isNestedArray) {
-            $var = rawurlencode($var);
-            if ($parsed['operator'] === '+' ||
-            $parsed['operator'] === '#'
-            ) {
-              $var = $this->decodeReserved($var);
-            }
-          }
-
-          if ($value['modifier'] === '*') {
-            if ($isAssoc) {
-              if ($isNestedArray) {
-                // Nested arrays must allow for deeply nested
-                // structures.
-                $var = strtr(
-                http_build_query([$key => $var]),
-                $rfc1738to3986
-                );
-              }
-              else {
-                $var = $key . '=' . $var;
-              }
-            }
-            elseif ($key > 0 && $actuallyUseQuery) {
-              $var = $value['value'] . '=' . $var;
-            }
-          }
-
-          $kvp[$key] = $var;
-        }
-
-        if (empty($variable)) {
-          $actuallyUseQuery = FALSE;
-        }
-        elseif ($value['modifier'] === '*') {
-          $expanded = implode($joiner, $kvp);
-          if ($isAssoc) {
-            // Don't prepend the value name when using the explode
-            // modifier with an associative array.
-            $actuallyUseQuery = FALSE;
-          }
-        }
-        else {
-          if ($isAssoc) {
-            // When an associative array is encountered and the
-            // explode modifier is not set, then the result must be
-            // a comma separated list of keys followed by their
-            // respective values.
-            foreach ($kvp as $k => &$v) {
-              $v = $k . ',' . $v;
-            }
-          }
-          $expanded = implode(',', $kvp);
-        }
-
-      }
-      else {
-        if ($value['modifier'] === ':') {
-          $variable = substr($variable, 0, $value['position']);
-        }
-        $expanded = rawurlencode($variable);
-        if ($parsed['operator'] === '+' || $parsed['operator'] === '#') {
-          $expanded = $this->decodeReserved($expanded);
-        }
-      }
-
-      if ($actuallyUseQuery) {
-        if (!$expanded && $joiner !== '&') {
-          $expanded = $value['value'];
-        }
-        else {
-          $expanded = $value['value'] . '=' . $expanded;
+        foreach ($parsed['values'] as $value) {
+
+            if (!isset($this->variables[$value['value']])) {
+                continue;
+            }
+
+            $variable = $this->variables[$value['value']];
+            $actuallyUseQuery = $useQuery;
+            $expanded = '';
+
+            if (is_array($variable)) {
+
+                $isAssoc = $this->isAssoc($variable);
+                $kvp = [];
+                foreach ($variable as $key => $var) {
+
+                    if ($isAssoc) {
+                        $key = rawurlencode($key);
+                        $isNestedArray = is_array($var);
+                    }
+                    else {
+                        $isNestedArray = false;
+                    }
+
+                    if (!$isNestedArray) {
+                        $var = rawurlencode($var);
+                        if ($parsed['operator'] === '+' 
+                            || $parsed['operator'] === '#'
+                        ) {
+                            $var = $this->decodeReserved($var);
+                        }
+                    }
+
+                    if ($value['modifier'] === '*') {
+                        if ($isAssoc) {
+                            if ($isNestedArray) {
+                                // Nested arrays must allow for deeply nested
+                                // structures.
+                                $var = strtr(
+                                    http_build_query([$key => $var]),
+                                    $rfc1738to3986
+                                );
+                            }
+                            else {
+                                $var = $key . '=' . $var;
+                            }
+                        }
+                        elseif ($key > 0 && $actuallyUseQuery) {
+                            $var = $value['value'] . '=' . $var;
+                        }
+                    }
+
+                    $kvp[$key] = $var;
+                }
+
+                if (empty($variable)) {
+                    $actuallyUseQuery = false;
+                }
+                elseif ($value['modifier'] === '*') {
+                    $expanded = implode($joiner, $kvp);
+                    if ($isAssoc) {
+                        // Don't prepend the value name when using the explode
+                        // modifier with an associative array.
+                        $actuallyUseQuery = false;
+                    }
+                }
+                else {
+                    if ($isAssoc) {
+                        // When an associative array is encountered and the
+                        // explode modifier is not set, then the result must be
+                        // a comma separated list of keys followed by their
+                        // respective values.
+                        foreach ($kvp as $k => &$v) {
+                            $v = $k . ',' . $v;
+                        }
+                    }
+                    $expanded = implode(',', $kvp);
+                }
+
+            }
+            else {
+                if ($value['modifier'] === ':') {
+                    $variable = substr($variable, 0, $value['position']);
+                }
+                $expanded = rawurlencode($variable);
+                if ($parsed['operator'] === '+' || $parsed['operator'] === '#') {
+                    $expanded = $this->decodeReserved($expanded);
+                }
+            }
+
+            if ($actuallyUseQuery) {
+                if (!$expanded && $joiner !== '&') {
+                    $expanded = $value['value'];
+                }
+                else {
+                    $expanded = $value['value'] . '=' . $expanded;
+                }
+            }
+
+            $replacements[] = $expanded;
         }
-      }
 
-      $replacements[] = $expanded;
-    }
+        $ret = implode($joiner, $replacements);
+        if ($ret && $prefix) {
+            return $prefix . $ret;
+        }
 
-    $ret = implode($joiner, $replacements);
-    if ($ret && $prefix) {
-      return $prefix . $ret;
+        return $ret;
     }
 
-    return $ret;
-  }
-
-  /**
+    /**
    * Determines if an array is associative.
    *
    * This makes the assumption that input arrays are sequences or hashes.
@@ -241,11 +250,12 @@
    *
    * @return bool
    */
-  private function isAssoc(array $array) {
-    return $array && array_keys($array)[0] !== 0;
-  }
+    private function isAssoc(array $array) 
+    {
+        return $array && array_keys($array)[0] !== 0;
+    }
 
-  /**
+    /**
    * Removes percent encoding on reserved characters (used with + and #
    * modifiers).
    *
@@ -254,8 +264,9 @@
    *
    * @return string
    */
-  private function decodeReserved($string) {
-    return str_replace(self::$delimsPct, self::$delims, $string);
-  }
+    private function decodeReserved($string) 
+    {
+        return str_replace(self::$delimsPct, self::$delims, $string);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/RedirectMiddleware.php
+++ PHP_CodeSniffer
@@ -16,230 +16,240 @@
  * Apply this middleware like other middleware using
  * {@see GuzzleHttp\Middleware::redirect()}.
  */
-class RedirectMiddleware {
-  const HISTORY_HEADER = 'X-Guzzle-Redirect-History';
+class RedirectMiddleware
+{
+    const HISTORY_HEADER = 'X-Guzzle-Redirect-History';
 
-  const STATUS_HISTORY_HEADER = 'X-Guzzle-Redirect-Status-History';
+    const STATUS_HISTORY_HEADER = 'X-Guzzle-Redirect-Status-History';
 
-  public static $defaultSettings = [
+    public static $defaultSettings = [
     'max'             => 5,
     'protocols'       => ['http', 'https'],
-    'strict'          => FALSE,
-    'referer'         => FALSE,
-    'track_redirects' => FALSE,
-  ];
-
-  /**
-   * @var callable*/
-  private $nextHandler;
+    'strict'          => false,
+    'referer'         => false,
+    'track_redirects' => false,
+    ];
+
+    /**
+   * @var callable
+*/
+    private $nextHandler;
 
-  /**
+    /**
    * @param callable $nextHandler
    *   Next handler to invoke.
    */
-  public function __construct(callable $nextHandler) {
-    $this->nextHandler = $nextHandler;
-  }
+    public function __construct(callable $nextHandler) 
+    {
+        $this->nextHandler = $nextHandler;
+    }
 
-  /**
+    /**
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    $fn = $this->nextHandler;
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        $fn = $this->nextHandler;
 
-    if (empty($options['allow_redirects'])) {
-      return $fn($request, $options);
-    }
+        if (empty($options['allow_redirects'])) {
+            return $fn($request, $options);
+        }
 
-    if ($options['allow_redirects'] === TRUE) {
-      $options['allow_redirects'] = self::$defaultSettings;
-    }
-    elseif (!is_array($options['allow_redirects'])) {
-      throw new \InvalidArgumentException('allow_redirects must be true, false, or array');
-    }
-    else {
-      // Merge the default settings with the provided settings.
-      $options['allow_redirects'] += self::$defaultSettings;
-    }
+        if ($options['allow_redirects'] === true) {
+            $options['allow_redirects'] = self::$defaultSettings;
+        }
+        elseif (!is_array($options['allow_redirects'])) {
+            throw new \InvalidArgumentException('allow_redirects must be true, false, or array');
+        }
+        else {
+            // Merge the default settings with the provided settings.
+            $options['allow_redirects'] += self::$defaultSettings;
+        }
 
-    if (empty($options['allow_redirects']['max'])) {
-      return $fn($request, $options);
-    }
+        if (empty($options['allow_redirects']['max'])) {
+            return $fn($request, $options);
+        }
 
-    return $fn($request, $options)
-      ->then(function (ResponseInterface $response) use ($request, $options) {
+        return $fn($request, $options)
+        ->then(
+            function (ResponseInterface $response) use ($request, $options) {
                 return $this->checkRedirect($request, $options, $response);
-      });
-  }
+            }
+        );
+    }
 
-  /**
-   * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+    /**
+   * @param \Psr\Http\Message\RequestInterface                   $request
+   * @param array                                                $options
    * @param \Psr\Http\Message\ResponseInterface|PromiseInterface $response
    *
    * @return \Psr\Http\Message\ResponseInterface|PromiseInterface
    */
-  public function checkRedirect(
+    public function checkRedirect(
         RequestInterface $request,
         array $options,
         ResponseInterface $response
     ) {
-    if (substr($response->getStatusCode(), 0, 1) != '3'
-        || !$response->hasHeader('Location')
-    ) {
-      return $response;
-    }
+        if (substr($response->getStatusCode(), 0, 1) != '3'
+            || !$response->hasHeader('Location')
+        ) {
+            return $response;
+        }
 
-    $this->guardMax($request, $options);
-    $nextRequest = $this->modifyRequest($request, $options, $response);
+        $this->guardMax($request, $options);
+        $nextRequest = $this->modifyRequest($request, $options, $response);
 
-    if (isset($options['allow_redirects']['on_redirect'])) {
-      call_user_func(
-        $options['allow_redirects']['on_redirect'],
-        $request,
-        $response,
-        $nextRequest->getUri()
-      );
-    }
+        if (isset($options['allow_redirects']['on_redirect'])) {
+            call_user_func(
+                $options['allow_redirects']['on_redirect'],
+                $request,
+                $response,
+                $nextRequest->getUri()
+            );
+        }
 
-    /** @var \GuzzleHttp\Promise\PromiseInterface|ResponseInterface $promise */
-    $promise = $this($nextRequest, $options);
+        /**
+ * @var \GuzzleHttp\Promise\PromiseInterface|ResponseInterface $promise 
+*/
+        $promise = $this($nextRequest, $options);
+
+        // Add headers to be able to track history of redirects.
+        if (!empty($options['allow_redirects']['track_redirects'])) {
+            return $this->withTracking(
+                $promise,
+                (string) $nextRequest->getUri(),
+                $response->getStatusCode()
+            );
+        }
 
-    // Add headers to be able to track history of redirects.
-    if (!empty($options['allow_redirects']['track_redirects'])) {
-      return $this->withTracking(
-        $promise,
-        (string) $nextRequest->getUri(),
-        $response->getStatusCode()
-      );
+        return $promise;
     }
 
-    return $promise;
-  }
-
-  /**
+    /**
    *
    */
-  private function withTracking(PromiseInterface $promise, $uri, $statusCode) {
-    return $promise->then(
-        function (ResponseInterface $response) use ($uri, $statusCode) {
-            // Note that we are pushing to the front of the list as this
-            // would be an earlier response than what is currently present
-            // in the history header.
-            $historyHeader = $response->getHeader(self::HISTORY_HEADER);
-            $statusHeader = $response->getHeader(self::STATUS_HISTORY_HEADER);
-            array_unshift($historyHeader, $uri);
-            array_unshift($statusHeader, $statusCode);
-            return $response->withHeader(self::HISTORY_HEADER, $historyHeader)
-              ->withHeader(self::STATUS_HISTORY_HEADER, $statusHeader);
-        }
-    );
-  }
+    private function withTracking(PromiseInterface $promise, $uri, $statusCode) 
+    {
+        return $promise->then(
+            function (ResponseInterface $response) use ($uri, $statusCode) {
+                // Note that we are pushing to the front of the list as this
+                // would be an earlier response than what is currently present
+                // in the history header.
+                $historyHeader = $response->getHeader(self::HISTORY_HEADER);
+                $statusHeader = $response->getHeader(self::STATUS_HISTORY_HEADER);
+                array_unshift($historyHeader, $uri);
+                array_unshift($statusHeader, $statusCode);
+                return $response->withHeader(self::HISTORY_HEADER, $historyHeader)
+                    ->withHeader(self::STATUS_HISTORY_HEADER, $statusHeader);
+            }
+        );
+    }
 
-  /**
+    /**
    *
    */
-  private function guardMax(RequestInterface $request, array &$options) {
-    $current = isset($options['__redirect_count'])
+    private function guardMax(RequestInterface $request, array &$options) 
+    {
+        $current = isset($options['__redirect_count'])
             ? $options['__redirect_count']
             : 0;
-    $options['__redirect_count'] = $current + 1;
-    $max = $options['allow_redirects']['max'];
+        $options['__redirect_count'] = $current + 1;
+        $max = $options['allow_redirects']['max'];
 
-    if ($options['__redirect_count'] > $max) {
-      throw new TooManyRedirectsException(
-        "Will not follow more than {$max} redirects",
-        $request
-      );
+        if ($options['__redirect_count'] > $max) {
+            throw new TooManyRedirectsException(
+                "Will not follow more than {$max} redirects",
+                $request
+            );
+        }
     }
-  }
 
-  /**
-   * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+    /**
+   * @param \Psr\Http\Message\RequestInterface  $request
+   * @param array                               $options
    * @param \Psr\Http\Message\ResponseInterface $response
    *
    * @return \Psr\Http\Message\RequestInterface
    */
-  public function modifyRequest(
+    public function modifyRequest(
         RequestInterface $request,
         array $options,
         ResponseInterface $response
     ) {
-    // Request modifications to apply.
-    $modify = [];
-    $protocols = $options['allow_redirects']['protocols'];
-
-    // Use a GET request if this is an entity enclosing request and we are
-    // not forcing RFC compliance, but rather emulating what all browsers
-    // would do.
-    $statusCode = $response->getStatusCode();
-    if ($statusCode == 303 ||
-        ($statusCode <= 302 && $request->getBody() && !$options['allow_redirects']['strict'])
-    ) {
-      $modify['method'] = 'GET';
-      $modify['body'] = '';
-    }
+        // Request modifications to apply.
+        $modify = [];
+        $protocols = $options['allow_redirects']['protocols'];
+
+        // Use a GET request if this is an entity enclosing request and we are
+        // not forcing RFC compliance, but rather emulating what all browsers
+        // would do.
+        $statusCode = $response->getStatusCode();
+        if ($statusCode == 303 
+            || ($statusCode <= 302 && $request->getBody() && !$options['allow_redirects']['strict'])
+        ) {
+            $modify['method'] = 'GET';
+            $modify['body'] = '';
+        }
 
-    $modify['uri'] = $this->redirectUri($request, $response, $protocols);
-    Psr7\rewind_body($request);
+        $modify['uri'] = $this->redirectUri($request, $response, $protocols);
+        Psr7\rewind_body($request);
 
-    // Add the Referer header if it is told to do so and only
-    // add the header if we are not redirecting from https to http.
-    if ($options['allow_redirects']['referer']
-        && $modify['uri']->getScheme() === $request->getUri()->getScheme()
-    ) {
-      $uri = $request->getUri()->withUserInfo('', '');
-      $modify['set_headers']['Referer'] = (string) $uri;
-    }
-    else {
-      $modify['remove_headers'][] = 'Referer';
-    }
+        // Add the Referer header if it is told to do so and only
+        // add the header if we are not redirecting from https to http.
+        if ($options['allow_redirects']['referer']
+            && $modify['uri']->getScheme() === $request->getUri()->getScheme()
+        ) {
+            $uri = $request->getUri()->withUserInfo('', '');
+            $modify['set_headers']['Referer'] = (string) $uri;
+        }
+        else {
+            $modify['remove_headers'][] = 'Referer';
+        }
 
-    // Remove Authorization header if host is different.
-    if ($request->getUri()->getHost() !== $modify['uri']->getHost()) {
-      $modify['remove_headers'][] = 'Authorization';
-    }
+        // Remove Authorization header if host is different.
+        if ($request->getUri()->getHost() !== $modify['uri']->getHost()) {
+            $modify['remove_headers'][] = 'Authorization';
+        }
 
-    return Psr7\modify_request($request, $modify);
-  }
+        return Psr7\modify_request($request, $modify);
+    }
 
-  /**
+    /**
    * Set the appropriate URL on the request based on the location header.
    *
-   * @param \Psr\Http\Message\RequestInterface $request
+   * @param \Psr\Http\Message\RequestInterface  $request
    * @param \Psr\Http\Message\ResponseInterface $response
-   * @param array $protocols
+   * @param array                               $protocols
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  private function redirectUri(
+    private function redirectUri(
         RequestInterface $request,
         ResponseInterface $response,
         array $protocols
     ) {
-    $location = UriResolver::resolve(
-        $request->getUri(),
-        new Uri($response->getHeaderLine('Location'))
-    );
-
-    // Ensure that the redirect URI is allowed based on the protocols.
-    if (!in_array($location->getScheme(), $protocols)) {
-      throw new BadResponseException(
-        sprintf(
-            'Redirect URI, %s, does not use one of the allowed redirect protocols: %s',
-            $location,
-            implode(', ', $protocols)
-        ),
-        $request,
-        $response
-      );
-    }
+        $location = UriResolver::resolve(
+            $request->getUri(),
+            new Uri($response->getHeaderLine('Location'))
+        );
+
+        // Ensure that the redirect URI is allowed based on the protocols.
+        if (!in_array($location->getScheme(), $protocols)) {
+            throw new BadResponseException(
+                sprintf(
+                    'Redirect URI, %s, does not use one of the allowed redirect protocols: %s',
+                    $location,
+                    implode(', ', $protocols)
+                ),
+                $request,
+                $response
+            );
+        }
 
-    return $location;
-  }
+        return $location;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/TransferStats.php
+++ PHP_CodeSniffer
@@ -9,65 +9,69 @@
  * Represents data at the point after it was transferred either successfully
  * or after a network error.
  */
-final class TransferStats {
-  private $request;
-  private $response;
-  private $transferTime;
-  private $handlerStats;
-  private $handlerErrorData;
+final class TransferStats
+{
+    private $request;
+    private $response;
+    private $transferTime;
+    private $handlerStats;
+    private $handlerErrorData;
 
-  /**
-   * @param \Psr\Http\Message\RequestInterface $request
+    /**
+   * @param \Psr\Http\Message\RequestInterface  $request
    *   Request that was sent.
    * @param \Psr\Http\Message\ResponseInterface $response
    *   Response received (if any)
-   * @param null $transferTime
+   * @param null                                $transferTime
    *   Total handler transfer time.
-   * @param mixed $handlerErrorData
+   * @param mixed                               $handlerErrorData
    *   Handler error data.
-   * @param array $handlerStats
+   * @param array                               $handlerStats
    *   Handler specific stats.
    */
-  public function __construct(
+    public function __construct(
         RequestInterface $request,
-        ResponseInterface $response = NULL,
-        $transferTime = NULL,
-        $handlerErrorData = NULL,
+        ResponseInterface $response = null,
+        $transferTime = null,
+        $handlerErrorData = null,
         $handlerStats = []
     ) {
-    $this->request = $request;
-    $this->response = $response;
-    $this->transferTime = $transferTime;
-    $this->handlerErrorData = $handlerErrorData;
-    $this->handlerStats = $handlerStats;
-  }
+        $this->request = $request;
+        $this->response = $response;
+        $this->transferTime = $transferTime;
+        $this->handlerErrorData = $handlerErrorData;
+        $this->handlerStats = $handlerStats;
+    }
 
-  /**
+    /**
    * @return \Psr\Http\Message\RequestInterface
    */
-  public function getRequest() {
-    return $this->request;
-  }
+    public function getRequest() 
+    {
+        return $this->request;
+    }
 
-  /**
+    /**
    * Returns the response that was received (if any).
    *
    * @return \Psr\Http\Message\ResponseInterface|null
    */
-  public function getResponse() {
-    return $this->response;
-  }
+    public function getResponse() 
+    {
+        return $this->response;
+    }
 
-  /**
+    /**
    * Returns true if a response was received.
    *
    * @return bool
    */
-  public function hasResponse() {
-    return $this->response !== NULL;
-  }
+    public function hasResponse() 
+    {
+        return $this->response !== null;
+    }
 
-  /**
+    /**
    * Gets handler specific error data.
    *
    * This might be an exception, a integer representing an error code, or
@@ -76,38 +80,42 @@
    *
    * @return mixed
    */
-  public function getHandlerErrorData() {
-    return $this->handlerErrorData;
-  }
+    public function getHandlerErrorData() 
+    {
+        return $this->handlerErrorData;
+    }
 
-  /**
+    /**
    * Get the effective URI the request was sent to.
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  public function getEffectiveUri() {
-    return $this->request->getUri();
-  }
+    public function getEffectiveUri() 
+    {
+        return $this->request->getUri();
+    }
 
-  /**
+    /**
    * Get the estimated time the request was being transferred by the handler.
    *
    * @return float Time in seconds.
    */
-  public function getTransferTime() {
-    return $this->transferTime;
-  }
+    public function getTransferTime() 
+    {
+        return $this->transferTime;
+    }
 
-  /**
+    /**
    * Gets an array of all of the handler specific transfer data.
    *
    * @return array
    */
-  public function getHandlerStats() {
-    return $this->handlerStats;
-  }
+    public function getHandlerStats() 
+    {
+        return $this->handlerStats;
+    }
 
-  /**
+    /**
    * Get a specific handler statistic from the handler by name.
    *
    * @param string $stat
@@ -115,10 +123,11 @@
    *
    * @return mixed|null
    */
-  public function getHandlerStat($stat) {
-    return isset($this->handlerStats[$stat])
+    public function getHandlerStat($stat) 
+    {
+        return isset($this->handlerStats[$stat])
             ? $this->handlerStats[$stat]
-            : NULL;
-  }
+            : null;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Pool.php
+++ PHP_CodeSniffer
@@ -17,74 +17,79 @@
  * "request_options" array that should be merged on top of any existing
  * options, and the function MUST then return a wait-able promise.
  */
-class Pool implements PromisorInterface {
-  /**
-   * @var \GuzzleHttp\Promise\EachPromise*/
-  private $each;
+class Pool implements PromisorInterface
+{
+    /**
+   * @var \GuzzleHttp\Promise\EachPromise
+*/
+    private $each;
 
-  /**
+    /**
    * @param ClientInterface $client
    *   Client used to send the requests.
    * @param array|\Iterator $requests
    *   Requests or functions that return
    *   requests to send concurrently.
-   * @param array $config
+   * @param array           $config
    *   Associative array of options
    *   - concurrency: (int) Maximum number of requests to send concurrently
    *   - options: Array of request options to apply to each request.
    *   - fulfilled: (callable) Function to invoke when a request completes.
    *   - rejected: (callable) Function to invoke when a request is rejected.
    */
-  public function __construct(
+    public function __construct(
         ClientInterface $client,
         $requests,
         array $config = []
     ) {
-    // Backwards compatibility.
-    if (isset($config['pool_size'])) {
-      $config['concurrency'] = $config['pool_size'];
-    }
-    elseif (!isset($config['concurrency'])) {
-      $config['concurrency'] = 25;
-    }
-
-    if (isset($config['options'])) {
-      $opts = $config['options'];
-      unset($config['options']);
-    }
-    else {
-      $opts = [];
-    }
-
-    $iterable = \GuzzleHttp\Promise\iter_for($requests);
-    $requests = function () use ($iterable, $client, $opts) {
-      foreach ($iterable as $key => $rfn) {
-        if ($rfn instanceof RequestInterface) {
-          yield $key => $client->sendAsync($rfn, $opts);
+        // Backwards compatibility.
+        if (isset($config['pool_size'])) {
+            $config['concurrency'] = $config['pool_size'];
         }
-        elseif (is_callable($rfn)) {
-          yield $key => $rfn($opts);
+        elseif (!isset($config['concurrency'])) {
+            $config['concurrency'] = 25;
+        }
+
+        if (isset($config['options'])) {
+            $opts = $config['options'];
+            unset($config['options']);
         }
         else {
-          throw new \InvalidArgumentException('Each value yielded by '
-                . 'the iterator must be a Psr7\Http\Message\RequestInterface '
-                . 'or a callable that returns a promise that fulfills '
-                . 'with a Psr7\Message\Http\ResponseInterface object.');
+            $opts = [];
         }
-      }
-    };
 
-    $this->each = new EachPromise($requests(), $config);
-  }
+        $iterable = \GuzzleHttp\Promise\iter_for($requests);
+        $requests = function () use ($iterable, $client, $opts) {
+            foreach ($iterable as $key => $rfn) {
+                if ($rfn instanceof RequestInterface) {
+                    yield $key => $client->sendAsync($rfn, $opts);
+                }
+                elseif (is_callable($rfn)) {
+                    yield $key => $rfn($opts);
+                }
+                else {
+                    throw new \InvalidArgumentException(
+                        'Each value yielded by '
+                        . 'the iterator must be a Psr7\Http\Message\RequestInterface '
+                        . 'or a callable that returns a promise that fulfills '
+                        . 'with a Psr7\Message\Http\ResponseInterface object.'
+                    );
+                }
+            }
+        };
 
-  /**
+        $this->each = new EachPromise($requests(), $config);
+    }
+
+    /**
    *
    */
-  public function promise() {
-    return $this->each->promise();
-  }
+    public function promise() 
+    {
+        return $this->each->promise();
+    }
 
-  /**
+    /**
    * Sends multiple requests concurrently and returns an array of responses
    * and exceptions that uses the same ordering as the provided requests.
    *
@@ -96,7 +101,7 @@
    *   Client used to send the requests.
    * @param array|\Iterator $requests
    *   Requests to send concurrently.
-   * @param array $options
+   * @param array           $options
    *   Passes through the options available in
    *   {@see GuzzleHttp\Pool::__construct}.
    *
@@ -105,37 +110,38 @@
    *
    * @throws \InvalidArgumentException if the event format is incorrect.
    */
-  public static function batch(
+    public static function batch(
         ClientInterface $client,
         $requests,
         array $options = []
     ) {
-    $res = [];
-    self::cmpCallback($options, 'fulfilled', $res);
-    self::cmpCallback($options, 'rejected', $res);
-    $pool = new static($client, $requests, $options);
-    $pool->promise()->wait();
-    ksort($res);
+        $res = [];
+        self::cmpCallback($options, 'fulfilled', $res);
+        self::cmpCallback($options, 'rejected', $res);
+        $pool = new static($client, $requests, $options);
+        $pool->promise()->wait();
+        ksort($res);
 
-    return $res;
-  }
+        return $res;
+    }
 
-  /**
+    /**
    *
    */
-  private static function cmpCallback(array &$options, $name, array &$results) {
-    if (!isset($options[$name])) {
-      $options[$name] = function ($v, $k) use (&$results) {
-        $results[$k] = $v;
-      };
-    }
-    else {
-      $currentFn = $options[$name];
-      $options[$name] = function ($v, $k) use (&$results, $currentFn) {
-        $currentFn($v, $k);
-        $results[$k] = $v;
-      };
+    private static function cmpCallback(array &$options, $name, array &$results) 
+    {
+        if (!isset($options[$name])) {
+            $options[$name] = function ($v, $k) use (&$results) {
+                $results[$k] = $v;
+            };
+        }
+        else {
+            $currentFn = $options[$name];
+            $options[$name] = function ($v, $k) use (&$results, $currentFn) {
+                $currentFn($v, $k);
+                $results[$k] = $v;
+            };
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/HandlerStack.php
+++ PHP_CodeSniffer
@@ -8,20 +8,24 @@
  * Creates a composed Guzzle handler function by stacking middlewares on top of
  * an HTTP handler function.
  */
-class HandlerStack {
-  /**
-   * @var callable*/
-  private $handler;
-
-  /**
-   * @var array*/
-  private $stack = [];
-
-  /**
-   * @var callable|null*/
-  private $cached;
+class HandlerStack
+{
+    /**
+   * @var callable
+*/
+    private $handler;
+
+    /**
+   * @var array
+*/
+    private $stack = [];
+
+    /**
+   * @var callable|null
+*/
+    private $cached;
 
-  /**
+    /**
    * Creates a default handler stack that can be used by clients.
    *
    * The returned handler will wrap the provided handler or use the most
@@ -39,192 +43,207 @@
    *
    * @return HandlerStack
    */
-  public static function create(callable $handler = NULL) {
-    $stack = new self($handler ?: choose_handler());
-    $stack->push(Middleware::httpErrors(), 'http_errors');
-    $stack->push(Middleware::redirect(), 'allow_redirects');
-    $stack->push(Middleware::cookies(), 'cookies');
-    $stack->push(Middleware::prepareBody(), 'prepare_body');
+    public static function create(callable $handler = null) 
+    {
+        $stack = new self($handler ?: choose_handler());
+        $stack->push(Middleware::httpErrors(), 'http_errors');
+        $stack->push(Middleware::redirect(), 'allow_redirects');
+        $stack->push(Middleware::cookies(), 'cookies');
+        $stack->push(Middleware::prepareBody(), 'prepare_body');
 
-    return $stack;
-  }
+        return $stack;
+    }
 
-  /**
+    /**
    * @param callable $handler
    *   Underlying HTTP handler.
    */
-  public function __construct(callable $handler = NULL) {
-    $this->handler = $handler;
-  }
+    public function __construct(callable $handler = null) 
+    {
+        $this->handler = $handler;
+    }
 
-  /**
+    /**
    * Invokes the handler stack as a composed handler.
    *
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    $handler = $this->resolve();
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        $handler = $this->resolve();
 
-    return $handler($request, $options);
-  }
+        return $handler($request, $options);
+    }
 
-  /**
+    /**
    * Dumps a string representation of the stack.
    *
    * @return string
    */
-  public function __toString() {
-    $depth = 0;
-    $stack = [];
-    if ($this->handler) {
-      $stack[] = "0) Handler: " . $this->debugCallable($this->handler);
-    }
+    public function __toString() 
+    {
+        $depth = 0;
+        $stack = [];
+        if ($this->handler) {
+            $stack[] = "0) Handler: " . $this->debugCallable($this->handler);
+        }
 
-    $result = '';
-    foreach (array_reverse($this->stack) as $tuple) {
-      $depth++;
-      $str = "{$depth}) Name: '{$tuple[1]}', ";
-      $str .= "Function: " . $this->debugCallable($tuple[0]);
-      $result = "> {$str}\n{$result}";
-      $stack[] = $str;
-    }
+        $result = '';
+        foreach (array_reverse($this->stack) as $tuple) {
+            $depth++;
+            $str = "{$depth}) Name: '{$tuple[1]}', ";
+            $str .= "Function: " . $this->debugCallable($tuple[0]);
+            $result = "> {$str}\n{$result}";
+            $stack[] = $str;
+        }
 
-    foreach (array_keys($stack) as $k) {
-      $result .= "< {$stack[$k]}\n";
-    }
+        foreach (array_keys($stack) as $k) {
+            $result .= "< {$stack[$k]}\n";
+        }
 
-    return $result;
-  }
+        return $result;
+    }
 
-  /**
+    /**
    * Set the HTTP handler that actually returns a promise.
    *
    * @param callable $handler
    *   Accepts a request and array of options and
    *   returns a Promise.
    */
-  public function setHandler(callable $handler) {
-    $this->handler = $handler;
-    $this->cached = NULL;
-  }
+    public function setHandler(callable $handler) 
+    {
+        $this->handler = $handler;
+        $this->cached = null;
+    }
 
-  /**
+    /**
    * Returns true if the builder has a handler.
    *
    * @return bool
    */
-  public function hasHandler() {
-    return (bool) $this->handler;
-  }
+    public function hasHandler() 
+    {
+        return (bool) $this->handler;
+    }
 
-  /**
+    /**
    * Unshift a middleware to the bottom of the stack.
    *
    * @param callable $middleware
    *   Middleware function.
-   * @param string $name
+   * @param string   $name
    *   Name to register for this middleware.
    */
-  public function unshift(callable $middleware, $name = NULL) {
-    array_unshift($this->stack, [$middleware, $name]);
-    $this->cached = NULL;
-  }
+    public function unshift(callable $middleware, $name = null) 
+    {
+        array_unshift($this->stack, [$middleware, $name]);
+        $this->cached = null;
+    }
 
-  /**
+    /**
    * Push a middleware to the top of the stack.
    *
    * @param callable $middleware
    *   Middleware function.
-   * @param string $name
+   * @param string   $name
    *   Name to register for this middleware.
    */
-  public function push(callable $middleware, $name = '') {
-    $this->stack[] = [$middleware, $name];
-    $this->cached = NULL;
-  }
+    public function push(callable $middleware, $name = '') 
+    {
+        $this->stack[] = [$middleware, $name];
+        $this->cached = null;
+    }
 
-  /**
+    /**
    * Add a middleware before another middleware by name.
    *
-   * @param string $findName
+   * @param string   $findName
    *   Middleware to find.
    * @param callable $middleware
    *   Middleware function.
-   * @param string $withName
+   * @param string   $withName
    *   Name to register for this middleware.
    */
-  public function before($findName, callable $middleware, $withName = '') {
-    $this->splice($findName, $withName, $middleware, TRUE);
-  }
+    public function before($findName, callable $middleware, $withName = '') 
+    {
+        $this->splice($findName, $withName, $middleware, true);
+    }
 
-  /**
+    /**
    * Add a middleware after another middleware by name.
    *
-   * @param string $findName
+   * @param string   $findName
    *   Middleware to find.
    * @param callable $middleware
    *   Middleware function.
-   * @param string $withName
+   * @param string   $withName
    *   Name to register for this middleware.
    */
-  public function after($findName, callable $middleware, $withName = '') {
-    $this->splice($findName, $withName, $middleware, FALSE);
-  }
+    public function after($findName, callable $middleware, $withName = '') 
+    {
+        $this->splice($findName, $withName, $middleware, false);
+    }
 
-  /**
+    /**
    * Remove a middleware by instance or name from the stack.
    *
    * @param callable|string $remove
    *   Middleware to remove by instance or name.
    */
-  public function remove($remove) {
-    $this->cached = NULL;
-    $idx = is_callable($remove) ? 0 : 1;
-    $this->stack = array_values(array_filter(
-        $this->stack,
-        function ($tuple) use ($idx, $remove) {
-            return $tuple[$idx] !== $remove;
-        }
-    ));
-  }
+    public function remove($remove) 
+    {
+        $this->cached = null;
+        $idx = is_callable($remove) ? 0 : 1;
+        $this->stack = array_values(
+            array_filter(
+                $this->stack,
+                function ($tuple) use ($idx, $remove) {
+                    return $tuple[$idx] !== $remove;
+                }
+            )
+        );
+    }
 
-  /**
+    /**
    * Compose the middleware and handler into a single callable function.
    *
    * @return callable
    */
-  public function resolve() {
-    if (!$this->cached) {
-      if (!($prev = $this->handler)) {
-        throw new \LogicException('No handler has been specified');
-      }
+    public function resolve() 
+    {
+        if (!$this->cached) {
+            if (!($prev = $this->handler)) {
+                throw new \LogicException('No handler has been specified');
+            }
+
+            foreach (array_reverse($this->stack) as $fn) {
+                $prev = $fn[0]($prev);
+            }
 
-      foreach (array_reverse($this->stack) as $fn) {
-        $prev = $fn[0]($prev);
-      }
+            $this->cached = $prev;
+        }
 
-      $this->cached = $prev;
+        return $this->cached;
     }
 
-    return $this->cached;
-  }
-
-  /**
+    /**
    * @param $name
    * @return int
    */
-  private function findByName($name) {
-    foreach ($this->stack as $k => $v) {
-      if ($v[1] === $name) {
-        return $k;
-      }
-    }
+    private function findByName($name) 
+    {
+        foreach ($this->stack as $k => $v) {
+            if ($v[1] === $name) {
+                return $k;
+            }
+        }
 
-    throw new \InvalidArgumentException("Middleware not found: $name");
-  }
+        throw new \InvalidArgumentException("Middleware not found: $name");
+    }
 
-  /**
+    /**
    * Splices a function into the middleware list at a specific position.
    *
    * @param $findName
@@ -232,30 +251,31 @@
    * @param callable $middleware
    * @param $before
    */
-  private function splice($findName, $withName, callable $middleware, $before) {
-    $this->cached = NULL;
-    $idx = $this->findByName($findName);
-    $tuple = [$middleware, $withName];
-
-    if ($before) {
-      if ($idx === 0) {
-        array_unshift($this->stack, $tuple);
-      }
-      else {
-        $replacement = [$tuple, $this->stack[$idx]];
-        array_splice($this->stack, $idx, 1, $replacement);
-      }
-    }
-    elseif ($idx === count($this->stack) - 1) {
-      $this->stack[] = $tuple;
-    }
-    else {
-      $replacement = [$this->stack[$idx], $tuple];
-      array_splice($this->stack, $idx, 1, $replacement);
+    private function splice($findName, $withName, callable $middleware, $before) 
+    {
+        $this->cached = null;
+        $idx = $this->findByName($findName);
+        $tuple = [$middleware, $withName];
+
+        if ($before) {
+            if ($idx === 0) {
+                array_unshift($this->stack, $tuple);
+            }
+            else {
+                $replacement = [$tuple, $this->stack[$idx]];
+                array_splice($this->stack, $idx, 1, $replacement);
+            }
+        }
+        elseif ($idx === count($this->stack) - 1) {
+            $this->stack[] = $tuple;
+        }
+        else {
+            $replacement = [$this->stack[$idx], $tuple];
+            array_splice($this->stack, $idx, 1, $replacement);
+        }
     }
-  }
 
-  /**
+    /**
    * Provides a debug string for a given callable.
    *
    * @param array|callable $fn
@@ -263,18 +283,19 @@
    *
    * @return string
    */
-  private function debugCallable($fn) {
-    if (is_string($fn)) {
-      return "callable({$fn})";
-    }
+    private function debugCallable($fn) 
+    {
+        if (is_string($fn)) {
+            return "callable({$fn})";
+        }
 
-    if (is_array($fn)) {
-      return is_string($fn[0])
+        if (is_array($fn)) {
+            return is_string($fn[0])
                 ? "callable({$fn[0]}::{$fn[1]})"
                 : "callable(['" . get_class($fn[0]) . "', '{$fn[1]}'])";
-    }
+        }
 
-    return 'callable(' . spl_object_hash($fn) . ')';
-  }
+        return 'callable(' . spl_object_hash($fn) . ')';
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/RequestOptions.php
+++ PHP_CodeSniffer
@@ -9,8 +9,9 @@
  *
  * @link http://docs.guzzlephp.org/en/v6/request-options.html
  */
-final class RequestOptions {
-  /**
+final class RequestOptions
+{
+    /**
      * Allow_redirects: (bool|array) Controls redirect behavior. Pass false
      * to disable redirects, pass true to enable redirects, pass an
      * associative to provide custom redirect settings. Defaults to "false".
@@ -31,68 +32,68 @@
      *   response that was received, and the effective URI. Any return value
      *   from the on_redirect function is ignored.
      */
-  const ALLOW_REDIRECTS = 'allow_redirects';
+    const ALLOW_REDIRECTS = 'allow_redirects';
 
-  /**
+    /**
      * Auth: (array) Pass an array of HTTP authentication parameters to use
      * with the request. The array must contain the username in index [0],
      * the password in index [1], and you can optionally provide a built-in
      * authentication type in index [2]. Pass null to disable authentication
      * for a request.
      */
-  const AUTH = 'auth';
+    const AUTH = 'auth';
 
-  /**
+    /**
      * Body: (resource|string|null|int|float|StreamInterface|callable|\Iterator)
      * Body to send in the request.
      */
-  const BODY = 'body';
+    const BODY = 'body';
 
-  /**
+    /**
      * Cert: (string|array) Set to a string to specify the path to a file
      * containing a PEM formatted SSL client side certificate. If a password
      * is required, then set cert to an array containing the path to the PEM
      * file in the first array element followed by the certificate password
      * in the second array element.
      */
-  const CERT = 'cert';
+    const CERT = 'cert';
 
-  /**
+    /**
      * Cookies: (bool|GuzzleHttp\Cookie\CookieJarInterface, default=false)
      * Specifies whether or not cookies are used in a request or what cookie
      * jar to use or what cookies to send. This option only works if your
      * handler has the `cookie` middleware. Valid values are `false` and
      * an instance of {@see GuzzleHttp\Cookie\CookieJarInterface}.
      */
-  const COOKIES = 'cookies';
+    const COOKIES = 'cookies';
 
-  /**
+    /**
      * Connect_timeout: (float, default=0) Float describing the number of
      * seconds to wait while trying to connect to a server. Use 0 to wait
      * indefinitely (the default behavior).
      */
-  const CONNECT_TIMEOUT = 'connect_timeout';
+    const CONNECT_TIMEOUT = 'connect_timeout';
 
-  /**
+    /**
      * Debug: (bool|resource) Set to true or set to a PHP stream returned by
      * fopen()  enable debug output with the HTTP handler used to send a
      * request.
      */
-  const DEBUG = 'debug';
+    const DEBUG = 'debug';
 
-  /**
+    /**
      * Decode_content: (bool, default=true) Specify whether or not
      * Content-Encoding responses (gzip, deflate, etc.) are automatically
      * decoded.
      */
-  const DECODE_CONTENT = 'decode_content';
+    const DECODE_CONTENT = 'decode_content';
 
-  /**
+    /**
      * Delay: (int) The amount of time to delay before sending in milliseconds.
      */
-  const DELAY = 'delay';
+    const DELAY = 'delay';
 
-  /**
+    /**
      * Expect: (bool|integer) Controls the behavior of the
      * "Expect: 100-Continue" header.
      *
@@ -108,38 +109,38 @@
      * size of the body of a request is greater than 1 MB and a request is
      * using HTTP/1.1.
      */
-  const EXPECT = 'expect';
+    const EXPECT = 'expect';
 
-  /**
+    /**
      * Form_params: (array) Associative array of form field names to values
      * where each value is a string or array of strings. Sets the Content-Type
      * header to application/x-www-form-urlencoded when no Content-Type header
      * is already present.
      */
-  const FORM_PARAMS = 'form_params';
+    const FORM_PARAMS = 'form_params';
 
-  /**
+    /**
      * Headers: (array) Associative array of HTTP headers. Each value MUST be
      * a string or array of strings.
      */
-  const HEADERS = 'headers';
+    const HEADERS = 'headers';
 
-  /**
+    /**
      * Http_errors: (bool, default=true) Set to false to disable exceptions
      * when a non- successful HTTP response is received. By default,
      * exceptions will be thrown for 4xx and 5xx responses. This option only
      * works if your handler has the `httpErrors` middleware.
      */
-  const HTTP_ERRORS = 'http_errors';
+    const HTTP_ERRORS = 'http_errors';
 
-  /**
+    /**
      * Json: (mixed) Adds JSON data to a request. The provided value is JSON
      * encoded and a Content-Type header of application/json will be added to
      * the request if no Content-Type header is already present.
      */
-  const JSON = 'json';
+    const JSON = 'json';
 
-  /**
+    /**
      * Multipart: (array) Array of associative arrays, each containing a
      * required "name" key mapping to the form field, name, a required
      * "contents" key mapping to a StreamInterface|resource|string, an
@@ -148,16 +149,16 @@
      * the part. If no "filename" key is present, then no "filename" attribute
      * will be added to the part.
      */
-  const MULTIPART = 'multipart';
+    const MULTIPART = 'multipart';
 
-  /**
+    /**
      * On_headers: (callable) A callable that is invoked when the HTTP headers
      * of the response have been received but the body has not yet begun to
      * download.
      */
-  const ON_HEADERS = 'on_headers';
+    const ON_HEADERS = 'on_headers';
 
-  /**
+    /**
      * On_stats: (callable) allows you to get access to transfer statistics of
      * a request and access the lower level transfer details of the handler
      * associated with your client. ``on_stats`` is a callable that is invoked
@@ -166,62 +167,62 @@
      * the error encountered. Included in the data is the total amount of time
      * taken to send the request.
      */
-  const ON_STATS = 'on_stats';
+    const ON_STATS = 'on_stats';
 
-  /**
+    /**
      * Progress: (callable) Defines a function to invoke when transfer
      * progress is made. The function accepts the following positional
      * arguments: the total number of bytes expected to be downloaded, the
      * number of bytes downloaded so far, the number of bytes expected to be
      * uploaded, the number of bytes uploaded so far.
      */
-  const PROGRESS = 'progress';
+    const PROGRESS = 'progress';
 
-  /**
+    /**
      * Proxy: (string|array) Pass a string to specify an HTTP proxy, or an
      * array to specify different proxies for different protocols (where the
      * key is the protocol and the value is a proxy string).
      */
-  const PROXY = 'proxy';
+    const PROXY = 'proxy';
 
-  /**
+    /**
      * Query: (array|string) Associative array of query string values to add
      * to the request. This option uses PHP's http_build_query() to create
      * the string representation. Pass a string value if you need more
      * control than what this method provides.
      */
-  const QUERY = 'query';
+    const QUERY = 'query';
 
-  /**
+    /**
      * Sink: (resource|string|StreamInterface) Where the data of the
      * response is written to. Defaults to a PHP temp stream. Providing a
      * string will write data to a file by the given name.
      */
-  const SINK = 'sink';
+    const SINK = 'sink';
 
-  /**
+    /**
      * Synchronous: (bool) Set to true to inform HTTP handlers that you intend
      * on waiting on the response. This can be useful for optimizations. Note
      * that a promise is still returned if you are using one of the async
      * client methods.
      */
-  const SYNCHRONOUS = 'synchronous';
+    const SYNCHRONOUS = 'synchronous';
 
-  /**
+    /**
      * Ssl_key: (array|string) Specify the path to a file containing a private
      * SSL key in PEM format. If a password is required, then set to an array
      * containing the path to the SSL key in the first array element followed
      * by the password required for the certificate in the second element.
      */
-  const SSL_KEY = 'ssl_key';
+    const SSL_KEY = 'ssl_key';
 
-  /**
+    /**
      * Stream: Set to true to attempt to stream a response rather than
      * download it all up-front.
      */
-  const STREAM = 'stream';
+    const STREAM = 'stream';
 
-  /**
+    /**
      * Verify: (bool|string, default=true) Describes the SSL certificate
      * verification behavior of a request. Set to true to enable SSL
      * certificate verification using the system CA bundle when available
@@ -229,28 +230,28 @@
      * is insecure!). Set to a string to provide the path to a CA bundle on
      * disk to enable verification using a custom certificate.
      */
-  const VERIFY = 'verify';
+    const VERIFY = 'verify';
 
-  /**
+    /**
      * Timeout: (float, default=0) Float describing the timeout of the
      * request in seconds. Use 0 to wait indefinitely (the default behavior).
      */
-  const TIMEOUT = 'timeout';
+    const TIMEOUT = 'timeout';
 
-  /**
+    /**
      * Read_timeout: (float, default=default_socket_timeout ini setting) Float describing
      * the body read timeout, for stream requests.
      */
-  const READ_TIMEOUT = 'read_timeout';
+    const READ_TIMEOUT = 'read_timeout';
 
-  /**
+    /**
      * Version: (float) Specifies the HTTP protocol version to attempt to use.
      */
-  const VERSION = 'version';
+    const VERSION = 'version';
 
-  /**
+    /**
      * Force_ip_resolve: (bool) Force client to use only ipv4 or ipv6 protocol.
      */
-  const FORCE_IP_RESOLVE = 'force_ip_resolve';
+    const FORCE_IP_RESOLVE = 'force_ip_resolve';
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/ClientInterface.php
+++ PHP_CodeSniffer
@@ -7,15 +7,16 @@
 /**
  * Client interface for sending HTTP requests.
  */
-interface ClientInterface {
-  const VERSION = '6.2.1';
+interface ClientInterface
+{
+    const VERSION = '6.2.1';
 
-  /**
+    /**
    * Send an HTTP request.
    *
    * @param \Psr\Http\Message\RequestInterface $request
    *   Request to send.
-   * @param array $options
+   * @param array                              $options
    *   Request options to apply to the given
    *   request and to the transfer.
    *
@@ -23,42 +24,42 @@
    *
    * @throws GuzzleException
    */
-  public function send(RequestInterface $request, array $options = []);
+    public function send(RequestInterface $request, array $options = []);
 
-  /**
+    /**
    * Asynchronously send an HTTP request.
    *
    * @param \Psr\Http\Message\RequestInterface $request
    *   Request to send.
-   * @param array $options
+   * @param array                              $options
    *   Request options to apply to the given
    *   request and to the transfer.
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function sendAsync(RequestInterface $request, array $options = []);
+    public function sendAsync(RequestInterface $request, array $options = []);
 
-  /**
+    /**
    * Create and send an HTTP request.
    *
    * Use an absolute path to override the base path of the client, or a
    * relative path to append to the base path of the client. The URL can
    * contain the query string as well.
    *
-   * @param string $method
+   * @param string              $method
    *   HTTP method.
    * @param string|UriInterface $uri
    *   URI object or string.
-   * @param array $options
+   * @param array               $options
    *   Request options to apply.
    *
    * @return \Psr\Http\Message\ResponseInterface
    *
    * @throws GuzzleException
    */
-  public function request($method, $uri, array $options = []);
+    public function request($method, $uri, array $options = []);
 
-  /**
+    /**
    * Create and send an asynchronous HTTP request.
    *
    * Use an absolute path to override the base path of the client, or a
@@ -66,18 +67,18 @@
    * contain the query string as well. Use an array to provide a URL
    * template and additional variables to use in the URL template expansion.
    *
-   * @param string $method
+   * @param string              $method
    *   HTTP method.
    * @param string|UriInterface $uri
    *   URI object or string.
-   * @param array $options
+   * @param array               $options
    *   Request options to apply.
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function requestAsync($method, $uri, array $options = []);
+    public function requestAsync($method, $uri, array $options = []);
 
-  /**
+    /**
    * Get a client configuration option.
    *
    * These options include default request options of the client, a "handler"
@@ -89,6 +90,6 @@
    *
    * @return mixed
    */
-  public function getConfig($option = NULL);
+    public function getConfig($option = null);
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/PrepareBodyMiddleware.php
+++ PHP_CodeSniffer
@@ -8,102 +8,106 @@
  * Prepares requests that contain a body, adding the Content-Length,
  * Content-Type, and Expect headers.
  */
-class PrepareBodyMiddleware {
-  /**
-   * @var callable*/
-  private $nextHandler;
+class PrepareBodyMiddleware
+{
+    /**
+   * @var callable
+*/
+    private $nextHandler;
 
-  /**
+    /**
    * @param callable $nextHandler
    *   Next handler to invoke.
    */
-  public function __construct(callable $nextHandler) {
-    $this->nextHandler = $nextHandler;
-  }
+    public function __construct(callable $nextHandler) 
+    {
+        $this->nextHandler = $nextHandler;
+    }
 
-  /**
+    /**
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    $fn = $this->nextHandler;
-
-    // Don't do anything if the request has no body.
-    if ($request->getBody()->getSize() === 0) {
-      return $fn($request, $options);
-    }
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        $fn = $this->nextHandler;
+
+        // Don't do anything if the request has no body.
+        if ($request->getBody()->getSize() === 0) {
+            return $fn($request, $options);
+        }
 
-    $modify = [];
+        $modify = [];
 
-    // Add a default content-type if possible.
-    if (!$request->hasHeader('Content-Type')) {
-      if ($uri = $request->getBody()->getMetadata('uri')) {
-        if ($type = Psr7\mimetype_from_filename($uri)) {
-          $modify['set_headers']['Content-Type'] = $type;
+        // Add a default content-type if possible.
+        if (!$request->hasHeader('Content-Type')) {
+            if ($uri = $request->getBody()->getMetadata('uri')) {
+                if ($type = Psr7\mimetype_from_filename($uri)) {
+                    $modify['set_headers']['Content-Type'] = $type;
+                }
+            }
         }
-      }
-    }
 
-    // Add a default content-length or transfer-encoding header.
-    if (!$request->hasHeader('Content-Length')
-        && !$request->hasHeader('Transfer-Encoding')
-    ) {
-      $size = $request->getBody()->getSize();
-      if ($size !== NULL) {
-        $modify['set_headers']['Content-Length'] = $size;
-      }
-      else {
-        $modify['set_headers']['Transfer-Encoding'] = 'chunked';
-      }
-    }
+        // Add a default content-length or transfer-encoding header.
+        if (!$request->hasHeader('Content-Length')
+            && !$request->hasHeader('Transfer-Encoding')
+        ) {
+            $size = $request->getBody()->getSize();
+            if ($size !== null) {
+                $modify['set_headers']['Content-Length'] = $size;
+            }
+            else {
+                $modify['set_headers']['Transfer-Encoding'] = 'chunked';
+            }
+        }
 
-    // Add the expect header if needed.
-    $this->addExpectHeader($request, $options, $modify);
+        // Add the expect header if needed.
+        $this->addExpectHeader($request, $options, $modify);
 
-    return $fn(Psr7\modify_request($request, $modify), $options);
-  }
+        return $fn(Psr7\modify_request($request, $modify), $options);
+    }
 
-  /**
+    /**
    *
    */
-  private function addExpectHeader(
+    private function addExpectHeader(
         RequestInterface $request,
         array $options,
         array &$modify
     ) {
-    // Determine if the Expect header should be used.
-    if ($request->hasHeader('Expect')) {
-      return;
-    }
+        // Determine if the Expect header should be used.
+        if ($request->hasHeader('Expect')) {
+            return;
+        }
 
-    $expect = isset($options['expect']) ? $options['expect'] : NULL;
+        $expect = isset($options['expect']) ? $options['expect'] : null;
 
-    // Return if disabled or if you're not using HTTP/1.1 or HTTP/2.0.
-    if ($expect === FALSE || $request->getProtocolVersion() < 1.1) {
-      return;
-    }
+        // Return if disabled or if you're not using HTTP/1.1 or HTTP/2.0.
+        if ($expect === false || $request->getProtocolVersion() < 1.1) {
+            return;
+        }
 
-    // The expect header is unconditionally enabled.
-    if ($expect === TRUE) {
-      $modify['set_headers']['Expect'] = '100-Continue';
-      return;
-    }
+        // The expect header is unconditionally enabled.
+        if ($expect === true) {
+            $modify['set_headers']['Expect'] = '100-Continue';
+            return;
+        }
 
-    // By default, send the expect header when the payload is > 1mb.
-    if ($expect === NULL) {
-      $expect = 1048576;
-    }
+        // By default, send the expect header when the payload is > 1mb.
+        if ($expect === null) {
+            $expect = 1048576;
+        }
 
-    // Always add if the body cannot be rewound, the size cannot be
-    // determined, or the size is greater than the cutoff threshold.
-    $body = $request->getBody();
-    $size = $body->getSize();
+        // Always add if the body cannot be rewound, the size cannot be
+        // determined, or the size is greater than the cutoff threshold.
+        $body = $request->getBody();
+        $size = $body->getSize();
 
-    if ($size === NULL || $size >= (int) $expect || !$body->isSeekable()) {
-      $modify['set_headers']['Expect'] = '100-Continue';
+        if ($size === null || $size >= (int) $expect || !$body->isSeekable()) {
+            $modify['set_headers']['Expect'] = '100-Continue';
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Cookie/SessionCookieJar.php
+++ PHP_CodeSniffer
@@ -5,69 +5,78 @@
 /**
  * Persists cookies in the client session.
  */
-class SessionCookieJar extends CookieJar {
-  /**
-   * @var stringsessionkey*/
-  private $sessionKey;
-
-  /**
-   * @var boolControlwhethertopersistsessioncookiesornot*/
-  private $storeSessionCookies;
+class SessionCookieJar extends CookieJar
+{
+    /**
+   * @var stringsessionkey
+*/
+    private $sessionKey;
+
+    /**
+   * @var boolControlwhethertopersistsessioncookiesornot
+*/
+    private $storeSessionCookies;
 
-  /**
+    /**
    * Create a new SessionCookieJar object.
    *
    * @param string $sessionKey
    *   Session key name to store the cookie
    *   data in session.
-   * @param bool $storeSessionCookies
+   * @param bool   $storeSessionCookies
    *   Set to true to store session cookies
    *   in the cookie jar.
    */
-  public function __construct($sessionKey, $storeSessionCookies = FALSE) {
-    $this->sessionKey = $sessionKey;
-    $this->storeSessionCookies = $storeSessionCookies;
-    $this->load();
-  }
+    public function __construct($sessionKey, $storeSessionCookies = false) 
+    {
+        $this->sessionKey = $sessionKey;
+        $this->storeSessionCookies = $storeSessionCookies;
+        $this->load();
+    }
 
-  /**
+    /**
    * Saves cookies to session when shutting down.
    */
-  public function __destruct() {
-    $this->save();
-  }
+    public function __destruct() 
+    {
+        $this->save();
+    }
 
-  /**
+    /**
    * Save cookies to the client session.
    */
-  public function save() {
-    $json = [];
-    foreach ($this as $cookie) {
-      /** @var SetCookie $cookie */
-      if (CookieJar::shouldPersist($cookie, $this->storeSessionCookies)) {
-        $json[] = $cookie->toArray();
-      }
-    }
+    public function save() 
+    {
+        $json = [];
+        foreach ($this as $cookie) {
+            /**
+ * @var SetCookie $cookie 
+*/
+            if (CookieJar::shouldPersist($cookie, $this->storeSessionCookies)) {
+                $json[] = $cookie->toArray();
+            }
+        }
 
-    $_SESSION[$this->sessionKey] = json_encode($json);
-  }
+        $_SESSION[$this->sessionKey] = json_encode($json);
+    }
 
-  /**
+    /**
    * Load the contents of the client session into the data array.
    */
-  protected function load() {
-    if (!isset($_SESSION[$this->sessionKey])) {
-      return;
-    }
-    $data = json_decode($_SESSION[$this->sessionKey], TRUE);
-    if (is_array($data)) {
-      foreach ($data as $cookie) {
-        $this->setCookie(new SetCookie($cookie));
-      }
-    }
-    elseif (strlen($data)) {
-      throw new \RuntimeException("Invalid cookie data");
+    protected function load() 
+    {
+        if (!isset($_SESSION[$this->sessionKey])) {
+            return;
+        }
+        $data = json_decode($_SESSION[$this->sessionKey], true);
+        if (is_array($data)) {
+            foreach ($data as $cookie) {
+                $this->setCookie(new SetCookie($cookie));
+            }
+        }
+        elseif (strlen($data)) {
+            throw new \RuntimeException("Invalid cookie data");
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Cookie/CookieJarInterface.php
+++ PHP_CodeSniffer
@@ -15,9 +15,10 @@
  *
  * @link http://docs.python.org/2/library/cookielib.html Inspiration
  */
-interface CookieJarInterface extends \Countable, \IteratorAggregate {
+interface CookieJarInterface extends \Countable, \IteratorAggregate
+{
 
-  /**
+    /**
    * Create a request with added cookie headers.
    *
    * If no matching cookies are found in the cookie jar, then no Cookie
@@ -28,22 +29,22 @@
    *
    * @return \Psr\Http\Message\RequestInterface returns the modified request.
    */
-  public function withCookieHeader(RequestInterface $request);
+    public function withCookieHeader(RequestInterface $request);
 
-  /**
+    /**
    * Extract cookies from an HTTP response and store them in the CookieJar.
    *
-   * @param \Psr\Http\Message\RequestInterface $request
+   * @param \Psr\Http\Message\RequestInterface  $request
    *   Request that was sent.
    * @param \Psr\Http\Message\ResponseInterface $response
    *   Response that was received.
    */
-  public function extractCookies(
+    public function extractCookies(
         RequestInterface $request,
         ResponseInterface $response
     );
 
-  /**
+    /**
    * Sets a cookie in the cookie jar.
    *
    * @param SetCookie $cookie
@@ -51,9 +52,9 @@
    *
    * @return bool Returns true on success or false on failure
    */
-  public function setCookie(SetCookie $cookie);
+    public function setCookie(SetCookie $cookie);
 
-  /**
+    /**
    * Remove cookies currently held in the cookie jar.
    *
    * Invoking this method without arguments will empty the whole cookie jar.
@@ -72,22 +73,22 @@
    *
    * @return CookieJarInterface
    */
-  public function clear($domain = NULL, $path = NULL, $name = NULL);
+    public function clear($domain = null, $path = null, $name = null);
 
-  /**
+    /**
    * Discard all sessions cookies.
    *
    * Removes cookies that don't have an expire field or a have a discard
    * field set to true. To be called when the user agent shuts down according
    * to RFC 2965.
    */
-  public function clearSessionCookies();
+    public function clearSessionCookies();
 
-  /**
+    /**
    * Converts the cookie jar to an array.
    *
    * @return array
    */
-  public function toArray();
+    public function toArray();
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Cookie/SetCookie.php
+++ PHP_CodeSniffer
@@ -5,26 +5,29 @@
 /**
  * Set-Cookie object.
  */
-class SetCookie {
-  /**
-   * @var array*/
-  private static $defaults = [
-    'Name'     => NULL,
-    'Value'    => NULL,
-    'Domain'   => NULL,
+class SetCookie
+{
+    /**
+   * @var array
+*/
+    private static $defaults = [
+    'Name'     => null,
+    'Value'    => null,
+    'Domain'   => null,
     'Path'     => '/',
-    'Max-Age'  => NULL,
-    'Expires'  => NULL,
-    'Secure'   => FALSE,
-    'Discard'  => FALSE,
-    'HttpOnly' => FALSE,
-  ];
-
-  /**
-   * @var arrayCookiedata*/
-  private $data;
+    'Max-Age'  => null,
+    'Expires'  => null,
+    'Secure'   => false,
+    'Discard'  => false,
+    'HttpOnly' => false,
+    ];
+
+    /**
+   * @var arrayCookiedata
+*/
+    private $data;
 
-  /**
+    /**
    * Create a new SetCookie object from a string.
    *
    * @param string $cookie
@@ -32,259 +35,281 @@
    *
    * @return self
    */
-  public static function fromString($cookie) {
-    // Create the default return array.
-    $data = self::$defaults;
-    // Explode the cookie string using a series of semicolons.
-    $pieces = array_filter(array_map('trim', explode(';', $cookie)));
-    // The name of the cookie (first kvp) must include an equal sign.
-    if (empty($pieces) || !strpos($pieces[0], '=')) {
-      return new self($data);
-    }
-
-    // Add the cookie pieces into the parsed data array.
-    foreach ($pieces as $part) {
-
-      $cookieParts = explode('=', $part, 2);
-      $key = trim($cookieParts[0]);
-      $value = isset($cookieParts[1])
+    public static function fromString($cookie) 
+    {
+        // Create the default return array.
+        $data = self::$defaults;
+        // Explode the cookie string using a series of semicolons.
+        $pieces = array_filter(array_map('trim', explode(';', $cookie)));
+        // The name of the cookie (first kvp) must include an equal sign.
+        if (empty($pieces) || !strpos($pieces[0], '=')) {
+            return new self($data);
+        }
+
+        // Add the cookie pieces into the parsed data array.
+        foreach ($pieces as $part) {
+
+            $cookieParts = explode('=', $part, 2);
+            $key = trim($cookieParts[0]);
+            $value = isset($cookieParts[1])
                 ? trim($cookieParts[1], " \n\r\t\0\x0B")
-                : TRUE;
+                : true;
 
-      // Only check for non-cookies when cookies have been found.
-      if (empty($data['Name'])) {
-        $data['Name'] = $key;
-        $data['Value'] = $value;
-      }
-      else {
-        foreach (array_keys(self::$defaults) as $search) {
-          if (!strcasecmp($search, $key)) {
-            $data[$search] = $value;
-            continue 2;
-          }
+            // Only check for non-cookies when cookies have been found.
+            if (empty($data['Name'])) {
+                $data['Name'] = $key;
+                $data['Value'] = $value;
+            }
+            else {
+                foreach (array_keys(self::$defaults) as $search) {
+                    if (!strcasecmp($search, $key)) {
+                        $data[$search] = $value;
+                        continue 2;
+                    }
+                }
+                $data[$key] = $value;
+            }
         }
-        $data[$key] = $value;
-      }
-    }
 
-    return new self($data);
-  }
+        return new self($data);
+    }
 
-  /**
+    /**
    * @param array $data
    *   Array of cookie data provided by a Cookie parser.
    */
-  public function __construct(array $data = []) {
-    $this->data = array_replace(self::$defaults, $data);
-    // Extract the Expires value and turn it into a UNIX timestamp if needed.
-    if (!$this->getExpires() && $this->getMaxAge()) {
-      // Calculate the Expires date.
-      $this->setExpires(time() + $this->getMaxAge());
-    }
-    elseif ($this->getExpires() && !is_numeric($this->getExpires())) {
-      $this->setExpires($this->getExpires());
+    public function __construct(array $data = []) 
+    {
+        $this->data = array_replace(self::$defaults, $data);
+        // Extract the Expires value and turn it into a UNIX timestamp if needed.
+        if (!$this->getExpires() && $this->getMaxAge()) {
+            // Calculate the Expires date.
+            $this->setExpires(time() + $this->getMaxAge());
+        }
+        elseif ($this->getExpires() && !is_numeric($this->getExpires())) {
+            $this->setExpires($this->getExpires());
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function __toString() {
-    $str = $this->data['Name'] . '=' . $this->data['Value'] . '; ';
-    foreach ($this->data as $k => $v) {
-      if ($k !== 'Name' && $k !== 'Value' && $v !== NULL && $v !== FALSE) {
-        if ($k === 'Expires') {
-          $str .= 'Expires=' . gmdate('D, d M Y H:i:s \G\M\T', $v) . '; ';
-        }
-        else {
-          $str .= ($v === TRUE ? $k : "{$k}={$v}") . '; ';
+    public function __toString() 
+    {
+        $str = $this->data['Name'] . '=' . $this->data['Value'] . '; ';
+        foreach ($this->data as $k => $v) {
+            if ($k !== 'Name' && $k !== 'Value' && $v !== null && $v !== false) {
+                if ($k === 'Expires') {
+                    $str .= 'Expires=' . gmdate('D, d M Y H:i:s \G\M\T', $v) . '; ';
+                }
+                else {
+                    $str .= ($v === true ? $k : "{$k}={$v}") . '; ';
+                }
+            }
         }
-      }
-    }
 
-    return rtrim($str, '; ');
-  }
+        return rtrim($str, '; ');
+    }
 
-  /**
+    /**
    *
    */
-  public function toArray() {
-    return $this->data;
-  }
+    public function toArray() 
+    {
+        return $this->data;
+    }
 
-  /**
+    /**
    * Get the cookie name.
    *
    * @return string
    */
-  public function getName() {
-    return $this->data['Name'];
-  }
+    public function getName() 
+    {
+        return $this->data['Name'];
+    }
 
-  /**
+    /**
    * Set the cookie name.
    *
    * @param string $name
    *   Cookie name.
    */
-  public function setName($name) {
-    $this->data['Name'] = $name;
-  }
+    public function setName($name) 
+    {
+        $this->data['Name'] = $name;
+    }
 
-  /**
+    /**
    * Get the cookie value.
    *
    * @return string
    */
-  public function getValue() {
-    return $this->data['Value'];
-  }
+    public function getValue() 
+    {
+        return $this->data['Value'];
+    }
 
-  /**
+    /**
    * Set the cookie value.
    *
    * @param string $value
    *   Cookie value.
    */
-  public function setValue($value) {
-    $this->data['Value'] = $value;
-  }
+    public function setValue($value) 
+    {
+        $this->data['Value'] = $value;
+    }
 
-  /**
+    /**
    * Get the domain.
    *
    * @return string|null
    */
-  public function getDomain() {
-    return $this->data['Domain'];
-  }
+    public function getDomain() 
+    {
+        return $this->data['Domain'];
+    }
 
-  /**
+    /**
    * Set the domain of the cookie.
    *
    * @param string $domain
    */
-  public function setDomain($domain) {
-    $this->data['Domain'] = $domain;
-  }
+    public function setDomain($domain) 
+    {
+        $this->data['Domain'] = $domain;
+    }
 
-  /**
+    /**
    * Get the path.
    *
    * @return string
    */
-  public function getPath() {
-    return $this->data['Path'];
-  }
+    public function getPath() 
+    {
+        return $this->data['Path'];
+    }
 
-  /**
+    /**
    * Set the path of the cookie.
    *
    * @param string $path
    *   Path of the cookie.
    */
-  public function setPath($path) {
-    $this->data['Path'] = $path;
-  }
+    public function setPath($path) 
+    {
+        $this->data['Path'] = $path;
+    }
 
-  /**
+    /**
    * Maximum lifetime of the cookie in seconds.
    *
    * @return int|null
    */
-  public function getMaxAge() {
-    return $this->data['Max-Age'];
-  }
+    public function getMaxAge() 
+    {
+        return $this->data['Max-Age'];
+    }
 
-  /**
+    /**
    * Set the max-age of the cookie.
    *
    * @param int $maxAge
    *   Max age of the cookie in seconds.
    */
-  public function setMaxAge($maxAge) {
-    $this->data['Max-Age'] = $maxAge;
-  }
+    public function setMaxAge($maxAge) 
+    {
+        $this->data['Max-Age'] = $maxAge;
+    }
 
-  /**
+    /**
    * The UNIX timestamp when the cookie Expires.
    *
    * @return mixed
    */
-  public function getExpires() {
-    return $this->data['Expires'];
-  }
+    public function getExpires() 
+    {
+        return $this->data['Expires'];
+    }
 
-  /**
+    /**
    * Set the unix timestamp for which the cookie will expire.
    *
    * @param int $timestamp
    *   Unix timestamp.
    */
-  public function setExpires($timestamp) {
-    $this->data['Expires'] = is_numeric($timestamp)
+    public function setExpires($timestamp) 
+    {
+        $this->data['Expires'] = is_numeric($timestamp)
             ? (int) $timestamp
             : strtotime($timestamp);
-  }
+    }
 
-  /**
+    /**
    * Get whether or not this is a secure cookie.
    *
    * @return null|bool
    */
-  public function getSecure() {
-    return $this->data['Secure'];
-  }
+    public function getSecure() 
+    {
+        return $this->data['Secure'];
+    }
 
-  /**
+    /**
    * Set whether or not the cookie is secure.
    *
    * @param bool $secure
    *   Set to true or false if secure.
    */
-  public function setSecure($secure) {
-    $this->data['Secure'] = $secure;
-  }
+    public function setSecure($secure) 
+    {
+        $this->data['Secure'] = $secure;
+    }
 
-  /**
+    /**
    * Get whether or not this is a session cookie.
    *
    * @return null|bool
    */
-  public function getDiscard() {
-    return $this->data['Discard'];
-  }
+    public function getDiscard() 
+    {
+        return $this->data['Discard'];
+    }
 
-  /**
+    /**
    * Set whether or not this is a session cookie.
    *
    * @param bool $discard
    *   Set to true or false if this is a session cookie.
    */
-  public function setDiscard($discard) {
-    $this->data['Discard'] = $discard;
-  }
+    public function setDiscard($discard) 
+    {
+        $this->data['Discard'] = $discard;
+    }
 
-  /**
+    /**
    * Get whether or not this is an HTTP only cookie.
    *
    * @return bool
    */
-  public function getHttpOnly() {
-    return $this->data['HttpOnly'];
-  }
+    public function getHttpOnly() 
+    {
+        return $this->data['HttpOnly'];
+    }
 
-  /**
+    /**
    * Set whether or not this is an HTTP only cookie.
    *
    * @param bool $httpOnly
    *   Set to true or false if this is HTTP only.
    */
-  public function setHttpOnly($httpOnly) {
-    $this->data['HttpOnly'] = $httpOnly;
-  }
+    public function setHttpOnly($httpOnly) 
+    {
+        $this->data['HttpOnly'] = $httpOnly;
+    }
 
-  /**
+    /**
    * Check if the cookie matches a path value.
    *
    * A request-path path-matches a given cookie-path if at least one of
@@ -302,29 +327,30 @@
    *
    * @return bool
    */
-  public function matchesPath($requestPath) {
-    $cookiePath = $this->getPath();
+    public function matchesPath($requestPath) 
+    {
+        $cookiePath = $this->getPath();
+
+        // Match on exact matches or when path is the default empty "/".
+        if ($cookiePath === '/' || $cookiePath == $requestPath) {
+            return true;
+        }
 
-    // Match on exact matches or when path is the default empty "/".
-    if ($cookiePath === '/' || $cookiePath == $requestPath) {
-      return TRUE;
-    }
+        // Ensure that the cookie-path is a prefix of the request path.
+        if (0 !== strpos($requestPath, $cookiePath)) {
+            return false;
+        }
 
-    // Ensure that the cookie-path is a prefix of the request path.
-    if (0 !== strpos($requestPath, $cookiePath)) {
-      return FALSE;
-    }
+        // Match if the last character of the cookie-path is "/".
+        if (substr($cookiePath, -1, 1) === '/') {
+            return true;
+        }
 
-    // Match if the last character of the cookie-path is "/".
-    if (substr($cookiePath, -1, 1) === '/') {
-      return TRUE;
+        // Match if the first character not included in cookie path is "/".
+        return substr($requestPath, strlen($cookiePath), 1) === '/';
     }
 
-    // Match if the first character not included in cookie path is "/".
-    return substr($requestPath, strlen($cookiePath), 1) === '/';
-  }
-
-  /**
+    /**
    * Check if the cookie matches a domain value.
    *
    * @param string $domain
@@ -332,71 +358,75 @@
    *
    * @return bool
    */
-  public function matchesDomain($domain) {
-    // Remove the leading '.' as per spec in RFC 6265.
-    // http://tools.ietf.org/html/rfc6265#section-5.2.3
-    $cookieDomain = ltrim($this->getDomain(), '.');
+    public function matchesDomain($domain) 
+    {
+        // Remove the leading '.' as per spec in RFC 6265.
+        // http://tools.ietf.org/html/rfc6265#section-5.2.3
+        $cookieDomain = ltrim($this->getDomain(), '.');
+
+        // Domain not set or exact match.
+        if (!$cookieDomain || !strcasecmp($domain, $cookieDomain)) {
+            return true;
+        }
 
-    // Domain not set or exact match.
-    if (!$cookieDomain || !strcasecmp($domain, $cookieDomain)) {
-      return TRUE;
-    }
+        // Matching the subdomain according to RFC 6265.
+        // http://tools.ietf.org/html/rfc6265#section-5.1.3
+        if (filter_var($domain, FILTER_VALIDATE_IP)) {
+            return false;
+        }
 
-    // Matching the subdomain according to RFC 6265.
-    // http://tools.ietf.org/html/rfc6265#section-5.1.3
-    if (filter_var($domain, FILTER_VALIDATE_IP)) {
-      return FALSE;
+        return (bool) preg_match('/\.' . preg_quote($cookieDomain) . '$/', $domain);
     }
 
-    return (bool) preg_match('/\.' . preg_quote($cookieDomain) . '$/', $domain);
-  }
-
-  /**
+    /**
    * Check if the cookie is expired.
    *
    * @return bool
    */
-  public function isExpired() {
-    return $this->getExpires() && time() > $this->getExpires();
-  }
+    public function isExpired() 
+    {
+        return $this->getExpires() && time() > $this->getExpires();
+    }
 
-  /**
+    /**
    * Check if the cookie is valid according to RFC 6265.
    *
    * @return bool|string Returns true if valid or an error message if invalid
    */
-  public function validate() {
-    // Names must not be empty, but can be 0.
-    $name = $this->getName();
-    if (empty($name) && !is_numeric($name)) {
-      return 'The cookie name must not be empty';
-    }
+    public function validate() 
+    {
+        // Names must not be empty, but can be 0.
+        $name = $this->getName();
+        if (empty($name) && !is_numeric($name)) {
+            return 'The cookie name must not be empty';
+        }
 
-    // Check if any of the invalid characters are present in the cookie name.
-    if (preg_match(
-        '/[\x00-\x20\x22\x28-\x29\x2c\x2f\x3a-\x40\x5c\x7b\x7d\x7f]/',
-        $name)
-    ) {
-      return 'Cookie name must not contain invalid characters: ASCII '
+        // Check if any of the invalid characters are present in the cookie name.
+        if (preg_match(
+            '/[\x00-\x20\x22\x28-\x29\x2c\x2f\x3a-\x40\x5c\x7b\x7d\x7f]/',
+            $name
+        )
+        ) {
+            return 'Cookie name must not contain invalid characters: ASCII '
                 . 'Control characters (0-31;127), space, tab and the '
                 . 'following characters: ()<>@,;:\"/?={}';
-    }
+        }
 
-    // Value must not be empty, but can be 0.
-    $value = $this->getValue();
-    if (empty($value) && !is_numeric($value)) {
-      return 'The cookie value must not be empty';
-    }
-
-    // Domains must not be empty, but can be 0
-    // A "0" is not a valid internet domain, but may be used as server name
-    // in a private network.
-    $domain = $this->getDomain();
-    if (empty($domain) && !is_numeric($domain)) {
-      return 'The cookie domain must not be empty';
-    }
+        // Value must not be empty, but can be 0.
+        $value = $this->getValue();
+        if (empty($value) && !is_numeric($value)) {
+            return 'The cookie value must not be empty';
+        }
 
-    return TRUE;
-  }
+        // Domains must not be empty, but can be 0
+        // A "0" is not a valid internet domain, but may be used as server name
+        // in a private network.
+        $domain = $this->getDomain();
+        if (empty($domain) && !is_numeric($domain)) {
+            return 'The cookie domain must not be empty';
+        }
+
+        return true;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Cookie/FileCookieJar.php
+++ PHP_CodeSniffer
@@ -5,43 +5,48 @@
 /**
  * Persists non-session cookies using a JSON formatted file.
  */
-class FileCookieJar extends CookieJar {
-  /**
-   * @var stringfilename*/
-  private $filename;
-
-  /**
-   * @var boolControlwhethertopersistsessioncookiesornot*/
-  private $storeSessionCookies;
+class FileCookieJar extends CookieJar
+{
+    /**
+   * @var stringfilename
+*/
+    private $filename;
+
+    /**
+   * @var boolControlwhethertopersistsessioncookiesornot
+*/
+    private $storeSessionCookies;
 
-  /**
+    /**
    * Create a new FileCookieJar object.
    *
    * @param string $cookieFile
    *   File to store the cookie data.
-   * @param bool $storeSessionCookies
+   * @param bool   $storeSessionCookies
    *   Set to true to store session cookies
    *   in the cookie jar.
    *
    * @throws \RuntimeException if the file cannot be found or created
    */
-  public function __construct($cookieFile, $storeSessionCookies = FALSE) {
-    $this->filename = $cookieFile;
-    $this->storeSessionCookies = $storeSessionCookies;
+    public function __construct($cookieFile, $storeSessionCookies = false) 
+    {
+        $this->filename = $cookieFile;
+        $this->storeSessionCookies = $storeSessionCookies;
 
-    if (file_exists($cookieFile)) {
-      $this->load($cookieFile);
+        if (file_exists($cookieFile)) {
+            $this->load($cookieFile);
+        }
     }
-  }
 
-  /**
+    /**
    * Saves the file when shutting down.
    */
-  public function __destruct() {
-    $this->save($this->filename);
-  }
+    public function __destruct() 
+    {
+        $this->save($this->filename);
+    }
 
-  /**
+    /**
    * Saves the cookies to a file.
    *
    * @param string $filename
@@ -49,22 +54,25 @@
    *
    * @throws \RuntimeException if the file cannot be found or created
    */
-  public function save($filename) {
-    $json = [];
-    foreach ($this as $cookie) {
-      /** @var SetCookie $cookie */
-      if (CookieJar::shouldPersist($cookie, $this->storeSessionCookies)) {
-        $json[] = $cookie->toArray();
-      }
-    }
-
-    $jsonStr = \GuzzleHttp\json_encode($json);
-    if (FALSE === file_put_contents($filename, $jsonStr)) {
-      throw new \RuntimeException("Unable to save file {$filename}");
+    public function save($filename) 
+    {
+        $json = [];
+        foreach ($this as $cookie) {
+            /**
+ * @var SetCookie $cookie 
+*/
+            if (CookieJar::shouldPersist($cookie, $this->storeSessionCookies)) {
+                $json[] = $cookie->toArray();
+            }
+        }
+
+        $jsonStr = \GuzzleHttp\json_encode($json);
+        if (false === file_put_contents($filename, $jsonStr)) {
+            throw new \RuntimeException("Unable to save file {$filename}");
+        }
     }
-  }
 
-  /**
+    /**
    * Load cookies from a JSON formatted file.
    *
    * Old cookies are kept unless overwritten by newly loaded ones.
@@ -74,24 +82,25 @@
    *
    * @throws \RuntimeException if the file cannot be loaded.
    */
-  public function load($filename) {
-    $json = file_get_contents($filename);
-    if (FALSE === $json) {
-      throw new \RuntimeException("Unable to load file {$filename}");
-    }
-    elseif ($json === '') {
-      return;
-    }
-
-    $data = \GuzzleHttp\json_decode($json, TRUE);
-    if (is_array($data)) {
-      foreach (json_decode($json, TRUE) as $cookie) {
-        $this->setCookie(new SetCookie($cookie));
-      }
-    }
-    elseif (strlen($data)) {
-      throw new \RuntimeException("Invalid cookie file: {$filename}");
+    public function load($filename) 
+    {
+        $json = file_get_contents($filename);
+        if (false === $json) {
+            throw new \RuntimeException("Unable to load file {$filename}");
+        }
+        elseif ($json === '') {
+            return;
+        }
+
+        $data = \GuzzleHttp\json_decode($json, true);
+        if (is_array($data)) {
+            foreach (json_decode($json, true) as $cookie) {
+                $this->setCookie(new SetCookie($cookie));
+            }
+        }
+        elseif (strlen($data)) {
+            throw new \RuntimeException("Invalid cookie file: {$filename}");
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Cookie/CookieJar.php
+++ PHP_CodeSniffer
@@ -8,17 +8,20 @@
 /**
  * Cookie jar that stores cookies as an array.
  */
-class CookieJar implements CookieJarInterface {
-  /**
-   * @var SetCookie[]Loadedcookiedata*/
-  private $cookies = [];
-
-  /**
-   * @var bool*/
-  private $strictMode;
+class CookieJar implements CookieJarInterface
+{
+    /**
+   * @var SetCookie[]Loadedcookiedata
+*/
+    private $cookies = [];
+
+    /**
+   * @var bool
+*/
+    private $strictMode;
 
-  /**
-   * @param bool $strictMode
+    /**
+   * @param bool  $strictMode
    *   Set to true to throw exceptions when invalid
    *   cookies are added to the cookie jar.
    * @param array $cookieArray
@@ -26,73 +29,80 @@
    *   arrays that can be used with the SetCookie
    *                           constructor.
    */
-  public function __construct($strictMode = FALSE, $cookieArray = []) {
-    $this->strictMode = $strictMode;
-
-    foreach ($cookieArray as $cookie) {
-      if (!($cookie instanceof SetCookie)) {
-        $cookie = new SetCookie($cookie);
-      }
-      $this->setCookie($cookie);
+    public function __construct($strictMode = false, $cookieArray = []) 
+    {
+        $this->strictMode = $strictMode;
+
+        foreach ($cookieArray as $cookie) {
+            if (!($cookie instanceof SetCookie)) {
+                $cookie = new SetCookie($cookie);
+            }
+            $this->setCookie($cookie);
+        }
     }
-  }
 
-  /**
+    /**
    * Create a new Cookie jar from an associative array and domain.
    *
-   * @param array $cookies
+   * @param array  $cookies
    *   Cookies to create the jar from.
    * @param string $domain
    *   Domain to set the cookies to.
    *
    * @return self
    */
-  public static function fromArray(array $cookies, $domain) {
-    $cookieJar = new self();
-    foreach ($cookies as $name => $value) {
-      $cookieJar->setCookie(new SetCookie([
-        'Domain'  => $domain,
-        'Name'    => $name,
-        'Value'   => $value,
-        'Discard' => TRUE,
-      ]));
-    }
+    public static function fromArray(array $cookies, $domain) 
+    {
+        $cookieJar = new self();
+        foreach ($cookies as $name => $value) {
+            $cookieJar->setCookie(
+                new SetCookie(
+                    [
+                    'Domain'  => $domain,
+                    'Name'    => $name,
+                    'Value'   => $value,
+                    'Discard' => true,
+                    ]
+                )
+            );
+        }
 
-    return $cookieJar;
-  }
+        return $cookieJar;
+    }
 
-  /**
+    /**
    * @deprecated
    */
-  public static function getCookieValue($value) {
-    return $value;
-  }
+    public static function getCookieValue($value) 
+    {
+        return $value;
+    }
 
-  /**
+    /**
    * Evaluate if this cookie should be persisted to storage
    * that survives between requests.
    *
    * @param SetCookie $cookie
    *   Being evaluated.
-   * @param bool $allowSessionCookies
+   * @param bool      $allowSessionCookies
    *   If we should persist session cookies.
    *
    * @return bool
    */
-  public static function shouldPersist(
+    public static function shouldPersist(
         SetCookie $cookie,
-        $allowSessionCookies = FALSE
+        $allowSessionCookies = false
     ) {
-    if ($cookie->getExpires() || $allowSessionCookies) {
-      if (!$cookie->getDiscard()) {
-        return TRUE;
-      }
-    }
+        if ($cookie->getExpires() || $allowSessionCookies) {
+            if (!$cookie->getDiscard()) {
+                return true;
+            }
+        }
 
-    return FALSE;
-  }
+        return false;
+    }
 
-  /**
+    /**
    * Finds and returns the cookie based on the name.
    *
    * @param string $name
@@ -100,176 +110,185 @@
    *
    * @return SetCookie|null cookie that was found or null if not found
    */
-  public function getCookieByName($name) {
-    // don't allow a null name.
-    if ($name === NULL) {
-      return NULL;
-    }
-    foreach ($this->cookies as $cookie) {
-      if ($cookie->getName() !== NULL && strcasecmp($cookie->getName(), $name) === 0) {
-        return $cookie;
-      }
+    public function getCookieByName($name) 
+    {
+        // don't allow a null name.
+        if ($name === null) {
+            return null;
+        }
+        foreach ($this->cookies as $cookie) {
+            if ($cookie->getName() !== null && strcasecmp($cookie->getName(), $name) === 0) {
+                return $cookie;
+            }
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function toArray() {
-    return array_map(function (SetCookie $cookie) {
-      return $cookie->toArray();
-    }, $this->getIterator()->getArrayCopy());
-  }
+    public function toArray() 
+    {
+        return array_map(
+            function (SetCookie $cookie) {
+                return $cookie->toArray();
+            }, $this->getIterator()->getArrayCopy()
+        );
+    }
 
-  /**
+    /**
    *
    */
-  public function clear($domain = NULL, $path = NULL, $name = NULL) {
-    if (!$domain) {
-      $this->cookies = [];
-      return;
-    }
-    elseif (!$path) {
-      $this->cookies = array_filter(
-        $this->cookies,
-        function (SetCookie $cookie) use ($path, $domain) {
-            return !$cookie->matchesDomain($domain);
+    public function clear($domain = null, $path = null, $name = null) 
+    {
+        if (!$domain) {
+            $this->cookies = [];
+            return;
         }
-        );
-    }
-    elseif (!$name) {
-      $this->cookies = array_filter(
-        $this->cookies,
-        function (SetCookie $cookie) use ($path, $domain) {
-            return !($cookie->matchesPath($path) &&
-                $cookie->matchesDomain($domain));
+        elseif (!$path) {
+            $this->cookies = array_filter(
+                $this->cookies,
+                function (SetCookie $cookie) use ($path, $domain) {
+                    return !$cookie->matchesDomain($domain);
+                }
+            );
         }
-        );
-    }
-    else {
-      $this->cookies = array_filter(
-        $this->cookies,
-        function (SetCookie $cookie) use ($path, $domain, $name) {
-            return !($cookie->getName() == $name &&
-                $cookie->matchesPath($path) &&
-                $cookie->matchesDomain($domain));
+        elseif (!$name) {
+            $this->cookies = array_filter(
+                $this->cookies,
+                function (SetCookie $cookie) use ($path, $domain) {
+                    return !($cookie->matchesPath($path) &&
+                    $cookie->matchesDomain($domain));
+                }
+            );
+        }
+        else {
+            $this->cookies = array_filter(
+                $this->cookies,
+                function (SetCookie $cookie) use ($path, $domain, $name) {
+                    return !($cookie->getName() == $name &&
+                    $cookie->matchesPath($path) &&
+                    $cookie->matchesDomain($domain));
+                }
+            );
         }
-        );
     }
-  }
 
-  /**
+    /**
    *
    */
-  public function clearSessionCookies() {
-    $this->cookies = array_filter(
-        $this->cookies,
-        function (SetCookie $cookie) {
-            return !$cookie->getDiscard() && $cookie->getExpires();
-        }
-    );
-  }
+    public function clearSessionCookies() 
+    {
+        $this->cookies = array_filter(
+            $this->cookies,
+            function (SetCookie $cookie) {
+                return !$cookie->getDiscard() && $cookie->getExpires();
+            }
+        );
+    }
 
-  /**
+    /**
    *
    */
-  public function setCookie(SetCookie $cookie) {
-    // If the name string is empty (but not 0), ignore the set-cookie
-    // string entirely.
-    $name = $cookie->getName();
-    if (!$name && $name !== '0') {
-      return FALSE;
-    }
-
-    // Only allow cookies with set and valid domain, name, value.
-    $result = $cookie->validate();
-    if ($result !== TRUE) {
-      if ($this->strictMode) {
-        throw new \RuntimeException('Invalid cookie: ' . $result);
-      }
-      else {
-        $this->removeCookieIfEmpty($cookie);
-        return FALSE;
-      }
-    }
+    public function setCookie(SetCookie $cookie) 
+    {
+        // If the name string is empty (but not 0), ignore the set-cookie
+        // string entirely.
+        $name = $cookie->getName();
+        if (!$name && $name !== '0') {
+            return false;
+        }
 
-    // Resolve conflicts with previously set cookies.
-    foreach ($this->cookies as $i => $c) {
+        // Only allow cookies with set and valid domain, name, value.
+        $result = $cookie->validate();
+        if ($result !== true) {
+            if ($this->strictMode) {
+                throw new \RuntimeException('Invalid cookie: ' . $result);
+            }
+            else {
+                $this->removeCookieIfEmpty($cookie);
+                return false;
+            }
+        }
 
-      // Two cookies are identical, when their path, and domain are
-      // identical.
-      if ($c->getPath() != $cookie->getPath() ||
-        $c->getDomain() != $cookie->getDomain() ||
-        $c->getName() != $cookie->getName()
-      ) {
-        continue;
-      }
+        // Resolve conflicts with previously set cookies.
+        foreach ($this->cookies as $i => $c) {
 
-      // The previously set cookie is a discard cookie and this one is
-      // not so allow the new cookie to be set.
-      if (!$cookie->getDiscard() && $c->getDiscard()) {
-        unset($this->cookies[$i]);
-        continue;
-      }
+            // Two cookies are identical, when their path, and domain are
+            // identical.
+            if ($c->getPath() != $cookie->getPath() 
+                || $c->getDomain() != $cookie->getDomain() 
+                || $c->getName() != $cookie->getName()
+            ) {
+                continue;
+            }
+
+            // The previously set cookie is a discard cookie and this one is
+            // not so allow the new cookie to be set.
+            if (!$cookie->getDiscard() && $c->getDiscard()) {
+                unset($this->cookies[$i]);
+                continue;
+            }
+
+            // If the new cookie's expiration is further into the future, then
+            // replace the old cookie.
+            if ($cookie->getExpires() > $c->getExpires()) {
+                unset($this->cookies[$i]);
+                continue;
+            }
+
+            // If the value has changed, we better change it.
+            if ($cookie->getValue() !== $c->getValue()) {
+                unset($this->cookies[$i]);
+                continue;
+            }
 
-      // If the new cookie's expiration is further into the future, then
-      // replace the old cookie.
-      if ($cookie->getExpires() > $c->getExpires()) {
-        unset($this->cookies[$i]);
-        continue;
-      }
+            // The cookie exists, so no need to continue.
+            return false;
+        }
 
-      // If the value has changed, we better change it.
-      if ($cookie->getValue() !== $c->getValue()) {
-        unset($this->cookies[$i]);
-        continue;
-      }
+        $this->cookies[] = $cookie;
 
-      // The cookie exists, so no need to continue.
-      return FALSE;
+        return true;
     }
 
-    $this->cookies[] = $cookie;
-
-    return TRUE;
-  }
-
-  /**
+    /**
    *
    */
-  public function count() {
-    return count($this->cookies);
-  }
+    public function count() 
+    {
+        return count($this->cookies);
+    }
 
-  /**
+    /**
    *
    */
-  public function getIterator() {
-    return new \ArrayIterator(array_values($this->cookies));
-  }
+    public function getIterator() 
+    {
+        return new \ArrayIterator(array_values($this->cookies));
+    }
 
-  /**
+    /**
    *
    */
-  public function extractCookies(
+    public function extractCookies(
         RequestInterface $request,
         ResponseInterface $response
     ) {
-    if ($cookieHeader = $response->getHeader('Set-Cookie')) {
-      foreach ($cookieHeader as $cookie) {
-        $sc = SetCookie::fromString($cookie);
-        if (!$sc->getDomain()) {
-          $sc->setDomain($request->getUri()->getHost());
+        if ($cookieHeader = $response->getHeader('Set-Cookie')) {
+            foreach ($cookieHeader as $cookie) {
+                $sc = SetCookie::fromString($cookie);
+                if (!$sc->getDomain()) {
+                    $sc->setDomain($request->getUri()->getHost());
+                }
+                if (0 !== strpos($sc->getPath(), '/')) {
+                    $sc->setPath($this->getCookiePathFromRequest($request));
+                }
+                $this->setCookie($sc);
+            }
         }
-        if (0 !== strpos($sc->getPath(), '/')) {
-          $sc->setPath($this->getCookiePathFromRequest($request));
-        }
-        $this->setCookie($sc);
-      }
     }
-  }
 
-  /**
+    /**
    * Computes cookie path following RFC 6265 section 5.1.4.
    *
    * @link https://tools.ietf.org/html/rfc6265#section-5.1.4
@@ -278,65 +297,68 @@
    *
    * @return string
    */
-  private function getCookiePathFromRequest(RequestInterface $request) {
-    $uriPath = $request->getUri()->getPath();
-    if ('' === $uriPath) {
-      return '/';
-    }
-    if (0 !== strpos($uriPath, '/')) {
-      return '/';
-    }
-    if ('/' === $uriPath) {
-      return '/';
-    }
-    if (0 === $lastSlashPos = strrpos($uriPath, '/')) {
-      return '/';
-    }
+    private function getCookiePathFromRequest(RequestInterface $request) 
+    {
+        $uriPath = $request->getUri()->getPath();
+        if ('' === $uriPath) {
+            return '/';
+        }
+        if (0 !== strpos($uriPath, '/')) {
+            return '/';
+        }
+        if ('/' === $uriPath) {
+            return '/';
+        }
+        if (0 === $lastSlashPos = strrpos($uriPath, '/')) {
+            return '/';
+        }
 
-    return substr($uriPath, 0, $lastSlashPos);
-  }
+        return substr($uriPath, 0, $lastSlashPos);
+    }
 
-  /**
+    /**
    *
    */
-  public function withCookieHeader(RequestInterface $request) {
-    $values = [];
-    $uri = $request->getUri();
-    $scheme = $uri->getScheme();
-    $host = $uri->getHost();
-    $path = $uri->getPath() ?: '/';
-
-    foreach ($this->cookies as $cookie) {
-      if ($cookie->matchesPath($path) &&
-        $cookie->matchesDomain($host) &&
-        !$cookie->isExpired() &&
-        (!$cookie->getSecure() || $scheme === 'https')
-      ) {
-        $values[] = $cookie->getName() . '='
+    public function withCookieHeader(RequestInterface $request) 
+    {
+        $values = [];
+        $uri = $request->getUri();
+        $scheme = $uri->getScheme();
+        $host = $uri->getHost();
+        $path = $uri->getPath() ?: '/';
+
+        foreach ($this->cookies as $cookie) {
+            if ($cookie->matchesPath($path) 
+                && $cookie->matchesDomain($host) 
+                && !$cookie->isExpired() 
+                && (!$cookie->getSecure() || $scheme === 'https')
+            ) {
+                $values[] = $cookie->getName() . '='
                     . $cookie->getValue();
-      }
-    }
+            }
+        }
 
-    return $values
+        return $values
             ? $request->withHeader('Cookie', implode('; ', $values))
             : $request;
-  }
+    }
 
-  /**
+    /**
    * If a cookie already exists and the server asks to set it again with a
    * null value, the cookie must be deleted.
    *
    * @param SetCookie $cookie
    */
-  private function removeCookieIfEmpty(SetCookie $cookie) {
-    $cookieValue = $cookie->getValue();
-    if ($cookieValue === NULL || $cookieValue === '') {
-      $this->clear(
-        $cookie->getDomain(),
-        $cookie->getPath(),
-        $cookie->getName()
-      );
+    private function removeCookieIfEmpty(SetCookie $cookie) 
+    {
+        $cookieValue = $cookie->getValue();
+        if ($cookieValue === null || $cookieValue === '') {
+            $this->clear(
+                $cookie->getDomain(),
+                $cookie->getPath(),
+                $cookie->getName()
+            );
+        }
     }
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Middleware.php
+++ PHP_CodeSniffer
@@ -11,9 +11,10 @@
 /**
  * Functions used to create and wrap handlers with handler middleware.
  */
-final class Middleware {
+final class Middleware
+{
 
-  /**
+    /**
    * Middleware that adds cookies to requests.
    *
    * The options array must be set to a CookieJarInterface in order to use
@@ -21,53 +22,56 @@
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function cookies() {
-    return function (callable $handler) {
-      return function ($request, array $options) use ($handler) {
-        if (empty($options['cookies'])) {
-          return $handler($request, $options);
-        }
-        elseif (!($options['cookies'] instanceof CookieJarInterface)) {
-          throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');
-        }
-        $cookieJar = $options['cookies'];
-        $request = $cookieJar->withCookieHeader($request);
-        return $handler($request, $options)
-          ->then(function ($response) use ($cookieJar, $request) {
+    public static function cookies() 
+    {
+        return function (callable $handler) {
+            return function ($request, array $options) use ($handler) {
+                if (empty($options['cookies'])) {
+                    return $handler($request, $options);
+                }
+                elseif (!($options['cookies'] instanceof CookieJarInterface)) {
+                    throw new \InvalidArgumentException('cookies must be an instance of GuzzleHttp\Cookie\CookieJarInterface');
+                }
+                $cookieJar = $options['cookies'];
+                $request = $cookieJar->withCookieHeader($request);
+                return $handler($request, $options)
+                ->then(
+                    function ($response) use ($cookieJar, $request) {
                         $cookieJar->extractCookies($request, $response);
                         return $response;
-          }
-        );
-      };
-    };
-  }
+                    }
+                );
+            };
+        };
+    }
 
-  /**
+    /**
    * Middleware that throws exceptions for 4xx or 5xx responses when the
    * "http_error" request option is set to true.
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function httpErrors() {
-    return function (callable $handler) {
-      return function ($request, array $options) use ($handler) {
-        if (empty($options['http_errors'])) {
-          return $handler($request, $options);
-        }
-        return $handler($request, $options)->then(
-        function (ResponseInterface $response) use ($request, $handler) {
-            $code = $response->getStatusCode();
-          if ($code < 400) {
-            return $response;
-          }
-            throw RequestException::create($request, $response);
-        }
-        );
-      };
-    };
-  }
+    public static function httpErrors() 
+    {
+        return function (callable $handler) {
+            return function ($request, array $options) use ($handler) {
+                if (empty($options['http_errors'])) {
+                    return $handler($request, $options);
+                }
+                return $handler($request, $options)->then(
+                    function (ResponseInterface $response) use ($request, $handler) {
+                        $code = $response->getStatusCode();
+                        if ($code < 400) {
+                            return $response;
+                        }
+                        throw RequestException::create($request, $response);
+                    }
+                );
+            };
+        };
+    }
 
-  /**
+    /**
    * Middleware that pushes history data to an ArrayAccess container.
    *
    * @param array $container
@@ -77,38 +81,39 @@
    *
    * @throws \InvalidArgumentException if container is not an array or ArrayAccess.
    */
-  public static function history(&$container) {
-    if (!is_array($container) && !$container instanceof \ArrayAccess) {
-      throw new \InvalidArgumentException('history container must be an array or object implementing ArrayAccess');
-    }
-
-    return function (callable $handler) use (&$container) {
-      return function ($request, array $options) use ($handler, &$container) {
-        return $handler($request, $options)->then(
-        function ($value) use ($request, &$container, $options) {
-            $container[] = [
-              'request'  => $request,
-              'response' => $value,
-              'error'    => NULL,
-              'options'  => $options,
-            ];
-            return $value;
-        },
-                function ($reason) use ($request, &$container, $options) {
-                  $container[] = [
-                    'request'  => $request,
-                    'response' => NULL,
-                    'error'    => $reason,
-                    'options'  => $options,
-                  ];
-                  return \GuzzleHttp\Promise\rejection_for($reason);
-                }
-        );
-      };
-    };
-  }
+    public static function history(&$container) 
+    {
+        if (!is_array($container) && !$container instanceof \ArrayAccess) {
+            throw new \InvalidArgumentException('history container must be an array or object implementing ArrayAccess');
+        }
+
+        return function (callable $handler) use (&$container) {
+            return function ($request, array $options) use ($handler, &$container) {
+                return $handler($request, $options)->then(
+                    function ($value) use ($request, &$container, $options) {
+                        $container[] = [
+                        'request'  => $request,
+                        'response' => $value,
+                        'error'    => null,
+                        'options'  => $options,
+                        ];
+                        return $value;
+                    },
+                    function ($reason) use ($request, &$container, $options) {
+                        $container[] = [
+                        'request'  => $request,
+                        'response' => null,
+                        'error'    => $reason,
+                        'options'  => $options,
+                        ];
+                        return \GuzzleHttp\Promise\rejection_for($reason);
+                    }
+                );
+            };
+        };
+    }
 
-  /**
+    /**
    * Middleware that invokes a callback before and after sending a request.
    *
    * The provided listener cannot modify or alter the response. It simply
@@ -123,33 +128,35 @@
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function tap(callable $before = NULL, callable $after = NULL) {
-    return function (callable $handler) use ($before, $after) {
-      return function ($request, array $options) use ($handler, $before, $after) {
-        if ($before) {
-          $before($request, $options);
-        }
-        $response = $handler($request, $options);
-        if ($after) {
-          $after($request, $options, $response);
-        }
-        return $response;
-      };
-    };
-  }
+    public static function tap(callable $before = null, callable $after = null) 
+    {
+        return function (callable $handler) use ($before, $after) {
+            return function ($request, array $options) use ($handler, $before, $after) {
+                if ($before) {
+                    $before($request, $options);
+                }
+                $response = $handler($request, $options);
+                if ($after) {
+                    $after($request, $options, $response);
+                }
+                return $response;
+            };
+        };
+    }
 
-  /**
+    /**
    * Middleware that handles request redirects.
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function redirect() {
-    return function (callable $handler) {
-      return new RedirectMiddleware($handler);
-    };
-  }
+    public static function redirect() 
+    {
+        return function (callable $handler) {
+            return new RedirectMiddleware($handler);
+        };
+    }
 
-  /**
+    /**
    * Middleware that retries requests based on the boolean result of
    * invoking the provided "decider" function.
    *
@@ -166,60 +173,63 @@
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function retry(callable $decider, callable $delay = NULL) {
-    return function (callable $handler) use ($decider, $delay) {
-      return new RetryMiddleware($decider, $handler, $delay);
-    };
-  }
+    public static function retry(callable $decider, callable $delay = null) 
+    {
+        return function (callable $handler) use ($decider, $delay) {
+            return new RetryMiddleware($decider, $handler, $delay);
+        };
+    }
 
-  /**
+    /**
    * Middleware that logs requests, responses, and errors using a message
    * formatter.
    *
    * @param \Psr\Log\LoggerInterface $logger
    *   Logs messages.
-   * @param MessageFormatter $formatter
+   * @param MessageFormatter         $formatter
    *   Formatter used to create message strings.
-   * @param string $logLevel
+   * @param string                   $logLevel
    *   Level at which to log requests.
    *
    * @return callable Returns a function that accepts the next handler.
    */
-  public static function log(LoggerInterface $logger, MessageFormatter $formatter, $logLevel = LogLevel::INFO) {
-    return function (callable $handler) use ($logger, $formatter, $logLevel) {
-      return function ($request, array $options) use ($handler, $logger, $formatter, $logLevel) {
-        return $handler($request, $options)->then(
-        function ($response) use ($logger, $request, $formatter, $logLevel) {
-            $message = $formatter->format($request, $response);
-            $logger->log($logLevel, $message);
-            return $response;
-        },
-                function ($reason) use ($logger, $request, $formatter) {
-                  $response = $reason instanceof RequestException
-                      ? $reason->getResponse()
-                      : NULL;
-                  $message = $formatter->format($request, $response, $reason);
-                  $logger->notice($message);
-                  return \GuzzleHttp\Promise\rejection_for($reason);
-                }
-        );
-      };
-    };
-  }
+    public static function log(LoggerInterface $logger, MessageFormatter $formatter, $logLevel = LogLevel::INFO) 
+    {
+        return function (callable $handler) use ($logger, $formatter, $logLevel) {
+            return function ($request, array $options) use ($handler, $logger, $formatter, $logLevel) {
+                return $handler($request, $options)->then(
+                    function ($response) use ($logger, $request, $formatter, $logLevel) {
+                        $message = $formatter->format($request, $response);
+                        $logger->log($logLevel, $message);
+                        return $response;
+                    },
+                    function ($reason) use ($logger, $request, $formatter) {
+                        $response = $reason instanceof RequestException
+                        ? $reason->getResponse()
+                        : null;
+                        $message = $formatter->format($request, $response, $reason);
+                        $logger->notice($message);
+                        return \GuzzleHttp\Promise\rejection_for($reason);
+                    }
+                );
+            };
+        };
+    }
 
-  /**
+    /**
    * This middleware adds a default content-type if possible, a default
    * content-length or transfer-encoding header, and the expect header.
    *
    * @return callable
    */
-  public static function prepareBody() {
-    return function (callable $handler) {
-      return new PrepareBodyMiddleware($handler);
-    };
-  }
+    public static function prepareBody() 
+    {
+        return function (callable $handler) {
+            return new PrepareBodyMiddleware($handler);
+        };
+    }
 
-  /**
+    /**
    * Middleware that applies a map function to the request before passing to
    * the next handler.
    *
@@ -229,15 +239,16 @@
    *
    * @return callable
    */
-  public static function mapRequest(callable $fn) {
-    return function (callable $handler) use ($fn) {
-      return function ($request, array $options) use ($handler, $fn) {
-        return $handler($fn($request), $options);
-      };
-    };
-  }
+    public static function mapRequest(callable $fn) 
+    {
+        return function (callable $handler) use ($fn) {
+            return function ($request, array $options) use ($handler, $fn) {
+                return $handler($fn($request), $options);
+            };
+        };
+    }
 
-  /**
+    /**
    * Middleware that applies a map function to the resolved promise's
    * response.
    *
@@ -247,12 +258,13 @@
    *
    * @return callable
    */
-  public static function mapResponse(callable $fn) {
-    return function (callable $handler) use ($fn) {
-      return function ($request, array $options) use ($handler, $fn) {
-        return $handler($request, $options)->then($fn);
-      };
-    };
-  }
+    public static function mapResponse(callable $fn) 
+    {
+        return function (callable $handler) use ($fn) {
+            return function ($request, array $options) use ($handler, $fn) {
+                return $handler($request, $options)->then($fn);
+            };
+        };
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/RetryMiddleware.php
+++ PHP_CodeSniffer
@@ -9,16 +9,19 @@
  * Middleware that retries requests based on the boolean result of
  * invoking the provided "decider" function.
  */
-class RetryMiddleware {
-  /**
-   * @var callable*/
-  private $nextHandler;
-
-  /**
-   * @var callable*/
-  private $decider;
+class RetryMiddleware
+{
+    /**
+   * @var callable
+*/
+    private $nextHandler;
+
+    /**
+   * @var callable
+*/
+    private $decider;
 
-  /**
+    /**
    * @param callable $decider
    *   Function that accepts the number of retries,
    *   a request, [response], and [exception] and
@@ -31,89 +34,96 @@
    *   and [response] and returns the number of
    *                              milliseconds to delay.
    */
-  public function __construct(
+    public function __construct(
         callable $decider,
         callable $nextHandler,
-        callable $delay = NULL
+        callable $delay = null
     ) {
-    $this->decider = $decider;
-    $this->nextHandler = $nextHandler;
-    $this->delay = $delay ?: __CLASS__ . '::exponentialDelay';
-  }
+        $this->decider = $decider;
+        $this->nextHandler = $nextHandler;
+        $this->delay = $delay ?: __CLASS__ . '::exponentialDelay';
+    }
 
-  /**
+    /**
    * Default exponential backoff delay function.
    *
    * @param $retries
    *
    * @return int
    */
-  public static function exponentialDelay($retries) {
-    return (int) pow(2, $retries - 1);
-  }
+    public static function exponentialDelay($retries) 
+    {
+        return (int) pow(2, $retries - 1);
+    }
 
-  /**
+    /**
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  public function __invoke(RequestInterface $request, array $options) {
-    if (!isset($options['retries'])) {
-      $options['retries'] = 0;
-    }
-
-    $fn = $this->nextHandler;
-    return $fn($request, $options)
-      ->then(
+    public function __invoke(RequestInterface $request, array $options) 
+    {
+        if (!isset($options['retries'])) {
+            $options['retries'] = 0;
+        }
+
+        $fn = $this->nextHandler;
+        return $fn($request, $options)
+        ->then(
             $this->onFulfilled($request, $options),
             $this->onRejected($request, $options)
         );
-  }
+    }
 
-  /**
+    /**
    *
    */
-  private function onFulfilled(RequestInterface $req, array $options) {
-    return function ($value) use ($req, $options) {
-      if (!call_user_func(
-        $this->decider,
-        $options['retries'],
-        $req,
-        $value,
-        NULL
-      )) {
-        return $value;
-      }
-      return $this->doRetry($req, $options, $value);
-    };
-  }
-
-  /**
-   *
-   */
-  private function onRejected(RequestInterface $req, array $options) {
-    return function ($reason) use ($req, $options) {
-      if (!call_user_func(
-        $this->decider,
-        $options['retries'],
-        $req,
-        NULL,
-        $reason
-      )) {
-        return \GuzzleHttp\Promise\rejection_for($reason);
-      }
-      return $this->doRetry($req, $options);
-    };
-  }
+    private function onFulfilled(RequestInterface $req, array $options) 
+    {
+        return function ($value) use ($req, $options) {
+            if (!call_user_func(
+                $this->decider,
+                $options['retries'],
+                $req,
+                $value,
+                null
+            )
+            ) {
+                return $value;
+            }
+            return $this->doRetry($req, $options, $value);
+        };
+    }
 
-  /**
+    /**
    *
    */
-  private function doRetry(RequestInterface $request, array $options, ResponseInterface $response = NULL) {
-    $options['delay'] = call_user_func($this->delay, ++$options['retries'], $response);
+    private function onRejected(RequestInterface $req, array $options) 
+    {
+        return function ($reason) use ($req, $options) {
+            if (!call_user_func(
+                $this->decider,
+                $options['retries'],
+                $req,
+                null,
+                $reason
+            )
+            ) {
+                return \GuzzleHttp\Promise\rejection_for($reason);
+            }
+            return $this->doRetry($req, $options);
+        };
+    }
 
-    return $this($request, $options);
-  }
+    /**
+   *
+   */
+    private function doRetry(RequestInterface $request, array $options, ResponseInterface $response = null) 
+    {
+        $options['delay'] = call_user_func($this->delay, ++$options['retries'], $response);
+
+        return $this($request, $options);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/MessageFormatter.php
+++ PHP_CodeSniffer
@@ -34,176 +34,183 @@
  * - {req_body}:       Request body
  * - {res_body}:       Response body
  */
-class MessageFormatter {
-  /**
+class MessageFormatter
+{
+    /**
      * Apache Common Log Format.
+   *
      * @link http://httpd.apache.org/docs/2.4/logs.html#common
-     * @var string
+     * @var  string
      */
-  const CLF = "{hostname} {req_header_User-Agent} - [{date_common_log}] \"{method} {target} HTTP/{version}\" {code} {res_header_Content-Length}";
-  const DEBUG = ">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}";
-  const SHORT = '[{ts}] "{method} {target} HTTP/{version}" {code}';
-
-  /**
-   * @var stringTemplateusedtoformatlogmessages*/
-  private $template;
+    const CLF = "{hostname} {req_header_User-Agent} - [{date_common_log}] \"{method} {target} HTTP/{version}\" {code} {res_header_Content-Length}";
+    const DEBUG = ">>>>>>>>\n{request}\n<<<<<<<<\n{response}\n--------\n{error}";
+    const SHORT = '[{ts}] "{method} {target} HTTP/{version}" {code}';
+
+    /**
+   * @var stringTemplateusedtoformatlogmessages
+*/
+    private $template;
 
-  /**
+    /**
    * @param string $template
    *   Log message template.
    */
-  public function __construct($template = self::CLF) {
-    $this->template = $template ?: self::CLF;
-  }
+    public function __construct($template = self::CLF) 
+    {
+        $this->template = $template ?: self::CLF;
+    }
 
-  /**
+    /**
    * Returns a formatted message string.
    *
-   * @param \Psr\Http\Message\RequestInterface $request
+   * @param \Psr\Http\Message\RequestInterface  $request
    *   Request that was sent.
    * @param \Psr\Http\Message\ResponseInterface $response
    *   Response that was received.
-   * @param \Exception $error
+   * @param \Exception                          $error
    *   Exception that was received.
    *
    * @return string
    */
-  public function format(
+    public function format(
         RequestInterface $request,
-        ResponseInterface $response = NULL,
-        \Exception $error = NULL
+        ResponseInterface $response = null,
+        \Exception $error = null
     ) {
-    $cache = [];
+        $cache = [];
 
-    return preg_replace_callback(
-        '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',
-        function (array $matches) use ($request, $response, $error, &$cache) {
-
-          if (isset($cache[$matches[1]])) {
-            return $cache[$matches[1]];
-          }
-
-            $result = '';
-          switch ($matches[1]) {
-            case 'request':
-              $result = Psr7\str($request);
-              break;
-
-            case 'response':
-              $result = $response ? Psr7\str($response) : '';
-              break;
-
-            case 'req_headers':
-              $result = trim($request->getMethod()
-                      . ' ' . $request->getRequestTarget())
-                  . ' HTTP/' . $request->getProtocolVersion() . "\r\n"
-                  . $this->headers($request);
-              break;
-
-            case 'res_headers':
-              $result = $response ?
-                  sprintf(
-                      'HTTP/%s %d %s',
-                      $response->getProtocolVersion(),
-                      $response->getStatusCode(),
-                      $response->getReasonPhrase()
-                  ) . "\r\n" . $this->headers($response)
-                  : 'NULL';
-              break;
-
-            case 'req_body':
-              $result = $request->getBody();
-              break;
-
-            case 'res_body':
-              $result = $response ? $response->getBody() : 'NULL';
-              break;
-
-            case 'ts':
-            case 'date_iso_8601':
-              $result = gmdate('c');
-              break;
-
-            case 'date_common_log':
-              $result = date('d/M/Y:H:i:s O');
-              break;
-
-            case 'method':
-              $result = $request->getMethod();
-              break;
-
-            case 'version':
-              $result = $request->getProtocolVersion();
-              break;
-
-            case 'uri':
-            case 'url':
-              $result = $request->getUri();
-              break;
-
-            case 'target':
-              $result = $request->getRequestTarget();
-              break;
-
-            case 'req_version':
-              $result = $request->getProtocolVersion();
-              break;
-
-            case 'res_version':
-              $result = $response
-                  ? $response->getProtocolVersion()
-                  : 'NULL';
-              break;
-
-            case 'host':
-              $result = $request->getHeaderLine('Host');
-              break;
-
-            case 'hostname':
-              $result = gethostname();
-              break;
-
-            case 'code':
-              $result = $response ? $response->getStatusCode() : 'NULL';
-              break;
-
-            case 'phrase':
-              $result = $response ? $response->getReasonPhrase() : 'NULL';
-              break;
-
-            case 'error':
-              $result = $error ? $error->getMessage() : 'NULL';
-              break;
-
-            default:
-              // Handle prefixed dynamic headers.
-              if (strpos($matches[1], 'req_header_') === 0) {
-                $result = $request->getHeaderLine(substr($matches[1], 11));
-              }
-              elseif (strpos($matches[1], 'res_header_') === 0) {
-                  $result = $response
-                      ? $response->getHeaderLine(substr($matches[1], 11))
+        return preg_replace_callback(
+            '/{\s*([A-Za-z_\-\.0-9]+)\s*}/',
+            function (array $matches) use ($request, $response, $error, &$cache) {
+
+                if (isset($cache[$matches[1]])) {
+                    return $cache[$matches[1]];
+                }
+
+                $result = '';
+                switch ($matches[1]) {
+                case 'request':
+                    $result = Psr7\str($request);
+                    break;
+
+                case 'response':
+                    $result = $response ? Psr7\str($response) : '';
+                    break;
+
+                case 'req_headers':
+                    $result = trim(
+                        $request->getMethod()
+                        . ' ' . $request->getRequestTarget()
+                    )
+                      . ' HTTP/' . $request->getProtocolVersion() . "\r\n"
+                      . $this->headers($request);
+                    break;
+
+                case 'res_headers':
+                    $result = $response ?
+                    sprintf(
+                        'HTTP/%s %d %s',
+                        $response->getProtocolVersion(),
+                        $response->getStatusCode(),
+                        $response->getReasonPhrase()
+                    ) . "\r\n" . $this->headers($response)
                       : 'NULL';
-              }
-          }
+                    break;
 
-            $cache[$matches[1]] = $result;
-            return $result;
-        },
-        $this->template
-    );
-  }
+                case 'req_body':
+                    $result = $request->getBody();
+                    break;
+
+                case 'res_body':
+                    $result = $response ? $response->getBody() : 'NULL';
+                    break;
+
+                case 'ts':
+                case 'date_iso_8601':
+                    $result = gmdate('c');
+                    break;
+
+                case 'date_common_log':
+                    $result = date('d/M/Y:H:i:s O');
+                    break;
+
+                case 'method':
+                    $result = $request->getMethod();
+                    break;
+
+                case 'version':
+                    $result = $request->getProtocolVersion();
+                    break;
+
+                case 'uri':
+                case 'url':
+                    $result = $request->getUri();
+                    break;
+
+                case 'target':
+                    $result = $request->getRequestTarget();
+                    break;
+
+                case 'req_version':
+                    $result = $request->getProtocolVersion();
+                    break;
+
+                case 'res_version':
+                    $result = $response
+                    ? $response->getProtocolVersion()
+                    : 'NULL';
+                    break;
+
+                case 'host':
+                    $result = $request->getHeaderLine('Host');
+                    break;
+
+                case 'hostname':
+                    $result = gethostname();
+                    break;
+
+                case 'code':
+                    $result = $response ? $response->getStatusCode() : 'NULL';
+                    break;
+
+                case 'phrase':
+                    $result = $response ? $response->getReasonPhrase() : 'NULL';
+                    break;
+
+                case 'error':
+                    $result = $error ? $error->getMessage() : 'NULL';
+                    break;
+
+                default:
+                    // Handle prefixed dynamic headers.
+                    if (strpos($matches[1], 'req_header_') === 0) {
+                        $result = $request->getHeaderLine(substr($matches[1], 11));
+                    }
+                    elseif (strpos($matches[1], 'res_header_') === 0) {
+                        $result = $response
+                        ? $response->getHeaderLine(substr($matches[1], 11))
+                        : 'NULL';
+                    }
+                }
+
+                $cache[$matches[1]] = $result;
+                return $result;
+            },
+            $this->template
+        );
+    }
 
-  /**
+    /**
    *
    */
-  private function headers(MessageInterface $message) {
-    $result = '';
-    foreach ($message->getHeaders() as $name => $values) {
-      $result .= $name . ': ' . implode(', ', $values) . "\r\n";
-    }
+    private function headers(MessageInterface $message) 
+    {
+        $result = '';
+        foreach ($message->getHeaders() as $name => $values) {
+            $result .= $name . ': ' . implode(', ', $values) . "\r\n";
+        }
 
-    return trim($result);
-  }
+        return trim($result);
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/SeekException.php
+++ PHP_CodeSniffer
@@ -7,23 +7,26 @@
 /**
  * Exception thrown when a seek fails on a stream.
  */
-class SeekException extends \RuntimeException implements GuzzleException {
-  private $stream;
+class SeekException extends \RuntimeException implements GuzzleException
+{
+    private $stream;
 
-  /**
+    /**
    *
    */
-  public function __construct(StreamInterface $stream, $pos = 0, $msg = '') {
-    $this->stream = $stream;
-    $msg = $msg ?: 'Could not seek the stream to position ' . $pos;
-    parent::__construct($msg);
-  }
+    public function __construct(StreamInterface $stream, $pos = 0, $msg = '') 
+    {
+        $this->stream = $stream;
+        $msg = $msg ?: 'Could not seek the stream to position ' . $pos;
+        parent::__construct($msg);
+    }
 
-  /**
+    /**
    * @return \Psr\Http\Message\StreamInterface
    */
-  public function getStream() {
-    return $this->stream;
-  }
+    public function getStream() 
+    {
+        return $this->stream;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/TransferException.php
+++ PHP_CodeSniffer
@@ -5,4 +5,6 @@
 /**
  *
  */
-class TransferException extends \RuntimeException implements GuzzleException {}
+class TransferException extends \RuntimeException implements GuzzleException
+{
+}

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/ServerException.php
+++ PHP_CodeSniffer
@@ -5,4 +5,6 @@
 /**
  * Exception when a server error is encountered (5xx codes)
  */
-class ServerException extends BadResponseException {}
+class ServerException extends BadResponseException
+{
+}

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/ClientException.php
+++ PHP_CodeSniffer
@@ -5,4 +5,6 @@
 /**
  * Exception when a client error is encountered (4xx codes)
  */
-class ClientException extends BadResponseException {}
+class ClientException extends BadResponseException
+{
+}

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/GuzzleException.php
+++ PHP_CodeSniffer
@@ -5,4 +5,6 @@
 /**
  *
  */
-interface GuzzleException {}
+interface GuzzleException
+{
+}

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/BadResponseException.php
+++ PHP_CodeSniffer
@@ -8,25 +8,26 @@
 /**
  * Exception when an HTTP error occurs (4xx or 5xx error)
  */
-class BadResponseException extends RequestException {
+class BadResponseException extends RequestException
+{
 
-  /**
+    /**
    *
    */
-  public function __construct(
+    public function __construct(
         $message,
         RequestInterface $request,
-        ResponseInterface $response = NULL,
-        \Exception $previous = NULL,
+        ResponseInterface $response = null,
+        \Exception $previous = null,
         array $handlerContext = []
     ) {
-    if (NULL === $response) {
-      @trigger_error(
-        'Instantiating the ' . __CLASS__ . ' class without a Response is deprecated since version 6.3 and will be removed in 7.0.',
-        E_USER_DEPRECATED
-      );
+        if (null === $response) {
+            @trigger_error(
+                'Instantiating the ' . __CLASS__ . ' class without a Response is deprecated since version 6.3 and will be removed in 7.0.',
+                E_USER_DEPRECATED
+            );
+        }
+        parent::__construct($message, $request, $response, $previous, $handlerContext);
     }
-    parent::__construct($message, $request, $response, $previous, $handlerContext);
-  }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/TooManyRedirectsException.php
+++ PHP_CodeSniffer
@@ -5,4 +5,6 @@
 /**
  *
  */
-class TooManyRedirectsException extends RequestException {}
+class TooManyRedirectsException extends RequestException
+{
+}

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/ConnectException.php
+++ PHP_CodeSniffer
@@ -9,32 +9,35 @@
  *
  * Note that no response is present for a ConnectException.
  */
-class ConnectException extends RequestException {
+class ConnectException extends RequestException
+{
 
-  /**
+    /**
    *
    */
-  public function __construct(
+    public function __construct(
         $message,
         RequestInterface $request,
-        \Exception $previous = NULL,
+        \Exception $previous = null,
         array $handlerContext = []
     ) {
-    parent::__construct($message, $request, NULL, $previous, $handlerContext);
-  }
+        parent::__construct($message, $request, null, $previous, $handlerContext);
+    }
 
-  /**
+    /**
    * @return null
    */
-  public function getResponse() {
-    return NULL;
-  }
+    public function getResponse() 
+    {
+        return null;
+    }
 
-  /**
+    /**
    * @return bool
    */
-  public function hasResponse() {
-    return FALSE;
-  }
+    public function hasResponse() 
+    {
+        return false;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Exception/RequestException.php
+++ PHP_CodeSniffer
@@ -9,121 +9,126 @@
 /**
  * HTTP Request exception.
  */
-class RequestException extends TransferException {
-  /**
-   * @var \Psr\Http\Message\RequestInterface*/
-  private $request;
+class RequestException extends TransferException
+{
+    /**
+   * @var \Psr\Http\Message\RequestInterface
+*/
+    private $request;
+
+    /**
+   * @var \Psr\Http\Message\ResponseInterface
+*/
+    private $response;
+
+    /**
+   * @var array
+*/
+    private $handlerContext;
 
-  /**
-   * @var \Psr\Http\Message\ResponseInterface*/
-  private $response;
-
-  /**
-   * @var array*/
-  private $handlerContext;
-
-  /**
+    /**
    *
    */
-  public function __construct(
+    public function __construct(
         $message,
         RequestInterface $request,
-        ResponseInterface $response = NULL,
-        \Exception $previous = NULL,
+        ResponseInterface $response = null,
+        \Exception $previous = null,
         array $handlerContext = []
     ) {
-    // Set the code of the exception if the response is set and not future.
-    $code = $response && !($response instanceof PromiseInterface)
+        // Set the code of the exception if the response is set and not future.
+        $code = $response && !($response instanceof PromiseInterface)
             ? $response->getStatusCode()
             : 0;
-    parent::__construct($message, $code, $previous);
-    $this->request = $request;
-    $this->response = $response;
-    $this->handlerContext = $handlerContext;
-  }
+        parent::__construct($message, $code, $previous);
+        $this->request = $request;
+        $this->response = $response;
+        $this->handlerContext = $handlerContext;
+    }
 
-  /**
+    /**
    * Wrap non-RequestExceptions with a RequestException.
    *
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param \Exception $e
+   * @param \Exception                         $e
    *
    * @return RequestException
    */
-  public static function wrapException(RequestInterface $request, \Exception $e) {
-    return $e instanceof RequestException
+    public static function wrapException(RequestInterface $request, \Exception $e) 
+    {
+        return $e instanceof RequestException
             ? $e
-            : new RequestException($e->getMessage(), $request, NULL, $e);
-  }
+            : new RequestException($e->getMessage(), $request, null, $e);
+    }
 
-  /**
+    /**
    * Factory method to create a new exception with a normalized error message.
    *
-   * @param \Psr\Http\Message\RequestInterface $request
+   * @param \Psr\Http\Message\RequestInterface  $request
    *   Request.
    * @param \Psr\Http\Message\ResponseInterface $response
    *   Response received.
-   * @param \Exception $previous
+   * @param \Exception                          $previous
    *   Previous exception.
-   * @param array $ctx
+   * @param array                               $ctx
    *   Optional handler context.
    *
    * @return self
    */
-  public static function create(
+    public static function create(
         RequestInterface $request,
-        ResponseInterface $response = NULL,
-        \Exception $previous = NULL,
+        ResponseInterface $response = null,
+        \Exception $previous = null,
         array $ctx = []
     ) {
-    if (!$response) {
-      return new self(
-        'Error completing request',
-        $request,
-        NULL,
-        $previous,
-        $ctx
-      );
-    }
-
-    $level = (int) floor($response->getStatusCode() / 100);
-    if ($level === 4) {
-      $label = 'Client error';
-      $className = ClientException::class;
-    }
-    elseif ($level === 5) {
-      $label = 'Server error';
-      $className = ServerException::class;
-    }
-    else {
-      $label = 'Unsuccessful request';
-      $className = __CLASS__;
-    }
-
-    $uri = $request->getUri();
-    $uri = static::obfuscateUri($uri);
-
-    // Client Error: `GET /` resulted in a `404 Not Found` response:
-    // <html> ... (truncated)
-    $message = sprintf(
-        '%s: `%s %s` resulted in a `%s %s` response',
-        $label,
-        $request->getMethod(),
-        $uri,
-        $response->getStatusCode(),
-        $response->getReasonPhrase()
-    );
-
-    $summary = static::getResponseBodySummary($response);
+        if (!$response) {
+            return new self(
+            'Error completing request',
+            $request,
+            null,
+            $previous,
+            $ctx
+            );
+        }
+
+        $level = (int) floor($response->getStatusCode() / 100);
+        if ($level === 4) {
+            $label = 'Client error';
+            $className = ClientException::class;
+        }
+        elseif ($level === 5) {
+            $label = 'Server error';
+            $className = ServerException::class;
+        }
+        else {
+            $label = 'Unsuccessful request';
+            $className = __CLASS__;
+        }
+
+        $uri = $request->getUri();
+        $uri = static::obfuscateUri($uri);
+
+        // Client Error: `GET /` resulted in a `404 Not Found` response:
+        // <html> ... (truncated)
+        $message = sprintf(
+            '%s: `%s %s` resulted in a `%s %s` response',
+            $label,
+            $request->getMethod(),
+            $uri,
+            $response->getStatusCode(),
+            $response->getReasonPhrase()
+        );
+
+        $summary = static::getResponseBodySummary($response);
+
+        if ($summary !== null) {
+            $message .= ":\n{$summary}\n";
+        }
 
-    if ($summary !== NULL) {
-      $message .= ":\n{$summary}\n";
+        return new $className($message, $request, $response, $previous, $ctx);
     }
 
-    return new $className($message, $request, $response, $previous, $ctx);
-  }
-
-  /**
+    /**
    * Get a short summary of the response.
    *
    * Will return `null` if the response is not printable.
@@ -132,80 +137,85 @@
    *
    * @return string|null
    */
-  public static function getResponseBodySummary(ResponseInterface $response) {
-    $body = $response->getBody();
+    public static function getResponseBodySummary(ResponseInterface $response) 
+    {
+        $body = $response->getBody();
 
-    if (!$body->isSeekable()) {
-      return NULL;
-    }
+        if (!$body->isSeekable()) {
+            return null;
+        }
 
-    $size = $body->getSize();
+        $size = $body->getSize();
 
-    if ($size === 0) {
-      return NULL;
-    }
+        if ($size === 0) {
+            return null;
+        }
 
-    $summary = $body->read(120);
-    $body->rewind();
+        $summary = $body->read(120);
+        $body->rewind();
 
-    if ($size > 120) {
-      $summary .= ' (truncated...)';
-    }
+        if ($size > 120) {
+            $summary .= ' (truncated...)';
+        }
 
-    // Matches any printable character, including unicode characters:
-    // letters, marks, numbers, punctuation, spacing, and separators.
-    if (preg_match('/[^\pL\pM\pN\pP\pS\pZ\n\r\t]/', $summary)) {
-      return NULL;
-    }
+        // Matches any printable character, including unicode characters:
+        // letters, marks, numbers, punctuation, spacing, and separators.
+        if (preg_match('/[^\pL\pM\pN\pP\pS\pZ\n\r\t]/', $summary)) {
+            return null;
+        }
 
-    return $summary;
-  }
+        return $summary;
+    }
 
-  /**
+    /**
    * Obfuscates URI if there is an username and a password present.
    *
    * @param \Psr\Http\Message\UriInterface $uri
    *
    * @return \Psr\Http\Message\UriInterface
    */
-  private static function obfuscateUri($uri) {
-    $userInfo = $uri->getUserInfo();
+    private static function obfuscateUri($uri) 
+    {
+        $userInfo = $uri->getUserInfo();
 
-    if (FALSE !== ($pos = strpos($userInfo, ':'))) {
-      return $uri->withUserInfo(substr($userInfo, 0, $pos), '***');
-    }
+        if (false !== ($pos = strpos($userInfo, ':'))) {
+            return $uri->withUserInfo(substr($userInfo, 0, $pos), '***');
+        }
 
-    return $uri;
-  }
+        return $uri;
+    }
 
-  /**
+    /**
    * Get the request that caused the exception.
    *
    * @return \Psr\Http\Message\RequestInterface
    */
-  public function getRequest() {
-    return $this->request;
-  }
+    public function getRequest() 
+    {
+        return $this->request;
+    }
 
-  /**
+    /**
    * Get the associated response.
    *
    * @return \Psr\Http\Message\ResponseInterface|null
    */
-  public function getResponse() {
-    return $this->response;
-  }
+    public function getResponse() 
+    {
+        return $this->response;
+    }
 
-  /**
+    /**
    * Check if a response was received.
    *
    * @return bool
    */
-  public function hasResponse() {
-    return $this->response !== NULL;
-  }
+    public function hasResponse() 
+    {
+        return $this->response !== null;
+    }
 
-  /**
+    /**
    * Get contextual information about the error from the underlying handler.
    *
    * The contents of this array will vary depending on which handler you are
@@ -215,8 +225,9 @@
    *
    * @return array
    */
-  public function getHandlerContext() {
-    return $this->handlerContext;
-  }
+    public function getHandlerContext() 
+    {
+        return $this->handlerContext;
+    }
 
 }

--- qed42_activities/vendor/guzzlehttp/guzzle/src/Client.php
+++ PHP_CodeSniffer
@@ -22,12 +22,14 @@
  * @method Promise\PromiseInterface patchAsync(string|UriInterface $uri, array $options = [])
  * @method Promise\PromiseInterface deleteAsync(string|UriInterface $uri, array $options = [])
  */
-class Client implements ClientInterface {
-  /**
-   * @var arrayDefaultrequestoptions*/
-  private $config;
+class Client implements ClientInterface
+{
+    /**
+   * @var arrayDefaultrequestoptions
+*/
+    private $config;
 
-  /**
+    /**
    * Clients accept an array of constructor parameters.
    *
    * Here's an example of creating a client using a base_uri and an array of
@@ -60,164 +62,173 @@
    *
    * @see \GuzzleHttp\RequestOptions for a list of available request options.
    */
-  public function __construct(array $config = []) {
-    if (!isset($config['handler'])) {
-      $config['handler'] = HandlerStack::create();
-    }
-    elseif (!is_callable($config['handler'])) {
-      throw new \InvalidArgumentException('handler must be a callable');
-    }
+    public function __construct(array $config = []) 
+    {
+        if (!isset($config['handler'])) {
+            $config['handler'] = HandlerStack::create();
+        }
+        elseif (!is_callable($config['handler'])) {
+            throw new \InvalidArgumentException('handler must be a callable');
+        }
 
-    // Convert the base_uri to a UriInterface.
-    if (isset($config['base_uri'])) {
-      $config['base_uri'] = Psr7\uri_for($config['base_uri']);
-    }
+        // Convert the base_uri to a UriInterface.
+        if (isset($config['base_uri'])) {
+            $config['base_uri'] = Psr7\uri_for($config['base_uri']);
+        }
 
-    $this->configureDefaults($config);
-  }
+        $this->configureDefaults($config);
+    }
 
-  /**
+    /**
    *
    */
-  public function __call($method, $args) {
-    if (count($args) < 1) {
-      throw new \InvalidArgumentException('Magic request methods require a URI and optional options array');
-    }
+    public function __call($method, $args) 
+    {
+        if (count($args) < 1) {
+            throw new \InvalidArgumentException('Magic request methods require a URI and optional options array');
+        }
 
-    $uri = $args[0];
-    $opts = isset($args[1]) ? $args[1] : [];
+        $uri = $args[0];
+        $opts = isset($args[1]) ? $args[1] : [];
 
-    return substr($method, -5) === 'Async'
+        return substr($method, -5) === 'Async'
             ? $this->requestAsync(substr($method, 0, -5), $uri, $opts)
             : $this->request($method, $uri, $opts);
-  }
+    }
 
-  /**
+    /**
    *
    */
-  public function sendAsync(RequestInterface $request, array $options = []) {
-    // Merge the base URI into the request URI if needed.
-    $options = $this->prepareDefaults($options);
+    public function sendAsync(RequestInterface $request, array $options = []) 
+    {
+        // Merge the base URI into the request URI if needed.
+        $options = $this->prepareDefaults($options);
 
-    return $this->transfer(
-        $request->withUri($this->buildUri($request->getUri(), $options), $request->hasHeader('Host')),
-        $options
-    );
-  }
+        return $this->transfer(
+            $request->withUri($this->buildUri($request->getUri(), $options), $request->hasHeader('Host')),
+            $options
+        );
+    }
 
-  /**
+    /**
    *
    */
-  public function send(RequestInterface $request, array $options = []) {
-    $options[RequestOptions::SYNCHRONOUS] = TRUE;
-    return $this->sendAsync($request, $options)->wait();
-  }
+    public function send(RequestInterface $request, array $options = []) 
+    {
+        $options[RequestOptions::SYNCHRONOUS] = true;
+        return $this->sendAsync($request, $options)->wait();
+    }
 
-  /**
+    /**
    *
    */
-  public function requestAsync($method, $uri = '', array $options = []) {
-    $options = $this->prepareDefaults($options);
-    // Remove request modifying parameter because it can be done up-front.
-    $headers = isset($options['headers']) ? $options['headers'] : [];
-    $body = isset($options['body']) ? $options['body'] : NULL;
-    $version = isset($options['version']) ? $options['version'] : '1.1';
-    // Merge the URI into the base URI.
-    $uri = $this->buildUri($uri, $options);
-    if (is_array($body)) {
-      $this->invalidBody();
-    }
-    $request = new Request($method, $uri, $headers, $body, $version);
-    // Remove the option so that they are not doubly-applied.
-    unset($options['headers'], $options['body'], $options['version']);
+    public function requestAsync($method, $uri = '', array $options = []) 
+    {
+        $options = $this->prepareDefaults($options);
+        // Remove request modifying parameter because it can be done up-front.
+        $headers = isset($options['headers']) ? $options['headers'] : [];
+        $body = isset($options['body']) ? $options['body'] : null;
+        $version = isset($options['version']) ? $options['version'] : '1.1';
+        // Merge the URI into the base URI.
+        $uri = $this->buildUri($uri, $options);
+        if (is_array($body)) {
+            $this->invalidBody();
+        }
+        $request = new Request($method, $uri, $headers, $body, $version);
+        // Remove the option so that they are not doubly-applied.
+        unset($options['headers'], $options['body'], $options['version']);
 
-    return $this->transfer($request, $options);
-  }
+        return $this->transfer($request, $options);
+    }
 
-  /**
+    /**
    *
    */
-  public function request($method, $uri = '', array $options = []) {
-    $options[RequestOptions::SYNCHRONOUS] = TRUE;
-    return $this->requestAsync($method, $uri, $options)->wait();
-  }
+    public function request($method, $uri = '', array $options = []) 
+    {
+        $options[RequestOptions::SYNCHRONOUS] = true;
+        return $this->requestAsync($method, $uri, $options)->wait();
+    }
 
-  /**
+    /**
    *
    */
-  public function getConfig($option = NULL) {
-    return $option === NULL
+    public function getConfig($option = null) 
+    {
+        return $option === null
             ? $this->config
-            : (isset($this->config[$option]) ? $this->config[$option] : NULL);
-  }
+            : (isset($this->config[$option]) ? $this->config[$option] : null);
+    }
 
-  /**
+    /**
    *
    */
-  private function buildUri($uri, array $config) {
-    // For BC we accept null which would otherwise fail in uri_for.
-    $uri = Psr7\uri_for($uri === NULL ? '' : $uri);
+    private function buildUri($uri, array $config) 
+    {
+        // For BC we accept null which would otherwise fail in uri_for.
+        $uri = Psr7\uri_for($uri === null ? '' : $uri);
 
-    if (isset($config['base_uri'])) {
-      $uri = UriResolver::resolve(Psr7\uri_for($config['base_uri']), $uri);
-    }
+        if (isset($config['base_uri'])) {
+            $uri = UriResolver::resolve(Psr7\uri_for($config['base_uri']), $uri);
+        }
 
-    return $uri->getScheme() === '' && $uri->getHost() !== '' ? $uri->withScheme('http') : $uri;
-  }
+        return $uri->getScheme() === '' && $uri->getHost() !== '' ? $uri->withScheme('http') : $uri;
+    }
 
-  /**
+    /**
    * Configures the default options for a client.
    *
    * @param array $config
    */
-  private function configureDefaults(array $config) {
-    $defaults = [
-      'allow_redirects' => RedirectMiddleware::$defaultSettings,
-      'http_errors'     => TRUE,
-      'decode_content'  => TRUE,
-      'verify'          => TRUE,
-      'cookies'         => FALSE,
-    ];
-
-    // Use the standard Linux HTTP_PROXY and HTTPS_PROXY if set.
-    // We can only trust the HTTP_PROXY environment variable in a CLI
-    // process due to the fact that PHP has no reliable mechanism to
-    // get environment variables that start with "HTTP_".
-    if (php_sapi_name() == 'cli' && getenv('HTTP_PROXY')) {
-      $defaults['proxy']['http'] = getenv('HTTP_PROXY');
-    }
+    private function configureDefaults(array $config) 
+    {
+        $defaults = [
+        'allow_redirects' => RedirectMiddleware::$defaultSettings,
+        'http_errors'     => true,
+        'decode_content'  => true,
+        'verify'          => true,
+        'cookies'         => false,
+        ];
+
+        // Use the standard Linux HTTP_PROXY and HTTPS_PROXY if set.
+        // We can only trust the HTTP_PROXY environment variable in a CLI
+        // process due to the fact that PHP has no reliable mechanism to
+        // get environment variables that start with "HTTP_".
+        if (php_sapi_name() == 'cli' && getenv('HTTP_PROXY')) {
+            $defaults['proxy']['http'] = getenv('HTTP_PROXY');
+        }
 
-    if ($proxy = getenv('HTTPS_PROXY')) {
-      $defaults['proxy']['https'] = $proxy;
-    }
+        if ($proxy = getenv('HTTPS_PROXY')) {
+            $defaults['proxy']['https'] = $proxy;
+        }
 
-    if ($noProxy = getenv('NO_PROXY')) {
-      $cleanedNoProxy = str_replace(' ', '', $noProxy);
-      $defaults['proxy']['no'] = explode(',', $cleanedNoProxy);
-    }
+        if ($noProxy = getenv('NO_PROXY')) {
+            $cleanedNoProxy = str_replace(' ', '', $noProxy);
+            $defaults['proxy']['no'] = explode(',', $cleanedNoProxy);
+        }
 
-    $this->config = $config + $defaults;
+        $this->config = $config + $defaults;
 
-    if (!empty($config['cookies']) && $config['cookies'] === TRUE) {
-      $this->config['cookies'] = new CookieJar();
-    }
+        if (!empty($config['cookies']) && $config['cookies'] === true) {
+            $this->config['cookies'] = new CookieJar();
+        }
 
-    // Add the default user-agent header.
-    if (!isset($this->config['headers'])) {
-      $this->config['headers'] = ['User-Agent' => default_user_agent()];
-    }
-    else {
-      // Add the User-Agent header if one was not already set.
-      foreach (array_keys($this->config['headers']) as $name) {
-        if (strtolower($name) === 'user-agent') {
-          return;
+        // Add the default user-agent header.
+        if (!isset($this->config['headers'])) {
+            $this->config['headers'] = ['User-Agent' => default_user_agent()];
+        }
+        else {
+            // Add the User-Agent header if one was not already set.
+            foreach (array_keys($this->config['headers']) as $name) {
+                if (strtolower($name) === 'user-agent') {
+                    return;
+                }
+            }
+            $this->config['headers']['User-Agent'] = default_user_agent();
         }
-      }
-      $this->config['headers']['User-Agent'] = default_user_agent();
     }
-  }
 
-  /**
+    /**
    * Merges default options into the array.
    *
    * @param array $options
@@ -225,210 +236,218 @@
    *
    * @return array
    */
-  private function prepareDefaults($options) {
-    $defaults = $this->config;
+    private function prepareDefaults($options) 
+    {
+        $defaults = $this->config;
+
+        if (!empty($defaults['headers'])) {
+            // Default headers are only added if they are not present.
+            $defaults['_conditional'] = $defaults['headers'];
+            unset($defaults['headers']);
+        }
 
-    if (!empty($defaults['headers'])) {
-      // Default headers are only added if they are not present.
-      $defaults['_conditional'] = $defaults['headers'];
-      unset($defaults['headers']);
-    }
-
-    // Special handling for headers is required as they are added as
-    // conditional headers and as headers passed to a request ctor.
-    if (array_key_exists('headers', $options)) {
-      // Allows default headers to be unset.
-      if ($options['headers'] === NULL) {
-        $defaults['_conditional'] = NULL;
-        unset($options['headers']);
-      }
-      elseif (!is_array($options['headers'])) {
-        throw new \InvalidArgumentException('headers must be an array');
-      }
-    }
-
-    // Shallow merge defaults underneath options.
-    $result = $options + $defaults;
-
-    // Remove null values.
-    foreach ($result as $k => $v) {
-      if ($v === NULL) {
-        unset($result[$k]);
-      }
-    }
+        // Special handling for headers is required as they are added as
+        // conditional headers and as headers passed to a request ctor.
+        if (array_key_exists('headers', $options)) {
+            // Allows default headers to be unset.
+            if ($options['headers'] === null) {
+                $defaults['_conditional'] = null;
+                unset($options['headers']);
+            }
+            elseif (!is_array($options['headers'])) {
+                throw new \InvalidArgumentException('headers must be an array');
+            }
+        }
 
-    return $result;
-  }
+        // Shallow merge defaults underneath options.
+        $result = $options + $defaults;
+
+        // Remove null values.
+        foreach ($result as $k => $v) {
+            if ($v === null) {
+                unset($result[$k]);
+            }
+        }
 
-  /**
+        return $result;
+    }
+
+    /**
    * Transfers the given request and applies request options.
    *
    * The URI of the request is not modified and the request options are used
    * as-is without merging in default options.
    *
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    *
    * @return \GuzzleHttp\Promise\PromiseInterface
    */
-  private function transfer(RequestInterface $request, array $options) {
-    // save_to -> sink.
-    if (isset($options['save_to'])) {
-      $options['sink'] = $options['save_to'];
-      unset($options['save_to']);
-    }
+    private function transfer(RequestInterface $request, array $options) 
+    {
+        // save_to -> sink.
+        if (isset($options['save_to'])) {
+            $options['sink'] = $options['save_to'];
+            unset($options['save_to']);
+        }
 
-    // Exceptions -> http_errors.
-    if (isset($options['exceptions'])) {
-      $options['http_errors'] = $options['exceptions'];
-      unset($options['exceptions']);
-    }
+        // Exceptions -> http_errors.
+        if (isset($options['exceptions'])) {
+            $options['http_errors'] = $options['exceptions'];
+            unset($options['exceptions']);
+        }
 
-    $request = $this->applyOptions($request, $options);
-    $handler = $options['handler'];
+        $request = $this->applyOptions($request, $options);
+        $handler = $options['handler'];
 
-    try {
-      return Promise\promise_for($handler($request, $options));
-    }
-    catch (\Exception $e) {
-      return Promise\rejection_for($e);
+        try {
+            return Promise\promise_for($handler($request, $options));
+        }
+        catch (\Exception $e) {
+            return Promise\rejection_for($e);
+        }
     }
-  }
 
-  /**
+    /**
    * Applies the array of request options to a request.
    *
    * @param \Psr\Http\Message\RequestInterface $request
-   * @param array $options
+   * @param array                              $options
    *
    * @return \Psr\Http\Message\RequestInterface
    */
-  private function applyOptions(RequestInterface $request, array &$options) {
-    $modify = [];
+    private function applyOptions(RequestInterface $request, array &$options) 
+    {
+        $modify = [];
+
+        if (isset($options['form_params'])) {
+            if (isset($options['multipart'])) {
+                throw new \InvalidArgumentException(
+                    'You cannot use '
+                    . 'form_params and multipart at the same time. Use the '
+                    . 'form_params option if you want to send application/'
+                    . 'x-www-form-urlencoded requests, and the multipart '
+                    . 'option to send multipart/form-data requests.'
+                );
+            }
+            $options['body'] = http_build_query($options['form_params'], '', '&');
+            unset($options['form_params']);
+            $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';
+        }
+
+        if (isset($options['multipart'])) {
+            $options['body'] = new MultipartStream($options['multipart']);
+            unset($options['multipart']);
+        }
+
+        if (isset($options['json'])) {
+            $options['body'] = \GuzzleHttp\json_encode($options['json']);
+            unset($options['json']);
+            $options['_conditional']['Content-Type'] = 'application/json';
+        }
+
+        if (!empty($options['decode_content'])
+            && $options['decode_content'] !== true
+        ) {
+            $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];
+        }
 
-    if (isset($options['form_params'])) {
-      if (isset($options['multipart'])) {
-        throw new \InvalidArgumentException('You cannot use '
-        . 'form_params and multipart at the same time. Use the '
-        . 'form_params option if you want to send application/'
-        . 'x-www-form-urlencoded requests, and the multipart '
-        . 'option to send multipart/form-data requests.');
-      }
-      $options['body'] = http_build_query($options['form_params'], '', '&');
-      unset($options['form_params']);
-      $options['_conditional']['Content-Type'] = 'application/x-www-form-urlencoded';
-    }
-
-    if (isset($options['multipart'])) {
-      $options['body'] = new MultipartStream($options['multipart']);
-      unset($options['multipart']);
-    }
-
-    if (isset($options['json'])) {
-      $options['body'] = \GuzzleHttp\json_encode($options['json']);
-      unset($options['json']);
-      $options['_conditional']['Content-Type'] = 'application/json';
-    }
-
-    if (!empty($options['decode_content'])
-        && $options['decode_content'] !== TRUE
-    ) {
-      $modify['set_headers']['Accept-Encoding'] = $options['decode_content'];
-    }
-
-    if (isset($options['headers'])) {
-      if (isset($modify['set_headers'])) {
-        $modify['set_headers'] = $options['headers'] + $modify['set_headers'];
-      }
-      else {
-        $modify['set_headers'] = $options['headers'];
-      }
-      unset($options['headers']);
-    }
-
-    if (isset($options['body'])) {
-      if (is_array($options['body'])) {
-        $this->invalidBody();
-      }
-      $modify['body'] = Psr7\stream_for($options['body']);
-      unset($options['body']);
-    }
-
-    if (!empty($options['auth']) && is_array($options['auth'])) {
-      $value = $options['auth'];
-      $type = isset($value[2]) ? strtolower($value[2]) : 'basic';
-      switch ($type) {
-        case 'basic':
-          $modify['set_headers']['Authorization'] = 'Basic '
-                        . base64_encode("$value[0]:$value[1]");
-          break;
-
-        case 'digest':
-          // @todo: Do not rely on curl
-          $options['curl'][CURLOPT_HTTPAUTH] = CURLAUTH_DIGEST;
-          $options['curl'][CURLOPT_USERPWD] = "$value[0]:$value[1]";
-          break;
-
-        case 'ntlm':
-          $options['curl'][CURLOPT_HTTPAUTH] = CURLAUTH_NTLM;
-          $options['curl'][CURLOPT_USERPWD] = "$value[0]:$value[1]";
-          break;
-      }
-    }
-
-    if (isset($options['query'])) {
-      $value = $options['query'];
-      if (is_array($value)) {
-        $value = http_build_query($value, NULL, '&', PHP_QUERY_RFC3986);
-      }
-      if (!is_string($value)) {
-        throw new \InvalidArgumentException('query must be a string or array');
-      }
-      $modify['query'] = $value;
-      unset($options['query']);
-    }
-
-    // Ensure that sink is not an invalid value.
-    if (isset($options['sink'])) {
-      // TODO: Add more sink validation?
-      if (is_bool($options['sink'])) {
-        throw new \InvalidArgumentException('sink must not be a boolean');
-      }
-    }
-
-    $request = Psr7\modify_request($request, $modify);
-    if ($request->getBody() instanceof MultipartStream) {
-      // Use a multipart/form-data POST if a Content-Type is not set.
-      $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='
+        if (isset($options['headers'])) {
+            if (isset($modify['set_headers'])) {
+                $modify['set_headers'] = $options['headers'] + $modify['set_headers'];
+            }
+            else {
+                $modify['set_headers'] = $options['headers'];
+            }
+            unset($options['headers']);
+        }
+
+        if (isset($options['body'])) {
+            if (is_array($options['body'])) {
+                $this->invalidBody();
+            }
+            $modify['body'] = Psr7\stream_for($options['body']);
+            unset($options['body']);
+        }
+
+        if (!empty($options['auth']) && is_array($options['auth'])) {
+            $value = $options['auth'];
+            $type = isset($value[2]) ? strtolower($value[2]) : 'basic';
+            switch ($type) {
+            case 'basic':
+                $modify['set_headers']['Authorization'] = 'Basic '
+                      . base64_encode("$value[0]:$value[1]");
+                break;
+
+            case 'digest':
+                // @todo: Do not rely on curl
+                $options['curl'][CURLOPT_HTTPAUTH] = CURLAUTH_DIGEST;
+                $options['curl'][CURLOPT_USERPWD] = "$value[0]:$value[1]";
+                break;
+
+            case 'ntlm':
+                $options['curl'][CURLOPT_HTTPAUTH] = CURLAUTH_NTLM;
+                $options['curl'][CURLOPT_USERPWD] = "$value[0]:$value[1]";
+                break;
+            }
+        }
+
+        if (isset($options['query'])) {
+            $value = $options['query'];
+            if (is_array($value)) {
+                $value = http_build_query($value, null, '&', PHP_QUERY_RFC3986);
+            }
+            if (!is_string($value)) {
+                throw new \InvalidArgumentException('query must be a string or array');
+            }
+            $modify['query'] = $value;
+            unset($options['query']);
+        }
+
+        // Ensure that sink is not an invalid value.
+        if (isset($options['sink'])) {
+            // TODO: Add more sink validation?
+            if (is_bool($options['sink'])) {
+                throw new \InvalidArgumentException('sink must not be a boolean');
+            }
+        }
+
+        $request = Psr7\modify_request($request, $modify);
+        if ($request->getBody() instanceof MultipartStream) {
+            // Use a multipart/form-data POST if a Content-Type is not set.
+            $options['_conditional']['Content-Type'] = 'multipart/form-data; boundary='
                 . $request->getBody()->getBoundary();
+        }
+
+        // Merge in conditional headers if they are not present.
+        if (isset($options['_conditional'])) {
+            // Build up the changes so it's in a single clone of the message.
+            $modify = [];
+            foreach ($options['_conditional'] as $k => $v) {
+                if (!$request->hasHeader($k)) {
+                    $modify['set_headers'][$k] = $v;
+                }
+            }
+            $request = Psr7\modify_request($request, $modify);
+            // Don't pass this internal value along to middleware/handlers.
+            unset($options['_conditional']);
+        }
+
+        return $request;
     }
 
-    // Merge in conditional headers if they are not present.
-    if (isset($options['_conditional'])) {
-      // Build up the changes so it's in a single clone of the message.
-      $modify = [];
-      foreach ($options['_conditional'] as $k => $v) {
-        if (!$request->hasHeader($k)) {
-          $modify['set_headers'][$k] = $v;
-        }
-      }
-      $request = Psr7\modify_request($request, $modify);
-      // Don't pass this internal value along to middleware/handlers.
-      unset($options['_conditional']);
-    }
-
-    return $request;
-  }
-
-  /**
-   *
-   */
-  private function invalidBody() {
-    throw new \InvalidArgumentException('Passing in the "body" request '
-        . 'option as an array to send a POST request has been deprecated. '
-        . 'Please use the "form_params" request option to send a '
-        . 'application/x-www-form-urlencoded request, or the "multipart" '
-        . 'request option to send a multipart/form-data request.');
-  }
+    /**
+   *
+   */
+    private function invalidBody() 
+    {
+        throw new \InvalidArgumentException(
+            'Passing in the "body" request '
+            . 'option as an array to send a POST request has been deprecated. '
+            . 'Please use the "form_params" request option to send a '
+            . 'application/x-www-form-urlencoded request, or the "multipart" '
+            . 'request option to send a multipart/form-data request.'
+        );
+    }
 
 }

--- qed42_activities/vendor/composer/ClassLoader.php
+++ PHP_CodeSniffer
@@ -37,301 +37,320 @@
  *
  * @author Fabien Potencier <fabien@symfony.com>
  * @author Jordi Boggiano <j.boggiano@seld.be>
- * @see http://www.php-fig.org/psr/psr-0/
- * @see http://www.php-fig.org/psr/psr-4/
+ * @see    http://www.php-fig.org/psr/psr-0/
+ * @see    http://www.php-fig.org/psr/psr-4/
  */
-class ClassLoader {
-  /**
+class ClassLoader
+{
+    /**
    * PSR-4.
    */
-  private $prefixLengthsPsr4 = [];
-  private $prefixDirsPsr4 = [];
-  private $fallbackDirsPsr4 = [];
+    private $prefixLengthsPsr4 = [];
+    private $prefixDirsPsr4 = [];
+    private $fallbackDirsPsr4 = [];
 
-  /**
+    /**
    * PSR-0.
    */
-  private $prefixesPsr0 = [];
-  private $fallbackDirsPsr0 = [];
+    private $prefixesPsr0 = [];
+    private $fallbackDirsPsr0 = [];
 
-  private $useIncludePath = FALSE;
-  private $classMap = [];
-  private $classMapAuthoritative = FALSE;
-  private $missingClasses = [];
-  private $apcuPrefix;
+    private $useIncludePath = false;
+    private $classMap = [];
+    private $classMapAuthoritative = false;
+    private $missingClasses = [];
+    private $apcuPrefix;
+
+    /**
+   *
+   */
+    public function getPrefixes() 
+    {
+        if (!empty($this->prefixesPsr0)) {
+            return call_user_func_array('array_merge', $this->prefixesPsr0);
+        }
 
-  /**
-   *
-   */
-  public function getPrefixes() {
-    if (!empty($this->prefixesPsr0)) {
-      return call_user_func_array('array_merge', $this->prefixesPsr0);
+        return [];
     }
 
-    return [];
-  }
-
-  /**
+    /**
    *
    */
-  public function getPrefixesPsr4() {
-    return $this->prefixDirsPsr4;
-  }
+    public function getPrefixesPsr4() 
+    {
+        return $this->prefixDirsPsr4;
+    }
 
-  /**
+    /**
    *
    */
-  public function getFallbackDirs() {
-    return $this->fallbackDirsPsr0;
-  }
+    public function getFallbackDirs() 
+    {
+        return $this->fallbackDirsPsr0;
+    }
 
-  /**
+    /**
    *
    */
-  public function getFallbackDirsPsr4() {
-    return $this->fallbackDirsPsr4;
-  }
+    public function getFallbackDirsPsr4() 
+    {
+        return $this->fallbackDirsPsr4;
+    }
 
-  /**
+    /**
    *
    */
-  public function getClassMap() {
-    return $this->classMap;
-  }
+    public function getClassMap() 
+    {
+        return $this->classMap;
+    }
 
-  /**
+    /**
    * @param array $classMap
    *   Class to filename map.
    */
-  public function addClassMap(array $classMap) {
-    if ($this->classMap) {
-      $this->classMap = array_merge($this->classMap, $classMap);
-    }
-    else {
-      $this->classMap = $classMap;
+    public function addClassMap(array $classMap) 
+    {
+        if ($this->classMap) {
+            $this->classMap = array_merge($this->classMap, $classMap);
+        }
+        else {
+            $this->classMap = $classMap;
+        }
     }
-  }
 
-  /**
+    /**
    * Registers a set of PSR-0 directories for a given prefix, either
    * appending or prepending to the ones previously set for this prefix.
    *
-   * @param string $prefix
+   * @param string       $prefix
    *   The prefix.
    * @param array|string $paths
    *   The PSR-0 root directories.
-   * @param bool $prepend
+   * @param bool         $prepend
    *   Whether to prepend the directories.
    */
-  public function add($prefix, $paths, $prepend = FALSE) {
-    if (!$prefix) {
-      if ($prepend) {
-        $this->fallbackDirsPsr0 = array_merge(
-        (array) $paths,
-        $this->fallbackDirsPsr0
-        );
-      }
-      else {
-        $this->fallbackDirsPsr0 = array_merge(
-        $this->fallbackDirsPsr0,
-        (array) $paths
-          );
-      }
-
-      return;
-    }
-
-    $first = $prefix[0];
-    if (!isset($this->prefixesPsr0[$first][$prefix])) {
-      $this->prefixesPsr0[$first][$prefix] = (array) $paths;
-
-      return;
-    }
-    if ($prepend) {
-      $this->prefixesPsr0[$first][$prefix] = array_merge(
-        (array) $paths,
-        $this->prefixesPsr0[$first][$prefix]
-      );
-    }
-    else {
-      $this->prefixesPsr0[$first][$prefix] = array_merge(
-        $this->prefixesPsr0[$first][$prefix],
-        (array) $paths
-        );
+    public function add($prefix, $paths, $prepend = false) 
+    {
+        if (!$prefix) {
+            if ($prepend) {
+                $this->fallbackDirsPsr0 = array_merge(
+                    (array) $paths,
+                    $this->fallbackDirsPsr0
+                );
+            }
+            else {
+                $this->fallbackDirsPsr0 = array_merge(
+                    $this->fallbackDirsPsr0,
+                    (array) $paths
+                );
+            }
+
+            return;
+        }
+
+        $first = $prefix[0];
+        if (!isset($this->prefixesPsr0[$first][$prefix])) {
+            $this->prefixesPsr0[$first][$prefix] = (array) $paths;
+
+            return;
+        }
+        if ($prepend) {
+            $this->prefixesPsr0[$first][$prefix] = array_merge(
+                (array) $paths,
+                $this->prefixesPsr0[$first][$prefix]
+            );
+        }
+        else {
+            $this->prefixesPsr0[$first][$prefix] = array_merge(
+                $this->prefixesPsr0[$first][$prefix],
+                (array) $paths
+            );
+        }
     }
-  }
 
-  /**
+    /**
    * Registers a set of PSR-4 directories for a given namespace, either
    * appending or prepending to the ones previously set for this namespace.
    *
-   * @param string $prefix
+   * @param string       $prefix
    *   The prefix/namespace, with trailing '\\'.
    * @param array|string $paths
    *   The PSR-4 base directories.
-   * @param bool $prepend
+   * @param bool         $prepend
    *   Whether to prepend the directories.
    *
    * @throws \InvalidArgumentException
    */
-  public function addPsr4($prefix, $paths, $prepend = FALSE) {
-    if (!$prefix) {
-      // Register directories for the root namespace.
-      if ($prepend) {
-        $this->fallbackDirsPsr4 = array_merge(
-        (array) $paths,
-        $this->fallbackDirsPsr4
-        );
-      }
-      else {
-        $this->fallbackDirsPsr4 = array_merge(
-        $this->fallbackDirsPsr4,
-        (array) $paths
-          );
-      }
-    }
-    elseif (!isset($this->prefixDirsPsr4[$prefix])) {
-      // Register directories for a new namespace.
-      $length = strlen($prefix);
-      if ('\\' !== $prefix[$length - 1]) {
-        throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
-      }
-      $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
-      $this->prefixDirsPsr4[$prefix] = (array) $paths;
-    }
-    elseif ($prepend) {
-      // Prepend directories for an already registered namespace.
-      $this->prefixDirsPsr4[$prefix] = array_merge(
-        (array) $paths,
-        $this->prefixDirsPsr4[$prefix]
-        );
-    }
-    else {
-      // Append directories for an already registered namespace.
-      $this->prefixDirsPsr4[$prefix] = array_merge(
-        $this->prefixDirsPsr4[$prefix],
-        (array) $paths
-        );
+    public function addPsr4($prefix, $paths, $prepend = false) 
+    {
+        if (!$prefix) {
+            // Register directories for the root namespace.
+            if ($prepend) {
+                $this->fallbackDirsPsr4 = array_merge(
+                    (array) $paths,
+                    $this->fallbackDirsPsr4
+                );
+            }
+            else {
+                $this->fallbackDirsPsr4 = array_merge(
+                    $this->fallbackDirsPsr4,
+                    (array) $paths
+                );
+            }
+        }
+        elseif (!isset($this->prefixDirsPsr4[$prefix])) {
+            // Register directories for a new namespace.
+            $length = strlen($prefix);
+            if ('\\' !== $prefix[$length - 1]) {
+                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
+            }
+            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
+            $this->prefixDirsPsr4[$prefix] = (array) $paths;
+        }
+        elseif ($prepend) {
+            // Prepend directories for an already registered namespace.
+            $this->prefixDirsPsr4[$prefix] = array_merge(
+                (array) $paths,
+                $this->prefixDirsPsr4[$prefix]
+            );
+        }
+        else {
+            // Append directories for an already registered namespace.
+            $this->prefixDirsPsr4[$prefix] = array_merge(
+                $this->prefixDirsPsr4[$prefix],
+                (array) $paths
+            );
+        }
     }
-  }
 
-  /**
+    /**
    * Registers a set of PSR-0 directories for a given prefix,
    * replacing any others previously set for this prefix.
    *
-   * @param string $prefix
+   * @param string       $prefix
    *   The prefix.
    * @param array|string $paths
    *   The PSR-0 base directories.
    */
-  public function set($prefix, $paths) {
-    if (!$prefix) {
-      $this->fallbackDirsPsr0 = (array) $paths;
-    }
-    else {
-      $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
+    public function set($prefix, $paths) 
+    {
+        if (!$prefix) {
+            $this->fallbackDirsPsr0 = (array) $paths;
+        }
+        else {
+            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
+        }
     }
-  }
 
-  /**
+    /**
    * Registers a set of PSR-4 directories for a given namespace,
    * replacing any others previously set for this namespace.
    *
-   * @param string $prefix
+   * @param string       $prefix
    *   The prefix/namespace, with trailing '\\'.
    * @param array|string $paths
    *   The PSR-4 base directories.
    *
    * @throws \InvalidArgumentException
    */
-  public function setPsr4($prefix, $paths) {
-    if (!$prefix) {
-      $this->fallbackDirsPsr4 = (array) $paths;
-    }
-    else {
-      $length = strlen($prefix);
-      if ('\\' !== $prefix[$length - 1]) {
-        throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
-      }
-      $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
-      $this->prefixDirsPsr4[$prefix] = (array) $paths;
+    public function setPsr4($prefix, $paths) 
+    {
+        if (!$prefix) {
+            $this->fallbackDirsPsr4 = (array) $paths;
+        }
+        else {
+            $length = strlen($prefix);
+            if ('\\' !== $prefix[$length - 1]) {
+                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
+            }
+            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
+            $this->prefixDirsPsr4[$prefix] = (array) $paths;
+        }
     }
-  }
 
-  /**
+    /**
    * Turns on searching the include path for class files.
    *
    * @param bool $useIncludePath
    */
-  public function setUseIncludePath($useIncludePath) {
-    $this->useIncludePath = $useIncludePath;
-  }
+    public function setUseIncludePath($useIncludePath) 
+    {
+        $this->useIncludePath = $useIncludePath;
+    }
 
-  /**
+    /**
    * Can be used to check if the autoloader uses the include path to check
    * for classes.
    *
    * @return bool
    */
-  public function getUseIncludePath() {
-    return $this->useIncludePath;
-  }
+    public function getUseIncludePath() 
+    {
+        return $this->useIncludePath;
+    }
 
-  /**
+    /**
    * Turns off searching the prefix and fallback directories for classes
    * that have not been registered with the class map.
    *
    * @param bool $classMapAuthoritative
    */
-  public function setClassMapAuthoritative($classMapAuthoritative) {
-    $this->classMapAuthoritative = $classMapAuthoritative;
-  }
+    public function setClassMapAuthoritative($classMapAuthoritative) 
+    {
+        $this->classMapAuthoritative = $classMapAuthoritative;
+    }
 
-  /**
+    /**
    * Should class lookup fail if not found in the current class map?
    *
    * @return bool
    */
-  public function isClassMapAuthoritative() {
-    return $this->classMapAuthoritative;
-  }
+    public function isClassMapAuthoritative() 
+    {
+        return $this->classMapAuthoritative;
+    }
 
-  /**
+    /**
    * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
    *
    * @param string|null $apcuPrefix
    */
-  public function setApcuPrefix($apcuPrefix) {
-    $this->apcuPrefix = function_exists('apcu_fetch') && ini_get('apc.enabled') ? $apcuPrefix : NULL;
-  }
+    public function setApcuPrefix($apcuPrefix) 
+    {
+        $this->apcuPrefix = function_exists('apcu_fetch') && ini_get('apc.enabled') ? $apcuPrefix : null;
+    }
 
-  /**
+    /**
    * The APCu prefix in use, or null if APCu caching is not enabled.
    *
    * @return string|null
    */
-  public function getApcuPrefix() {
-    return $this->apcuPrefix;
-  }
+    public function getApcuPrefix() 
+    {
+        return $this->apcuPrefix;
+    }
 
-  /**
+    /**
    * Registers this instance as an autoloader.
    *
    * @param bool $prepend
    *   Whether to prepend the autoloader or not.
    */
-  public function register($prepend = FALSE) {
-    spl_autoload_register([$this, 'loadClass'], TRUE, $prepend);
-  }
+    public function register($prepend = false) 
+    {
+        spl_autoload_register([$this, 'loadClass'], true, $prepend);
+    }
 
-  /**
+    /**
    * Unregisters this instance as an autoloader.
    */
-  public function unregister() {
-    spl_autoload_unregister([$this, 'loadClass']);
-  }
+    public function unregister() 
+    {
+        spl_autoload_unregister([$this, 'loadClass']);
+    }
 
-  /**
+    /**
    * Loads the given class or interface.
    *
    * @param string $class
@@ -339,15 +358,16 @@
    *
    * @return bool|null True if loaded, null otherwise
    */
-  public function loadClass($class) {
-    if ($file = $this->findFile($class)) {
-      includeFile($file);
+    public function loadClass($class) 
+    {
+        if ($file = $this->findFile($class)) {
+            includeFile($file);
 
-      return TRUE;
+            return true;
+        }
     }
-  }
 
-  /**
+    /**
    * Finds the path to the file where the class is defined.
    *
    * @param string $class
@@ -355,109 +375,111 @@
    *
    * @return string|false The path if found, false otherwise
    */
-  public function findFile($class) {
-    // Class map lookup.
-    if (isset($this->classMap[$class])) {
-      return $this->classMap[$class];
-    }
-    if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
-      return FALSE;
-    }
-    if (NULL !== $this->apcuPrefix) {
-      $file = apcu_fetch($this->apcuPrefix . $class, $hit);
-      if ($hit) {
-        return $file;
-      }
-    }
+    public function findFile($class) 
+    {
+        // Class map lookup.
+        if (isset($this->classMap[$class])) {
+            return $this->classMap[$class];
+        }
+        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
+            return false;
+        }
+        if (null !== $this->apcuPrefix) {
+            $file = apcu_fetch($this->apcuPrefix . $class, $hit);
+            if ($hit) {
+                return $file;
+            }
+        }
 
-    $file = $this->findFileWithExtension($class, '.php');
+        $file = $this->findFileWithExtension($class, '.php');
 
-    // Search for Hack files if we are running on HHVM.
-    if (FALSE === $file && defined('HHVM_VERSION')) {
-      $file = $this->findFileWithExtension($class, '.hh');
-    }
+        // Search for Hack files if we are running on HHVM.
+        if (false === $file && defined('HHVM_VERSION')) {
+            $file = $this->findFileWithExtension($class, '.hh');
+        }
 
-    if (NULL !== $this->apcuPrefix) {
-      apcu_add($this->apcuPrefix . $class, $file);
-    }
+        if (null !== $this->apcuPrefix) {
+            apcu_add($this->apcuPrefix . $class, $file);
+        }
 
-    if (FALSE === $file) {
-      // Remember that this class does not exist.
-      $this->missingClasses[$class] = TRUE;
-    }
+        if (false === $file) {
+            // Remember that this class does not exist.
+            $this->missingClasses[$class] = true;
+        }
 
-    return $file;
-  }
+        return $file;
+    }
 
-  /**
+    /**
    *
    */
-  private function findFileWithExtension($class, $ext) {
-    // PSR-4 lookup.
-    $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
-
-    $first = $class[0];
-    if (isset($this->prefixLengthsPsr4[$first])) {
-      $subPath = $class;
-      while (FALSE !== $lastPos = strrpos($subPath, '\\')) {
-        $subPath = substr($subPath, 0, $lastPos);
-        $search = $subPath . '\\';
-        if (isset($this->prefixDirsPsr4[$search])) {
-          foreach ($this->prefixDirsPsr4[$search] as $dir) {
-            $length = $this->prefixLengthsPsr4[$first][$search];
-            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
-              return $file;
+    private function findFileWithExtension($class, $ext) 
+    {
+        // PSR-4 lookup.
+        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;
+
+        $first = $class[0];
+        if (isset($this->prefixLengthsPsr4[$first])) {
+            $subPath = $class;
+            while (false !== $lastPos = strrpos($subPath, '\\')) {
+                $subPath = substr($subPath, 0, $lastPos);
+                $search = $subPath . '\\';
+                if (isset($this->prefixDirsPsr4[$search])) {
+                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
+                        $length = $this->prefixLengthsPsr4[$first][$search];
+                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) {
+                            return $file;
+                        }
+                    }
+                }
             }
-          }
         }
-      }
-    }
 
-    // PSR-4 fallback dirs.
-    foreach ($this->fallbackDirsPsr4 as $dir) {
-      if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
-        return $file;
-      }
-    }
+        // PSR-4 fallback dirs.
+        foreach ($this->fallbackDirsPsr4 as $dir) {
+            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
+                return $file;
+            }
+        }
 
-    // PSR-0 lookup.
-    if (FALSE !== $pos = strrpos($class, '\\')) {
-      // Namespaced class name.
-      $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
+        // PSR-0 lookup.
+        if (false !== $pos = strrpos($class, '\\')) {
+            // Namespaced class name.
+            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                 . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
-    }
-    else {
-      // PEAR-like class name.
-      $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
-    }
+        }
+        else {
+            // PEAR-like class name.
+            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
+        }
 
-    if (isset($this->prefixesPsr0[$first])) {
-      foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
-        if (0 === strpos($class, $prefix)) {
-          foreach ($dirs as $dir) {
+        if (isset($this->prefixesPsr0[$first])) {
+            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
+                if (0 === strpos($class, $prefix)) {
+                    foreach ($dirs as $dir) {
+                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
+                            return $file;
+                        }
+                    }
+                }
+            }
+        }
+
+        // PSR-0 fallback dirs.
+        foreach ($this->fallbackDirsPsr0 as $dir) {
             if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
-              return $file;
+                return $file;
             }
-          }
         }
-      }
-    }
 
-    // PSR-0 fallback dirs.
-    foreach ($this->fallbackDirsPsr0 as $dir) {
-      if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
-        return $file;
-      }
-    }
+        // PSR-0 include paths.
+        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
+            return $file;
+        }
 
-    // PSR-0 include paths.
-    if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
-      return $file;
+        return false;
     }
 
-    return FALSE;
-  }
-
 }
 
 /**
@@ -465,6 +487,7 @@
  *
  * Prevents access to $this/self from included files.
  */
-function includeFile($file) {
-  include $file;
+function includeFile($file) 
+{
+    include $file;
 }

--- qed42_activities/vendor/composer/autoload_static.php
+++ PHP_CodeSniffer
@@ -6,67 +6,71 @@
 /**
  *
  */
-class ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d {
-  public static $files = [
+class ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d
+{
+    public static $files = [
     'c964ee0ededf28c96ebd9db5099ef910' => __DIR__ . '/..' . '/guzzlehttp/promises/src/functions_include.php',
     'a0edc8309cc5e1d60e3047b5df6b7052' => __DIR__ . '/..' . '/guzzlehttp/psr7/src/functions_include.php',
     '37a3dc5111fe8f707ab4c132ef1dbc62' => __DIR__ . '/..' . '/guzzlehttp/guzzle/src/functions_include.php',
-  ];
+    ];
 
-  public static $prefixLengthsPsr4 = [
+    public static $prefixLengthsPsr4 = [
     'P' =>
         [
           'Psr\\Http\\Message\\' => 17,
         ],
-    'G' =>
+        'G' =>
         [
           'GuzzleHttp\\Psr7\\' => 16,
           'GuzzleHttp\\Promise\\' => 19,
           'GuzzleHttp\\' => 11,
         ],
-    'A' =>
+        'A' =>
         [
           'AntoineAugusti\\Tests\\Books\\' => 27,
           'AntoineAugusti\\Books\\' => 21,
         ],
-  ];
+    ];
 
-  public static $prefixDirsPsr4 = [
+    public static $prefixDirsPsr4 = [
     'Psr\\Http\\Message\\' =>
         [
           0 => __DIR__ . '/..' . '/psr/http-message/src',
         ],
-    'GuzzleHttp\\Psr7\\' =>
+        'GuzzleHttp\\Psr7\\' =>
         [
           0 => __DIR__ . '/..' . '/guzzlehttp/psr7/src',
         ],
-    'GuzzleHttp\\Promise\\' =>
+        'GuzzleHttp\\Promise\\' =>
         [
           0 => __DIR__ . '/..' . '/guzzlehttp/promises/src',
         ],
-    'GuzzleHttp\\' =>
+        'GuzzleHttp\\' =>
         [
           0 => __DIR__ . '/..' . '/guzzlehttp/guzzle/src',
         ],
-    'AntoineAugusti\\Tests\\Books\\' =>
+        'AntoineAugusti\\Tests\\Books\\' =>
         [
           0 => __DIR__ . '/..' . '/antoineaugusti/google-books/tests',
         ],
-    'AntoineAugusti\\Books\\' =>
+        'AntoineAugusti\\Books\\' =>
         [
           0 => __DIR__ . '/..' . '/antoineaugusti/google-books/src',
         ],
-  ];
+    ];
 
-  /**
+    /**
    *
    */
-  public static function getInitializer(ClassLoader $loader) {
-    return \Closure::bind(function () use ($loader) {
-      $loader->prefixLengthsPsr4 = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$prefixLengthsPsr4;
-      $loader->prefixDirsPsr4 = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$prefixDirsPsr4;
+    public static function getInitializer(ClassLoader $loader) 
+    {
+        return \Closure::bind(
+            function () use ($loader) {
+                $loader->prefixLengthsPsr4 = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$prefixLengthsPsr4;
+                $loader->prefixDirsPsr4 = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$prefixDirsPsr4;
 
-    }, NULL, ClassLoader::class);
-  }
+            }, null, ClassLoader::class
+        );
+    }
 
 }

--- qed42_activities/vendor/composer/autoload_real.php
+++ PHP_CodeSniffer
@@ -14,77 +14,81 @@
 /**
  *
  */
-class ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d {
-  private static $loader;
+class ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d
+{
+    private static $loader;
 
-  /**
+    /**
    *
    */
-  public static function loadClassLoader($class) {
-    if ('Composer\Autoload\ClassLoader' === $class) {
-      require __DIR__ . '/ClassLoader.php';
+    public static function loadClassLoader($class) 
+    {
+        if ('Composer\Autoload\ClassLoader' === $class) {
+            include __DIR__ . '/ClassLoader.php';
+        }
     }
-  }
 
-  /**
+    /**
    *
    */
-  public static function getLoader() {
-    if (NULL !== self::$loader) {
-      return self::$loader;
-    }
-
-    spl_autoload_register(['ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d', 'loadClassLoader'], TRUE, TRUE);
-    self::$loader = $loader = new ClassLoader();
-    spl_autoload_unregister(['ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d', 'loadClassLoader']);
-
-    $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
-    if ($useStaticLoader) {
-      require_once __DIR__ . '/autoload_static.php';
-
-      call_user_func(ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::getInitializer($loader));
-    }
-    else {
-      $map = require __DIR__ . '/autoload_namespaces.php';
-      foreach ($map as $namespace => $path) {
-        $loader->set($namespace, $path);
-      }
-
-      $map = require __DIR__ . '/autoload_psr4.php';
-      foreach ($map as $namespace => $path) {
-        $loader->setPsr4($namespace, $path);
-      }
-
-      $classMap = require __DIR__ . '/autoload_classmap.php';
-      if ($classMap) {
-        $loader->addClassMap($classMap);
-      }
-    }
+    public static function getLoader() 
+    {
+        if (null !== self::$loader) {
+            return self::$loader;
+        }
+
+        spl_autoload_register(['ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d', 'loadClassLoader'], true, true);
+        self::$loader = $loader = new ClassLoader();
+        spl_autoload_unregister(['ComposerAutoloaderInita83ef6705c1fbf96c157ddd9db48ff5d', 'loadClassLoader']);
+
+        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
+        if ($useStaticLoader) {
+            include_once __DIR__ . '/autoload_static.php';
+
+            call_user_func(ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::getInitializer($loader));
+        }
+        else {
+            $map = include __DIR__ . '/autoload_namespaces.php';
+            foreach ($map as $namespace => $path) {
+                $loader->set($namespace, $path);
+            }
+
+            $map = include __DIR__ . '/autoload_psr4.php';
+            foreach ($map as $namespace => $path) {
+                $loader->setPsr4($namespace, $path);
+            }
+
+            $classMap = include __DIR__ . '/autoload_classmap.php';
+            if ($classMap) {
+                $loader->addClassMap($classMap);
+            }
+        }
+
+        $loader->register(true);
+
+        if ($useStaticLoader) {
+            $includeFiles = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$files;
+        }
+        else {
+            $includeFiles = include __DIR__ . '/autoload_files.php';
+        }
+        foreach ($includeFiles as $fileIdentifier => $file) {
+            composerRequirea83ef6705c1fbf96c157ddd9db48ff5d($fileIdentifier, $file);
+        }
 
-    $loader->register(TRUE);
-
-    if ($useStaticLoader) {
-      $includeFiles = ComposerStaticInita83ef6705c1fbf96c157ddd9db48ff5d::$files;
-    }
-    else {
-      $includeFiles = require __DIR__ . '/autoload_files.php';
-    }
-    foreach ($includeFiles as $fileIdentifier => $file) {
-      composerRequirea83ef6705c1fbf96c157ddd9db48ff5d($fileIdentifier, $file);
+        return $loader;
     }
 
-    return $loader;
-  }
-
 }
 
 /**
  *
  */
-function composerRequirea83ef6705c1fbf96c157ddd9db48ff5d($fileIdentifier, $file) {
-  if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
-    require $file;
+function composerRequirea83ef6705c1fbf96c157ddd9db48ff5d($fileIdentifier, $file) 
+{
+    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
+        include $file;
 
-    $GLOBALS['__composer_autoload_files'][$fileIdentifier] = TRUE;
-  }
+        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
+    }
 }

--- qed42_activities/vendor/psr/http-message/src/ServerRequestInterface.php
+++ PHP_CodeSniffer
@@ -40,9 +40,10 @@
  * be implemented such that they retain the internal state of the current
  * message and return an instance that contains the changed state.
  */
-interface ServerRequestInterface extends RequestInterface {
+interface ServerRequestInterface extends RequestInterface
+{
 
-  /**
+    /**
    * Retrieve server parameters.
    *
    * Retrieves data related to the incoming request environment,
@@ -51,9 +52,9 @@
    *
    * @return array
    */
-  public function getServerParams();
+    public function getServerParams();
 
-  /**
+    /**
    * Retrieve cookies.
    *
    * Retrieves cookies sent by the client to the server.
@@ -63,9 +64,9 @@
    *
    * @return array
    */
-  public function getCookieParams();
+    public function getCookieParams();
 
-  /**
+    /**
    * Return an instance with the specified cookies.
    *
    * The data IS NOT REQUIRED to come from the $_COOKIE superglobal, but MUST
@@ -84,9 +85,9 @@
    *
    * @return static
    */
-  public function withCookieParams(array $cookies);
+    public function withCookieParams(array $cookies);
 
-  /**
+    /**
    * Retrieve query string arguments.
    *
    * Retrieves the deserialized query string arguments, if any.
@@ -98,9 +99,9 @@
    *
    * @return array
    */
-  public function getQueryParams();
+    public function getQueryParams();
 
-  /**
+    /**
    * Return an instance with the specified query string arguments.
    *
    * These values SHOULD remain immutable over the course of the incoming
@@ -124,9 +125,9 @@
    *
    * @return static
    */
-  public function withQueryParams(array $query);
+    public function withQueryParams(array $query);
 
-  /**
+    /**
    * Retrieve normalized file upload data.
    *
    * This method returns upload metadata in a normalized tree, with each leaf
@@ -138,9 +139,9 @@
    * @return array An array tree of UploadedFileInterface instances; an empty
    *   array MUST be returned if no data is present.
    */
-  public function getUploadedFiles();
+    public function getUploadedFiles();
 
-  /**
+    /**
    * Create a new instance with the specified uploaded files.
    *
    * This method MUST be implemented in such a way as to retain the
@@ -154,9 +155,9 @@
    *
    * @throws \InvalidArgumentException if an invalid structure is provided.
    */
-  public function withUploadedFiles(array $uploadedFiles);
+    public function withUploadedFiles(array $uploadedFiles);
 
-  /**
+    /**
    * Retrieve any parameters provided in the request body.
    *
    * If the request Content-Type is either application/x-www-form-urlencoded
@@ -171,9 +172,9 @@
    * @return null|array|object The deserialized body parameters, if any.
    *   These will typically be an array or object.
    */
-  public function getParsedBody();
+    public function getParsedBody();
 
-  /**
+    /**
    * Return an instance with the specified body parameters.
    *
    * These MAY be injected during instantiation.
@@ -204,9 +205,9 @@
    * @throws \InvalidArgumentException if an unsupported argument type is
    *     provided.
    */
-  public function withParsedBody($data);
+    public function withParsedBody($data);
 
-  /**
+    /**
    * Retrieve attributes derived from the request.
    *
    * The request "attributes" may be used to allow injection of any
@@ -217,9 +218,9 @@
    *
    * @return array Attributes derived from the request.
    */
-  public function getAttributes();
+    public function getAttributes();
 
-  /**
+    /**
    * Retrieve a single derived request attribute.
    *
    * Retrieves a single derived request attribute as described in
@@ -229,17 +230,17 @@
    * This method obviates the need for a hasAttribute() method, as it allows
    * specifying a default value to return if the attribute is not found.
    *
-   * @see getAttributes()
+   * @see   getAttributes()
    * @param string $name
    *   The attribute name.
-   * @param mixed $default
+   * @param mixed  $default
    *   Default value to return if the attribute does not exist.
    *
    * @return mixed
    */
-  public function getAttribute($name, $default = NULL);
+    public function getAttribute($name, $default = null);
 
-  /**
+    /**
    * Return an instance with the specified derived request attribute.
    *
    * This method allows setting a single derived request attribute as
@@ -249,17 +250,17 @@
    * immutability of the message, and MUST return an instance that has the
    * updated attribute.
    *
-   * @see getAttributes()
+   * @see   getAttributes()
    * @param string $name
    *   The attribute name.
-   * @param mixed $value
+   * @param mixed  $value
    *   The value of the attribute.
    *
    * @return static
    */
-  public function withAttribute($name, $value);
+    public function withAttribute($name, $value);
 
-  /**
+    /**
    * Return an instance that removes the specified derived request attribute.
    *
    * This method allows removing a single derived request attribute as
@@ -269,12 +270,12 @@
    * immutability of the message, and MUST return an instance that removes
    * the attribute.
    *
-   * @see getAttributes()
+   * @see   getAttributes()
    * @param string $name
    *   The attribute name.
    *
    * @return static
    */
-  public function withoutAttribute($name);
+    public function withoutAttribute($name);
 
 }

--- qed42_activities/vendor/psr/http-message/src/UriInterface.php
+++ PHP_CodeSniffer
@@ -22,9 +22,10 @@
  *
  * @link http://tools.ietf.org/html/rfc3986 (the URI specification)
  */
-interface UriInterface {
+interface UriInterface
+{
 
-  /**
+    /**
    * Retrieve the scheme component of the URI.
    *
    * If no scheme is present, this method MUST return an empty string.
@@ -39,9 +40,9 @@
    *
    * @return string The URI scheme.
    */
-  public function getScheme();
+    public function getScheme();
 
-  /**
+    /**
    * Retrieve the authority component of the URI.
    *
    * If no authority information is present, this method MUST return an empty
@@ -60,9 +61,9 @@
    *
    * @return string The URI authority, in "[user-info@]host[:port]" format.
    */
-  public function getAuthority();
+    public function getAuthority();
 
-  /**
+    /**
    * Retrieve the user information component of the URI.
    *
    * If no user information is present, this method MUST return an empty
@@ -77,9 +78,9 @@
    *
    * @return string The URI user information, in "username[:password]" format.
    */
-  public function getUserInfo();
+    public function getUserInfo();
 
-  /**
+    /**
    * Retrieve the host component of the URI.
    *
    * If no host is present, this method MUST return an empty string.
@@ -91,9 +92,9 @@
    *
    * @return string The URI host.
    */
-  public function getHost();
+    public function getHost();
 
-  /**
+    /**
    * Retrieve the port component of the URI.
    *
    * If a port is present, and it is non-standard for the current scheme,
@@ -108,9 +109,9 @@
    *
    * @return null|int The URI port.
    */
-  public function getPort();
+    public function getPort();
 
-  /**
+    /**
    * Retrieve the path component of the URI.
    *
    * The path can either be empty or absolute (starting with a slash) or
@@ -136,9 +137,9 @@
    *
    * @return string The URI path.
    */
-  public function getPath();
+    public function getPath();
 
-  /**
+    /**
    * Retrieve the query string of the URI.
    *
    * If no query string is present, this method MUST return an empty string.
@@ -159,9 +160,9 @@
    *
    * @return string The URI query string.
    */
-  public function getQuery();
+    public function getQuery();
 
-  /**
+    /**
    * Retrieve the fragment component of the URI.
    *
    * If no fragment is present, this method MUST return an empty string.
@@ -178,9 +179,9 @@
    *
    * @return string The URI fragment.
    */
-  public function getFragment();
+    public function getFragment();
 
-  /**
+    /**
    * Return an instance with the specified scheme.
    *
    * This method MUST retain the state of the current instance, and return
@@ -198,9 +199,9 @@
    *
    * @throws \InvalidArgumentException for invalid or unsupported schemes.
    */
-  public function withScheme($scheme);
+    public function withScheme($scheme);
 
-  /**
+    /**
    * Return an instance with the specified user information.
    *
    * This method MUST retain the state of the current instance, and return
@@ -210,16 +211,16 @@
    * user; an empty string for the user is equivalent to removing user
    * information.
    *
-   * @param string $user
+   * @param string      $user
    *   The user name to use for authority.
    * @param null|string $password
    *   The password associated with $user.
    *
    * @return static A new instance with the specified user information.
    */
-  public function withUserInfo($user, $password = NULL);
+    public function withUserInfo($user, $password = null);
 
-  /**
+    /**
    * Return an instance with the specified host.
    *
    * This method MUST retain the state of the current instance, and return
@@ -234,9 +235,9 @@
    *
    * @throws \InvalidArgumentException for invalid hostnames.
    */
-  public function withHost($host);
+    public function withHost($host);
 
-  /**
+    /**
    * Return an instance with the specified port.
    *
    * This method MUST retain the state of the current instance, and return
@@ -256,9 +257,9 @@
    *
    * @throws \InvalidArgumentException for invalid ports.
    */
-  public function withPort($port);
+    public function withPort($port);
 
-  /**
+    /**
    * Return an instance with the specified path.
    *
    * This method MUST retain the state of the current instance, and return
@@ -283,9 +284,9 @@
    *
    * @throws \InvalidArgumentException for invalid paths.
    */
-  public function withPath($path);
+    public function withPath($path);
 
-  /**
+    /**
    * Return an instance with the specified query string.
    *
    * This method MUST retain the state of the current instance, and return
@@ -303,9 +304,9 @@
    *
    * @throws \InvalidArgumentException for invalid query strings.
    */
-  public function withQuery($query);
+    public function withQuery($query);
 
-  /**
+    /**
    * Return an instance with the specified URI fragment.
    *
    * This method MUST retain the state of the current instance, and return
@@ -321,9 +322,9 @@
    *
    * @return static A new instance with the specified fragment.
    */
-  public function withFragment($fragment);
+    public function withFragment($fragment);
 
-  /**
+    /**
    * Return the string representation as a URI reference.
    *
    * Depending on which components of the URI are present, the resulting
@@ -347,6 +348,6 @@
    *
    * @return string
    */
-  public function __toString();
+    public function __toString();
 
 }

--- qed42_activities/vendor/psr/http-message/src/StreamInterface.php
+++ PHP_CodeSniffer
@@ -9,9 +9,10 @@
  * a wrapper around the most common operations, including serialization of
  * the entire stream to a string.
  */
-interface StreamInterface {
+interface StreamInterface
+{
 
-  /**
+    /**
    * Reads all data from the stream into a string, from the beginning to end.
    *
    * This method MUST attempt to seek to the beginning of the stream before
@@ -26,58 +27,58 @@
    *
    * @return string
    */
-  public function __toString();
+    public function __toString();
 
-  /**
+    /**
    * Closes the stream and any underlying resources.
    *
    * @return void
    */
-  public function close();
+    public function close();
 
-  /**
+    /**
    * Separates any underlying resources from the stream.
    *
    * After the stream has been detached, the stream is in an unusable state.
    *
    * @return resource|null Underlying PHP stream, if any
    */
-  public function detach();
+    public function detach();
 
-  /**
+    /**
    * Get the size of the stream if known.
    *
    * @return int|null Returns the size in bytes if known, or null if unknown.
    */
-  public function getSize();
+    public function getSize();
 
-  /**
+    /**
    * Returns the current position of the file read/write pointer.
    *
    * @return int Position of the file pointer
    *
    * @throws \RuntimeException on error.
    */
-  public function tell();
+    public function tell();
 
-  /**
+    /**
    * Returns true if the stream is at the end of the stream.
    *
    * @return bool
    */
-  public function eof();
+    public function eof();
 
-  /**
+    /**
    * Returns whether or not the stream is seekable.
    *
    * @return bool
    */
-  public function isSeekable();
+    public function isSeekable();
 
-  /**
+    /**
    * Seek to a position in the stream.
    *
-   * @link http://www.php.net/manual/en/function.fseek.php
+   * @link  http://www.php.net/manual/en/function.fseek.php
    * @param int $offset
    *   Stream offset.
    * @param int $whence
@@ -89,29 +90,29 @@
    *
    * @throws \RuntimeException on failure.
    */
-  public function seek($offset, $whence = SEEK_SET);
+    public function seek($offset, $whence = SEEK_SET);
 
-  /**
+    /**
    * Seek to the beginning of the stream.
    *
    * If the stream is not seekable, this method will raise an exception;
    * otherwise, it will perform a seek(0).
    *
-   * @see seek()
+   * @see  seek()
    * @link http://www.php.net/manual/en/function.fseek.php
    *
    * @throws \RuntimeException on failure.
    */
-  public function rewind();
+    public function rewind();
 
-  /**
+    /**
    * Returns whether or not the stream is writable.
    *
    * @return bool
    */
-  public function isWritable();
+    public function isWritable();
 
-  /**
+    /**
    * Write data to the stream.
    *
    * @param string $string
@@ -121,16 +122,16 @@
    *
    * @throws \RuntimeException on failure.
    */
-  public function write($string);
+    public function write($string);
 
-  /**
+    /**
    * Returns whether or not the stream is readable.
    *
    * @return bool
    */
-  public function isReadable();
+    public function isReadable();
 
-  /**
+    /**
    * Read data from the stream.
    *
    * @param int $length
@@ -143,9 +144,9 @@
    *
    * @throws \RuntimeException if an error occurs.
    */
-  public function read($length);
+    public function read($length);
 
-  /**
+    /**
    * Returns the remaining contents in a string.
    *
    * @return string
@@ -153,15 +154,15 @@
    * @throws \RuntimeException if unable to read or an error occurs while
    *     reading.
    */
-  public function getContents();
+    public function getContents();
 
-  /**
+    /**
    * Get stream metadata as an associative array or retrieve a specific key.
    *
    * The keys returned are identical to the keys returned from PHP's
    * stream_get_meta_data() function.
    *
-   * @link http://php.net/manual/en/function.stream-get-meta-data.php
+   * @link  http://php.net/manual/en/function.stream-get-meta-data.php
    * @param string $key
    *   Specific metadata to retrieve.
    *
@@ -169,6 +170,6 @@
    *   provided. Returns a specific key value if a key is provided and the
    *     value is found, or null if the key is not found.
    */
-  public function getMetadata($key = NULL);
+    public function getMetadata($key = null);
 
 }

--- qed42_activities/vendor/psr/http-message/src/UploadedFileInterface.php
+++ PHP_CodeSniffer
@@ -10,9 +10,10 @@
  * state of the current instance and return an instance that contains the
  * changed state.
  */
-interface UploadedFileInterface {
+interface UploadedFileInterface
+{
 
-  /**
+    /**
    * Retrieve a stream representing the uploaded file.
    *
    * This method MUST return a StreamInterface instance, representing the
@@ -29,9 +30,9 @@
    * @throws \RuntimeException in cases when no stream is available or can be
    *     created.
    */
-  public function getStream();
+    public function getStream();
 
-  /**
+    /**
    * Move the uploaded file to a new location.
    *
    * Use this method as an alternative to move_uploaded_file(). This method is
@@ -56,8 +57,8 @@
    * If you wish to move to a stream, use getStream(), as SAPI operations
    * cannot guarantee writing to stream destinations.
    *
-   * @see http://php.net/is_uploaded_file
-   * @see http://php.net/move_uploaded_file
+   * @see   http://php.net/is_uploaded_file
+   * @see   http://php.net/move_uploaded_file
    * @param string $targetPath
    *   Path to which to move the uploaded file.
    *
@@ -65,9 +66,9 @@
    * @throws \RuntimeException on any error during the move operation, or on
    *     the second or subsequent call to the method.
    */
-  public function moveTo($targetPath);
+    public function moveTo($targetPath);
 
-  /**
+    /**
    * Retrieve the file size.
    *
    * Implementations SHOULD return the value stored in the "size" key of
@@ -76,9 +77,9 @@
    *
    * @return int|null The file size in bytes or null if unknown.
    */
-  public function getSize();
+    public function getSize();
 
-  /**
+    /**
    * Retrieve the error associated with the uploaded file.
    *
    * The return value MUST be one of PHP's UPLOAD_ERR_XXX constants.
@@ -93,9 +94,9 @@
    *
    * @return int One of PHP's UPLOAD_ERR_XXX constants.
    */
-  public function getError();
+    public function getError();
 
-  /**
+    /**
    * Retrieve the filename sent by the client.
    *
    * Do not trust the value returned by this method. A client could send
@@ -108,9 +109,9 @@
    * @return string|null The filename sent by the client or null if none
    *   was provided.
    */
-  public function getClientFilename();
+    public function getClientFilename();
 
-  /**
+    /**
    * Retrieve the media type sent by the client.
    *
    * Do not trust the value returned by this method. A client could send
@@ -123,6 +124,6 @@
    * @return string|null The media type sent by the client or null if none
    *   was provided.
    */
-  public function getClientMediaType();
+    public function getClientMediaType();
 
 }

--- qed42_activities/vendor/psr/http-message/src/RequestInterface.php
+++ PHP_CodeSniffer
@@ -21,9 +21,10 @@
  * be implemented such that they retain the internal state of the current
  * message and return an instance that contains the changed state.
  */
-interface RequestInterface extends MessageInterface {
+interface RequestInterface extends MessageInterface
+{
 
-  /**
+    /**
    * Retrieves the message's request target.
    *
    * Retrieves the message's request-target either as it will appear (for
@@ -39,9 +40,9 @@
    *
    * @return string
    */
-  public function getRequestTarget();
+    public function getRequestTarget();
 
-  /**
+    /**
    * Return an instance with the specific request-target.
    *
    * If the request needs a non-origin-form request-target — e.g., for
@@ -53,22 +54,22 @@
    * immutability of the message, and MUST return an instance that has the
    * changed request target.
    *
-   * @link http://tools.ietf.org/html/rfc7230#section-5.3 (for the various
+   * @link  http://tools.ietf.org/html/rfc7230#section-5.3 (for the various
    *     request-target forms allowed in request messages)
    * @param mixed $requestTarget
    *
    * @return static
    */
-  public function withRequestTarget($requestTarget);
+    public function withRequestTarget($requestTarget);
 
-  /**
+    /**
    * Retrieves the HTTP method of the request.
    *
    * @return string Returns the request method.
    */
-  public function getMethod();
+    public function getMethod();
 
-  /**
+    /**
    * Return an instance with the provided HTTP method.
    *
    * While HTTP method names are typically all uppercase characters, HTTP
@@ -86,9 +87,9 @@
    *
    * @throws \InvalidArgumentException for invalid HTTP methods.
    */
-  public function withMethod($method);
+    public function withMethod($method);
 
-  /**
+    /**
    * Retrieves the URI instance.
    *
    * This method MUST return a UriInterface instance.
@@ -98,9 +99,9 @@
    * @return UriInterface Returns a UriInterface instance
    *   representing the URI of the request.
    */
-  public function getUri();
+    public function getUri();
 
-  /**
+    /**
    * Returns an instance with the provided URI.
    *
    * This method MUST update the Host header of the returned request by
@@ -125,14 +126,14 @@
    * immutability of the message, and MUST return an instance that has the
    * new UriInterface instance.
    *
-   * @link http://tools.ietf.org/html/rfc3986#section-4.3
+   * @link  http://tools.ietf.org/html/rfc3986#section-4.3
    * @param UriInterface $uri
    *   New request URI to use.
-   * @param bool $preserveHost
+   * @param bool         $preserveHost
    *   Preserve the original state of the Host header.
    *
    * @return static
    */
-  public function withUri(UriInterface $uri, $preserveHost = FALSE);
+    public function withUri(UriInterface $uri, $preserveHost = false);
 
 }

--- qed42_activities/vendor/psr/http-message/src/ResponseInterface.php
+++ PHP_CodeSniffer
@@ -17,9 +17,10 @@
  * be implemented such that they retain the internal state of the current
  * message and return an instance that contains the changed state.
  */
-interface ResponseInterface extends MessageInterface {
+interface ResponseInterface extends MessageInterface
+{
 
-  /**
+    /**
    * Gets the response status code.
    *
    * The status code is a 3-digit integer result code of the server's attempt
@@ -27,9 +28,9 @@
    *
    * @return int Status code.
    */
-  public function getStatusCode();
+    public function getStatusCode();
 
-  /**
+    /**
    * Return an instance with the specified status code and, optionally, reason phrase.
    *
    * If no reason phrase is specified, implementations MAY choose to default
@@ -40,9 +41,9 @@
    * immutability of the message, and MUST return an instance that has the
    * updated status and reason phrase.
    *
-   * @link http://tools.ietf.org/html/rfc7231#section-6
-   * @link http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
-   * @param int $code
+   * @link  http://tools.ietf.org/html/rfc7231#section-6
+   * @link  http://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml
+   * @param int    $code
    *   The 3-digit integer result code to set.
    * @param string $reasonPhrase
    *   The reason phrase to use with the
@@ -53,9 +54,9 @@
    *
    * @throws \InvalidArgumentException For invalid status code arguments.
    */
-  public function withStatus($code, $reasonPhrase = '');
+    public function withStatus($code, $reasonPhrase = '');
 
-  /**
+    /**
    * Gets the response reason phrase associated with the status code.
    *
    * Because a reason phrase is not a required element in a response
@@ -69,6 +70,6 @@
    *
    * @return string Reason phrase; must return an empty string if none present.
    */
-  public function getReasonPhrase();
+    public function getReasonPhrase();
 
 }

--- qed42_activities/vendor/psr/http-message/src/MessageInterface.php
+++ PHP_CodeSniffer
@@ -14,18 +14,19 @@
  * @link http://www.ietf.org/rfc/rfc7230.txt
  * @link http://www.ietf.org/rfc/rfc7231.txt
  */
-interface MessageInterface {
+interface MessageInterface
+{
 
-  /**
+    /**
    * Retrieves the HTTP protocol version as a string.
    *
    * The string MUST contain only the HTTP version number (e.g., "1.1", "1.0").
    *
    * @return string HTTP protocol version.
    */
-  public function getProtocolVersion();
+    public function getProtocolVersion();
 
-  /**
+    /**
    * Return an instance with the specified HTTP protocol version.
    *
    * The version string MUST contain only the HTTP version number (e.g.,
@@ -40,9 +41,9 @@
    *
    * @return static
    */
-  public function withProtocolVersion($version);
+    public function withProtocolVersion($version);
 
-  /**
+    /**
    * Retrieves all message header values.
    *
    * The keys represent the header name as it will be sent over the wire, and
@@ -67,9 +68,9 @@
    *   key MUST be a header name, and each value MUST be an array of strings
    *     for that header.
    */
-  public function getHeaders();
+    public function getHeaders();
 
-  /**
+    /**
    * Checks if a header exists by the given case-insensitive name.
    *
    * @param string $name
@@ -79,9 +80,9 @@
    *   name using a case-insensitive string comparison. Returns false if
    *     no matching header name is found in the message.
    */
-  public function hasHeader($name);
+    public function hasHeader($name);
 
-  /**
+    /**
    * Retrieves a message header value by the given case-insensitive name.
    *
    * This method returns an array of all the header values of the given
@@ -97,9 +98,9 @@
    *   header. If the header does not appear in the message, this method MUST
    *    return an empty array.
    */
-  public function getHeader($name);
+    public function getHeader($name);
 
-  /**
+    /**
    * Retrieves a comma-separated string of the values for a single header.
    *
    * This method returns all of the header values of the given
@@ -120,9 +121,9 @@
    *   concatenated together using a comma. If the header does not appear in
    *    the message, this method MUST return an empty string.
    */
-  public function getHeaderLine($name);
+    public function getHeaderLine($name);
 
-  /**
+    /**
    * Return an instance with the provided value replacing the specified header.
    *
    * While header names are case-insensitive, the casing of the header will
@@ -132,7 +133,7 @@
    * immutability of the message, and MUST return an instance that has the
    * new and/or updated header and value.
    *
-   * @param string $name
+   * @param string          $name
    *   Case-insensitive header field name.
    * @param string|string[] $value
    *   Header value(s).
@@ -141,9 +142,9 @@
    *
    * @throws \InvalidArgumentException for invalid header names or values.
    */
-  public function withHeader($name, $value);
+    public function withHeader($name, $value);
 
-  /**
+    /**
    * Return an instance with the specified header appended with the given value.
    *
    * Existing values for the specified header will be maintained. The new
@@ -154,7 +155,7 @@
    * immutability of the message, and MUST return an instance that has the
    * new header and/or value.
    *
-   * @param string $name
+   * @param string          $name
    *   Case-insensitive header field name to add.
    * @param string|string[] $value
    *   Header value(s).
@@ -163,9 +164,9 @@
    *
    * @throws \InvalidArgumentException for invalid header names or values.
    */
-  public function withAddedHeader($name, $value);
+    public function withAddedHeader($name, $value);
 
-  /**
+    /**
    * Return an instance without the specified header.
    *
    * Header resolution MUST be done without case-sensitivity.
@@ -179,16 +180,16 @@
    *
    * @return static
    */
-  public function withoutHeader($name);
+    public function withoutHeader($name);
 
-  /**
+    /**
    * Gets the body of the message.
    *
    * @return StreamInterface Returns the body as a stream.
    */
-  public function getBody();
+    public function getBody();
 
-  /**
+    /**
    * Return an instance with the specified message body.
    *
    * The body MUST be a StreamInterface object.
@@ -204,6 +205,6 @@
    *
    * @throws \InvalidArgumentException When the body is not valid.
    */
-  public function withBody(StreamInterface $body);
+    public function withBody(StreamInterface $body);
 
 }

--- qed42_activities/src/DICFormService.php
+++ PHP_CodeSniffer
@@ -7,45 +7,49 @@
 /**
  *
  */
-class DICFormService {
-  protected $db_name;
-  protected $connection;
+class DICFormService
+{
+    protected $db_name;
+    protected $connection;
 
-  /**
+    /**
    *
    */
-  public function __construct(Connection $connection) {
-    $this->connection = $connection;
-    $this->db_name = 'd8training';
-  }
+    public function __construct(Connection $connection) 
+    {
+        $this->connection = $connection;
+        $this->db_name = 'd8training';
+    }
 
-  /**
+    /**
    *
    */
-  public function insertFormValue($data) {
-    // Insert data in table.
-    $status = $this->connection->insert('dic_form')
-      ->fields($data)
-      ->execute();
-    return $status;
-  }
+    public function insertFormValue($data) 
+    {
+        // Insert data in table.
+        $status = $this->connection->insert('dic_form')
+            ->fields($data)
+            ->execute();
+        return $status;
+    }
 
-  /**
+    /**
    *
    */
-  public function fetchData() {
-    $result = $this->connection->select('dic_form', 'dic_form')
-      ->fields('dic_form', ['fname', 'lname'])
-      ->orderBy('nid', 'DESC')
-      ->range(0, 1)
-      ->execute();
+    public function fetchData() 
+    {
+        $result = $this->connection->select('dic_form', 'dic_form')
+            ->fields('dic_form', ['fname', 'lname'])
+            ->orderBy('nid', 'DESC')
+            ->range(0, 1)
+            ->execute();
 
-    $output = [];
-    while ($row = $result->fetchAssoc()) {
-      $output['fname'] = $row['fname'];
-      $output['lname'] = $row['lname'];
+        $output = [];
+        while ($row = $result->fetchAssoc()) {
+            $output['fname'] = $row['fname'];
+            $output['lname'] = $row['lname'];
+        }
+        return $output;
     }
-    return $output;
-  }
 
 }

--- qed42_activities/src/Form/DicForm.php
+++ PHP_CodeSniffer
@@ -10,129 +10,135 @@
 /**
  *
  */
-class DicForm extends FormBase {
-  protected $DICFormService;
+class DicForm extends FormBase
+{
+    protected $DICFormService;
 
-  /**
+    /**
    *
    */
-  public function __construct(DICFormService $DICFormService) {
-    $this->DICFormService = $DICFormService;
-  }
+    public function __construct(DICFormService $DICFormService) 
+    {
+        $this->DICFormService = $DICFormService;
+    }
 
-  /**
+    /**
    *
    */
-  public static function create(ContainerInterface $container) {
-    return new static(
-      $container->get('dic_form.fetchservice')
-    );
-  }
+    public static function create(ContainerInterface $container) 
+    {
+        return new static(
+        $container->get('dic_form.fetchservice')
+        );
+    }
 
-  /**
+    /**
    *
    */
-  public function getFormId() {
-    // TODO: Implement getFormId() method.
-    return 'dic_form';
-  }
+    public function getFormId() 
+    {
+        // TODO: Implement getFormId() method.
+        return 'dic_form';
+    }
 
-  /**
+    /**
    *
    */
-  public function buildForm(array $form, FormStateInterface $form_state) {
-    // Fetch data.
-    $user_data = $this->DICFormService->fetchData();
-
-    $form['fname'] = [
-      '#type' => 'textfield',
-      '#title' => 'First Name',
-      '#default_value' => !empty($user_data['fname']) ? $user_data['fname'] : '',
-    ];
-
-    $form['lname'] = [
-      '#type' => 'textfield',
-      '#title' => 'Last Name',
-      '#default_value' => !empty($user_data['lname']) ? $user_data['lname'] : '',
-    ];
-
-    $form['qualification'] = [
-      '#type' => 'select',
-      '#title' => 'Qualification',
-      '#options' => ['UG' => 'U.G.', 'PG' => 'P.G.', 'Other' => 'Other'],
-      '#default_value' => !empty($user_data['qualification']) ? $user_data['qualification'] : '',
-    ];
-
-    $form['other'] = [
-      '#type' => 'textfield',
-      '#title' => 'Please specify other',
-      '#default_value' => !empty($user_data['other']) ? $user_data['other'] : '',
-      '#states' => [
+    public function buildForm(array $form, FormStateInterface $form_state) 
+    {
+        // Fetch data.
+        $user_data = $this->DICFormService->fetchData();
+
+        $form['fname'] = [
+        '#type' => 'textfield',
+        '#title' => 'First Name',
+        '#default_value' => !empty($user_data['fname']) ? $user_data['fname'] : '',
+        ];
+
+        $form['lname'] = [
+        '#type' => 'textfield',
+        '#title' => 'Last Name',
+        '#default_value' => !empty($user_data['lname']) ? $user_data['lname'] : '',
+        ];
+
+        $form['qualification'] = [
+        '#type' => 'select',
+        '#title' => 'Qualification',
+        '#options' => ['UG' => 'U.G.', 'PG' => 'P.G.', 'Other' => 'Other'],
+        '#default_value' => !empty($user_data['qualification']) ? $user_data['qualification'] : '',
+        ];
+
+        $form['other'] = [
+        '#type' => 'textfield',
+        '#title' => 'Please specify other',
+        '#default_value' => !empty($user_data['other']) ? $user_data['other'] : '',
+        '#states' => [
         'visible' => [
           ':input[name="qualification"]' => ['value' => 'Other'],
         ],
-      ],
-    ];
+        ],
+        ];
 
-    $form['country'] = [
-      '#type' => 'select',
-      '#title' => 'Country',
-      '#options' => ['India' => 'India', 'UK' => 'UK'],
-      '#default_value' => !empty($user_data['country']) ? [$user_data['country']] : '',
-    ];
-
-    $form['indian_state'] = [
-      '#type' => 'select',
-      '#title' => 'State',
-      '#options' => ['MH' => 'MH', 'RJ' => 'RJ'],
-      '#default_value' => !empty($user_data['state']) ? $user_data['state'] : '',
-      '#states' => [
+        $form['country'] = [
+        '#type' => 'select',
+        '#title' => 'Country',
+        '#options' => ['India' => 'India', 'UK' => 'UK'],
+        '#default_value' => !empty($user_data['country']) ? [$user_data['country']] : '',
+        ];
+
+        $form['indian_state'] = [
+        '#type' => 'select',
+        '#title' => 'State',
+        '#options' => ['MH' => 'MH', 'RJ' => 'RJ'],
+        '#default_value' => !empty($user_data['state']) ? $user_data['state'] : '',
+        '#states' => [
         'visible' => [
           ':input[name="country"]' => ['value' => 'India'],
         ],
-      ],
-    ];
+        ],
+        ];
 
-    $form['uk_state'] = [
-      '#type' => 'select',
-      '#title' => 'State',
-      '#options' => ['UK' => 'UK'],
-      '#default_value' => !empty($user_data['state']) ? $user_data['state'] : '',
-      '#states' => [
+        $form['uk_state'] = [
+        '#type' => 'select',
+        '#title' => 'State',
+        '#options' => ['UK' => 'UK'],
+        '#default_value' => !empty($user_data['state']) ? $user_data['state'] : '',
+        '#states' => [
         'visible' => [
           ':input[name="country"]' => ['value' => 'UK'],
         ],
-      ],
-    ];
+        ],
+        ];
+
+        $form['submit'] = [
+        '#type' => 'submit',
+        '#value' => t('Submit'),
+        ];
+
+        return $form;
+    }
 
-    $form['submit'] = [
-      '#type' => 'submit',
-      '#value' => t('Submit'),
-    ];
-
-    return $form;
-  }
-
-  // Public function validateForm(array &$form, FormStateInterface $form_state) {
-  // .
-  /**
+    // Public function validateForm(array &$form, FormStateInterface $form_state) {
+    // .
+    /**
    * }.
    */
-  public function submitForm(array &$form, FormStateInterface $form_state) {
-    // TODO: Implement submitForm() method.
-    $user_data = [
-      'fname' => $form_state->getValue('fname'),
-      'lname' => $form_state->getValue('lname'),
-      'qualification' => $form_state->getValue('qualification'),
-      'other' => $form_state->getValue('other'),
-      'country' => $form_state->getValue('country'),
-      'state' => ($form_state->getValue('country') == 'India') ? $form_state->getValue('indian_state') : $form_state->getValue('uk_state'),
-    ];
-
-    // Insert dorm data.
-    if ($this->DICFormService->insertFormValue($user_data)) {
-      drupal_set_message(t('User data saved.'), 'status', TRUE);
+    public function submitForm(array &$form, FormStateInterface $form_state) 
+    {
+        // TODO: Implement submitForm() method.
+        $user_data = [
+        'fname' => $form_state->getValue('fname'),
+        'lname' => $form_state->getValue('lname'),
+        'qualification' => $form_state->getValue('qualification'),
+        'other' => $form_state->getValue('other'),
+        'country' => $form_state->getValue('country'),
+        'state' => ($form_state->getValue('country') == 'India') ? $form_state->getValue('indian_state') : $form_state->getValue('uk_state'),
+        ];
+
+        // Insert dorm data.
+        if ($this->DICFormService->insertFormValue($user_data)) {
+            drupal_set_message(t('User data saved.'), 'status', true);
+        }
     }
-  }
 
 }

